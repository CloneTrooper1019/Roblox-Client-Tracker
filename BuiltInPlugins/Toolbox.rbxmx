<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXE9BE32F473B547DDBAC7B1ED91D8945C">
		<Properties>
			<string name="Name">Toolbox</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX0132D82472B647C0A9B15D2A9963290F">
			<Properties>
				<string name="Name">Core</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX4F830FF4ED26474784D7DACB9D7FE0B2">
				<Properties>
					<string name="Name">Keys</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7CA990A6F5C74FD49E00E30EAA7505D0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">pluginKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local pluginKey = newproxy(true)

getmetatable(pluginKey).__tostring = function()
	return "Symbol(Plugin)"
end

return pluginKey
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2AB9B527D4F44B91BC48520A16D43F8C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">settingsKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local settingsKey = newproxy(true)

getmetatable(settingsKey).__tostring = function()
	return "Symbol(Settings)"
end

return settingsKey
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX74A996A759D84532905DAEAB35DB7B72">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">themeKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local themeKey = newproxy(true)

getmetatable(themeKey).__tostring = function()
	return "Symbol(Theme)"
end

return themeKey
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX07BA24898AA24847A59B9BE8D7A54FEB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">pluginGuiKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local pluginGuiKey = newproxy(true)

getmetatable(pluginGuiKey).__tostring = function()
	return "Symbol(PluginGui)"
end

return pluginGuiKey
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE870052D62CB44A490DA62F3BFB1AB4E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">networkInterfaceKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local networkInterfaceKey = newproxy(true)

getmetatable(networkInterfaceKey).__tostring = function()
	return "Symbol(NetworkInterface)"
end

return networkInterfaceKey
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX6AED3384C8A24249B71BC89E394D022F">
				<Properties>
					<string name="Name">Reducers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX34F6762D9C8A4312BF2F195C08A716E8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ToolboxReducer.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local ToolboxReducer = require(Plugin.Core.Reducers.ToolboxReducer)

	it("should return a table with assets, network errors and page info", function()
		local state = ToolboxReducer(nil, {})

		expect(state).to.be.ok()
		expect(type(state)).to.equal("table")
		expect(state.assets).to.be.ok()
		expect(state.networkErrors).to.be.ok()
		expect(state.pageInfo).to.be.ok()
		expect(state.voting).to.be.ok()
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1A24402A278C46CB99021AD0F4F06E15">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkErrors</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Immutable = require(Plugin.Core.Util.Immutable)

local NetworkError = require(Plugin.Core.Actions.NetworkError)

local function logNetworkError(response)
	warn(("Toolbox network error on %s %s:  (code %s)  %s"):format(
		response.requestType,
		response.url,
		tostring(response.responseCode),
		response.responseBody))
end

return function(state, action)
	state = state or {}
	if action.type == NetworkError.name then
		if DebugFlags.shouldDebugWarnings() then
			logNetworkError(action.response)
		end
		return Immutable.Append(state, action.response)
		-- TODO CLIDEVSRVS-1591: Delay clearing
	end
	return state
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCCBB811EB2AD4168BF8134B3647F55FB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VotingReducer.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local VotingReducer = require(Plugin.Core.Reducers.VotingReducer)

	it("should return a table with the correct members", function()
		local state = VotingReducer(nil, {})

		expect(type(state)).to.equal("table")
	end)

	describe("GetAssets action", function()
	end)

	describe("PostVote action", function()
	end)

	describe("PostUnvote action", function()
	end)

	describe("PostInsertAsset action", function()
	end)

	--[==[
	describe("Post Unvote actions", function()
		it("Voting.HasVoted should be false", function()
			local defaultState = Assets(nil, {})
			local newState = {}
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 2, unvoteResponse = true}})

				expect(newState.itemList.Results[1].Voting.HasVoted).to.equal(false)
			end)
		end)

		it("Other property under Voting shouldn't be changed", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 2, unvoteResponse = true}})

				-- Comparing item one to item two
				local item1Voting = newState.itemList.Results[1].Voting
				local item2Voting = newState.itemList.Results[2].Voting
				expect(item1Voting[HasVoted]).never.equal(item2Voting[HasVoted])
				expect(item1Voting[ShowVotes]).to.equal(item2Voting[ShowVotes])
				expect(item1Voting[CanVote]).to.equal(item2Voting[CanVote])
			end)
		end)
	end)

	describe("Post Vote actions", function()
		it("Voting.HasVoted should be true", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
			--[[ Defualt
				Voting = {
					UserVote = true,
					HasVoted = true,
				}
			]]
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 2, unvoteResponse = true}})
			-- Comparing UserVote and HasVoted
			-- start with
			--[[
				Voting ={
					UserVote = true,
					HasVoted = true,
				},
				Voting ={
					UserVote = true,
					HasVoted = false,
				}
			]]

				-- Check what happens if PostVote on already voted item
				local item1Voting = newState[Results][1][Voting]
				newState = Assets(newState, {type = "PostVote", {assetId = 1, voteResponse = false}})
				expect(item1Voting[UserVote]).to.equal(false)
				expect(item1Voting[HasVoted]).to.equal(true)

				-- Check what happens if PostVote on not voted item
				local item2Voting = newState[Results][2][Voting]
				newState = Assets(newState, {type = "PostVote", {assetId = 2, voteResponse = false}})
				expect(item2Voting[UserVote]).to.equal(false)
				expect(item2Voting[HasVoted]).to.equal(true)
			end)
		end)

		it("Voting.UserVote should be the results from PostVote actions", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 1, unvoteResponse = true}})

				local item1Vote = newState.itemList.Results[1].Voting
				newState = Assets(newState, {type = "PostVote", {assetId = 1, voteResponse = false}})
				expect(item1Vote.HasVoted).to.equal(true)
				expect(item1Vote.UserVote).to.equal(false)

				newState = Assets(newState, {type = "PostVote", {assetId = 1, voteResponse = true}})
				expect(item1Vote.HasVoted).to.equal(true)
				expect(item1Vote.UserVote).to.equal(true)
			end)
		end)
	end)

	describe("Post Insert Asset actions", function()
		it("Voting.ShowVotes should be false by the PostInsertAsset actions", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostInsertAsset", {assetId = 1, insertResponse = true}})

				local item1Voting = newState.itemList.Results[1].Voting
				expect(item1Voting.ShowVotes).to.equal(false)
			end)
		end)

		it("other thing under Voting should be unchanged", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostInsertAsset", {assetId = 1, insertResponse = true}})

				local item1Voting = newState.itemList.Results[1].Voting
				local item2Voting = newState[Results][2][Voting]
				expect(item1Voting[CanVote]).to.equal(item2Voting[CanVote])
				expect(item1Voting[UserVote]).to.equal(item2Voting[UserVote])
				expect(item1Voting[HasVoted]).to.equal(item2Voting[HasVoted])
			end)
		end)
	end)]==]
end


]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX411C6C718DF54AD7B2D987AA3DE9A007">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Immutable = require(Plugin.Core.Util.Immutable)

local PlayPreviewSound = require(Plugin.Core.Actions.PlayPreviewSound)
local PausePreviewSound = require(Plugin.Core.Actions.PausePreviewSound)
local StopPreviewSound = require(Plugin.Core.Actions.StopPreviewSound)
local ResumePreviewSound = require(Plugin.Core.Actions.ResumePreviewSound)
local StopAllSounds = require(Plugin.Core.Actions.StopAllSounds)

return function(state, action)
	state = state or {
		currentSoundId = 0,
		isPlaying = false,
	}

	if action.type == PlayPreviewSound.name then
		if state.currentSoundId == action.currentSoundId and DebugFlags.shouldDebugWarnings() then
			warn("Trying to play the same sound instead of resuming it. Current SoundId : ", action.currentSoundId)
		end

		return Immutable.JoinDictionaries(state, {
			currentSoundId = action.currentSoundId,
			isPlaying = true
		})

	elseif action.type == PausePreviewSound.name  then
		if not state.isPlaying and DebugFlags.shouldDebugWarnings() then
			warn(("Trying to pause a sound that is not playing! Current SoundId : %d"):format(state.currentSoundId))
		end

		return Immutable.JoinDictionaries(state, {
			isPlaying = false
		})

	elseif action.type == StopPreviewSound.name  then
		if not state.isPlaying and DebugFlags.shouldDebugWarnings() then
			warn(("Trying to stop a sound that is not playing! Current SoundId : %d"):format(state.currentSoundId))
		end

		return Immutable.JoinDictionaries(state, {
			currentSoundId = 0,
			isPlaying = false
		})

	elseif action.type == ResumePreviewSound.name  then
		if state.isPlaying and DebugFlags.shouldDebugWarnings() then
			warn(("Trying to resume a sound which is playing! Current SoundId : %d"):format(state.currentSoundId))
		end

		return Immutable.JoinDictionaries(state, {
			isPlaying = true
		})

	elseif action.type == StopAllSounds.name then
		return Immutable.JoinDictionaries(state, {
			currentSoundId = 0,
			isPlaying = false
		})
	end

	return state
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3DB08933DDFB41398AE7CB824DD666C6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Assets.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local ClearAssets = require(Plugin.Core.Actions.ClearAssets)
	local GetAssets = require(Plugin.Core.Actions.GetAssets)
	local SetLoading = require(Plugin.Core.Actions.SetLoading)

	local Assets = require(Plugin.Core.Reducers.Assets)

	local NetworkInterfaceMock = require(Plugin.Core.Networking.NetworkInterfaceMock)

	local networkInterfaceMock = NetworkInterfaceMock.new()

	local function tableLength(tbl)
		local i = 0
		for _ in pairs(tbl) do
			i = i + 1
		end
		return i
	end

	local function generateFakeAssetsFromIds(ids)
		local assets = { }
		for _, id in ipairs(ids) do
			assets[#assets + 1] = {
				Asset = {
					Id = id,
				},
			}
		end
		return assets
	end

	it("should return a table with the correct members", function()
		local state = Assets(nil, {})

		expect(type(state)).to.equal("table")
		expect(state.idToAssetMap).to.be.ok()
		expect(state.idsToRender).to.be.ok()
		expect(state.isLoading).to.be.ok()
		expect(state.totalAssets).to.be.ok()
		expect(state.assetsReceived).to.be.ok()
		expect(state.hasReachedBottom).to.be.ok()
	end)

	describe("ClearAssets action", function()
		it("should clear the correct fields", function()
			local state = Assets(nil, {})

			networkInterfaceMock:resolveAssets(generateFakeAssetsFromIds({1, 2, 3}), 5):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))

				expect(tableLength(state.idToAssetMap)).to.equal(3)
				expect(tableLength(state.idsToRender)).to.equal(3)
				expect(state.totalAssets).to.equal(5)
				expect(state.assetsReceived).to.equal(3)
				expect(state.hasReachedBottom).to.equal(false)

				state = Assets(state, ClearAssets())

				expect(tableLength(state.idToAssetMap)).to.equal(3)
				expect(tableLength(state.idsToRender)).to.equal(0)
				expect(state.totalAssets).to.equal(0)
				expect(state.assetsReceived).to.equal(0)
				expect(state.hasReachedBottom).to.equal(false)
			end)
		end)
	end)

	describe("GetAssets action", function()
		it("should append assets", function()
			local state = Assets(nil, {})
			expect(tableLength(state.idToAssetMap)).to.equal(0)
			expect(tableLength(state.idsToRender)).to.equal(0)
			expect(state.totalAssets).to.equal(0)
			expect(state.assetsReceived).to.equal(0)
			expect(state.hasReachedBottom).to.equal(false)

			local totalAssets = 100 -- Arbitrarily high value as its not being tested in this case

			local firstAssets = generateFakeAssetsFromIds({1, 2, 3})
			local firstAssetsLength = tableLength(firstAssets)

			local secondAssets = generateFakeAssetsFromIds({4, 5})
			local secondAssetsLength = tableLength(secondAssets)

			local totalLength = firstAssetsLength + secondAssetsLength

			networkInterfaceMock:resolveAssets(firstAssets, totalAssets):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)

			expect(tableLength(state.idToAssetMap)).to.equal(firstAssetsLength)
			expect(tableLength(state.idsToRender)).to.equal(firstAssetsLength)
			expect(state.totalAssets).to.equal(totalAssets)
			expect(state.assetsReceived).to.equal(firstAssetsLength)
			expect(state.hasReachedBottom).to.equal(false)

			networkInterfaceMock:resolveAssets(secondAssets, totalAssets):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)

			expect(tableLength(state.idToAssetMap)).to.equal(totalLength)
			expect(tableLength(state.idsToRender)).to.equal(totalLength)
			expect(state.totalAssets).to.equal(totalAssets)
			expect(state.assetsReceived).to.equal(totalLength)
			expect(state.hasReachedBottom).to.equal(false)
		end)

		it("should set total assets correctly", function()
			local state = Assets(nil, {})
			expect(state.totalAssets).to.equal(0)

			-- Send a big number
			networkInterfaceMock:resolveAssets({}, 100):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)
			expect(state.totalAssets).to.equal(100)

			-- Then send a small number
			networkInterfaceMock:resolveAssets({}, 50):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)
			-- Should still be the larger number
			expect(state.totalAssets).to.equal(100)

			-- Then send an even bigger number
			networkInterfaceMock:resolveAssets({}, 600):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)
			-- Should now be the larger number
			expect(state.totalAssets).to.equal(600)
		end)

		it("should set hasReachedBottom", function()
			local state = Assets(nil, {})
			expect(state.hasReachedBottom).to.equal(false)

			networkInterfaceMock:resolveAssets(generateFakeAssetsFromIds({1, 2, 3}), 5):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)

			expect(tableLength(state.idsToRender)).to.equal(3)
			expect(state.totalAssets).to.equal(5)
			expect(state.assetsReceived).to.equal(3)
			expect(state.hasReachedBottom).to.equal(false)

			networkInterfaceMock:resolveAssets(generateFakeAssetsFromIds({4, 5}), 5):andThen(function(results)
				state = Assets(state, GetAssets(results.responseBody))
			end)

			expect(tableLength(state.idsToRender)).to.equal(5)
			expect(state.totalAssets).to.equal(5)
			expect(state.assetsReceived).to.equal(5)
			expect(state.hasReachedBottom).to.equal(true)
		end)
	end)

	describe("PostVote action", function()
	end)

	describe("PostUnvote action", function()
	end)

	describe("PostInsertAsset action", function()
	end)

	describe("SetLoading action", function()
		it("should set loading", function()
			local state = Assets(nil, {})
			expect(state.isLoading).to.equal(false)

			state = Assets(state, SetLoading(false))
			expect(state.isLoading).to.equal(false)

			state = Assets(state, SetLoading(true))
			expect(state.isLoading).to.equal(true)

			state = Assets(state, SetLoading(true))
			expect(state.isLoading).to.equal(true)

			state = Assets(state, SetLoading(false))
			expect(state.isLoading).to.equal(false)
		end)
	end)

	--[==[
	describe("Post Unvote actions", function()
		it("Voting.HasVoted should be false", function()
			local defaultState = Assets(nil, {})
			local newState = {}
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 2, unvoteResponse = true}})

				expect(newState.itemList.Results[1].Voting.HasVoted).to.equal(false)
			end)
		end)

		it("Other property under Voting shouldn't be changed", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 2, unvoteResponse = true}})

				-- Comparing item one to item two
				local item1Voting = newState.itemList.Results[1].Voting
				local item2Voting = newState.itemList.Results[2].Voting
				expect(item1Voting[HasVoted]).never.equal(item2Voting[HasVoted])
				expect(item1Voting[ShowVotes]).to.equal(item2Voting[ShowVotes])
				expect(item1Voting[CanVote]).to.equal(item2Voting[CanVote])
			end)
		end)
	end)

	describe("Post Vote actions", function()
		it("Voting.HasVoted should be true", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
			--[[ Defualt
				Voting = {
					UserVote = true,
					HasVoted = true,
				}
			]]
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 2, unvoteResponse = true}})
			-- Comparing UserVote and HasVoted
			-- start with
			--[[
				Voting ={
					UserVote = true,
					HasVoted = true,
				},
				Voting ={
					UserVote = true,
					HasVoted = false,
				}
			]]

				-- Check what happens if PostVote on already voted item
				local item1Voting = newState[Results][1][Voting]
				newState = Assets(newState, {type = "PostVote", {assetId = 1, voteResponse = false}})
				expect(item1Voting[UserVote]).to.equal(false)
				expect(item1Voting[HasVoted]).to.equal(true)

				-- Check what happens if PostVote on not voted item
				local item2Voting = newState[Results][2][Voting]
				newState = Assets(newState, {type = "PostVote", {assetId = 2, voteResponse = false}})
				expect(item2Voting[UserVote]).to.equal(false)
				expect(item2Voting[HasVoted]).to.equal(true)
			end)
		end)

		it("Voting.UserVote should be the results from PostVote actions", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostUnvote", {assetId = 1, unvoteResponse = true}})

				local item1Vote = newState.itemList.Results[1].Voting
				newState = Assets(newState, {type = "PostVote", {assetId = 1, voteResponse = false}})
				expect(item1Vote.HasVoted).to.equal(true)
				expect(item1Vote.UserVote).to.equal(false)

				newState = Assets(newState, {type = "PostVote", {assetId = 1, voteResponse = true}})
				expect(item1Vote.HasVoted).to.equal(true)
				expect(item1Vote.UserVote).to.equal(true)
			end)
		end)
	end)

	describe("Post Insert Asset actions", function()
		it("Voting.ShowVotes should be false by the PostInsertAsset actions", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostInsertAsset", {assetId = 1, insertResponse = true}})

				local item1Voting = newState.itemList.Results[1].Voting
				expect(item1Voting.ShowVotes).to.equal(false)
			end)
		end)

		it("other thing under Voting should be unchanged", function()
			local defaultState = Assets(nil, {})
			NetworkInterfaceMock:getAssets(nil, nil, nil, 2):andThen(function(results)
				local newState = Assets(defaultState, {type = "GetAssets", itemList = results.responseBody})
				newState = Assets(newState, {type = "PostInsertAsset", {assetId = 1, insertResponse = true}})

				local item1Voting = newState.itemList.Results[1].Voting
				local item2Voting = newState[Results][2][Voting]
				expect(item1Voting[CanVote]).to.equal(item2Voting[CanVote])
				expect(item1Voting[UserVote]).to.equal(item2Voting[UserVote])
				expect(item1Voting[HasVoted]).to.equal(item2Voting[HasVoted])
			end)
		end)
	end)]==]
end


]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB278A60627BA4A4FB970A23248613B73">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PageInfo.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local PageInfoHelper = require(Plugin.Core.Util.PageInfoHelper)

	local Category = require(Plugin.Core.Types.Category)

	local GetManageableGroups = require(Plugin.Core.Actions.GetManageableGroups)
	local NextPage = require(Plugin.Core.Actions.NextPage)
	local UpdatePageInfo = require(Plugin.Core.Actions.UpdatePageInfo)

	local PageInfo = require(Plugin.Core.Reducers.PageInfo)

	local function tableLength(tbl)
		local i = 0
		for _ in pairs(tbl) do
			i = i + 1
		end
		return i
	end

	it("should return a table with the correct members", function()
		local state = PageInfo(nil, {})

		expect(type(state)).to.equal("table")
		expect(state.categories).to.be.ok()
		expect(state.categoryIndex).to.be.ok()
		expect(state.searchTerm).to.be.ok()
		expect(state.sorts).to.be.ok()
		expect(state.sortIndex).to.be.ok()
		expect(state.groups).to.be.ok()
		expect(state.groupIndex).to.be.ok()
		expect(state.page).to.be.ok()
		expect(state.pageSize).to.be.ok()
	end)

	describe("GetManageableGroups action", function()
		it("should set the groups", function()
			local state = PageInfo(nil, {})
			expect(tableLength(state.groups)).to.equal(0)

			local testGroups = {
				{Id = 12345, Name = "Test1"},
				{Id = 67890, Name = "Test2"},
			}

			state = PageInfo(state, GetManageableGroups(testGroups))

			expect(tableLength(state.groups)).to.equal(#testGroups)

			for index, testGroup in ipairs(testGroups) do
				expect(state.groups[index].id).to.equal(testGroup.Id)
				expect(state.groups[index].name).to.equal(testGroup.Name)
			end
		end)

		it("should overwrite previously set groups", function()
			local state = PageInfo(nil, {})
			expect(tableLength(state.groups)).to.equal(0)

			local testGroups = {
				{Id = 12345, Name = "Test1"},
				{Id = 67890, Name = "Test2"},
			}

			state = PageInfo(state, GetManageableGroups(testGroups))

			expect(tableLength(state.groups)).to.equal(#testGroups)

			local nextTestGroups = {
				{Id = 13579, Name = "Test3"},
				{Id = 24680, Name = "Test4"},
			}

			state = PageInfo(state, GetManageableGroups(nextTestGroups))

			expect(tableLength(state.groups)).to.equal(#nextTestGroups)

			for index, testGroup in ipairs(nextTestGroups) do
				expect(state.groups[index].id).to.equal(testGroup.Id)
				expect(state.groups[index].name).to.equal(testGroup.Name)
			end
		end)

		it("should update the categories and group index+id if necessary", function()
			local state = PageInfo(nil, {})
			expect(state.categories).to.equal(Category.CATEGORIES_WITHOUT_GROUPS)
			expect(state.groupIndex).to.equal(0)
			expect(PageInfoHelper.getGroupIdForPageInfo(state)).to.equal(0)

			local firstTestGroups = {
				{Id = 12345, Name = "Test1"},
				{Id = 67890, Name = "Test2"},
			}
			state = PageInfo(state, GetManageableGroups(firstTestGroups))

			expect(state.categories).to.equal(Category.CATEGORIES)
			-- First time we have groups so set groupIndex to 1
			expect(state.groupIndex).to.equal(1)
			expect(PageInfoHelper.getGroupIdForPageInfo(state)).to.equal(firstTestGroups[state.groupIndex].Id)

			-- Change the groups list
			-- Previous selected group id stil exists in new array
			-- So index should change to where it is
			local secondTestGroups = {
				{Id = 13579, Name = "Test3"},
				{Id = 12345, Name = "Test1"},
				{Id = 24680, Name = "Test4"},
			}
			state = PageInfo(state, GetManageableGroups(secondTestGroups))

			expect(state.categories).to.equal(Category.CATEGORIES)
			expect(state.groupIndex).to.equal(2)
			expect(PageInfoHelper.getGroupIdForPageInfo(state)).to.equal(secondTestGroups[state.groupIndex].Id)

			-- Select a group category
			local groupModelsCategoryIndex = 13
			state = PageInfo(state, UpdatePageInfo({
				categoryIndex = groupModelsCategoryIndex,
				category = Category.CATEGORIES[groupModelsCategoryIndex].category
			}))
			expect(state.categoryIndex).to.equal(groupModelsCategoryIndex)

			-- Clear the groups list
			local thirdTestGroups = {}
			state = PageInfo(state, GetManageableGroups(thirdTestGroups))

			-- Categories list should remove groups
			expect(state.categories).to.equal(Category.CATEGORIES_WITHOUT_GROUPS)
			-- Category should be reset to 1 because the groups categories now don't exist
			expect(state.categoryIndex).to.equal(1)
			expect(PageInfoHelper.getCategoryForPageInfo(state)).to.equal(Category.CATEGORIES_WITHOUT_GROUPS[1].category)

			-- Group index and id should be reset to 0
			expect(state.groupIndex).to.equal(0)
			expect(PageInfoHelper.getGroupIdForPageInfo(state)).to.equal(0)
		end)
	end)

	describe("NextPage action", function()
		it("should increment the page", function()
			local state = PageInfo(nil, {})
			expect(state.page).to.equal(1)

			for i = 1, 10, 1 do
				state = PageInfo(state, NextPage())
				expect(state.page).to.equal(i + 1)
			end
		end)
	end)

	describe("UpdatePageInfo action", function()
		it("should update the info", function()
			local state = PageInfo(nil, {})

			expect(state.categoryIndex).to.equal(1)
			expect(state.searchTerm).to.equal("")
			expect(state.sortIndex).to.equal(1)

			state = PageInfo(state, UpdatePageInfo({
				categoryIndex = 2,
				category = state.categories[2].category,
			}))

			expect(state.categoryIndex).to.equal(2)
			expect(state.category).to.equal(state.categories[state.categoryIndex].category)
		end)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7D40596E3E684FE28256544DE86393DA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PageInfoMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Constants = require(Plugin.Core.Util.Constants)

local Category = require(Plugin.Core.Types.Category)
local Sort = require(Plugin.Core.Types.Sort)

return function(state, action)
	local defaultCategories = Category.CATEGORIES_WITHOUT_GROUPS
	local defaultSorts = Sort.SORT_OPTIONS

	return {
		categories = defaultCategories,
		categoryIndex = 1,
		category = defaultCategories[1].category,

		searchTerm = "",

		sorts = defaultSorts,
		sortIndex = 1,
		sortType = defaultSorts[1].sort,

		groups = {},
		groupIndex = 0,
		groupId = 0,

		page = 1,
		pageSize = Constants.GET_ITEMS_PAGE_SIZE,

		selectedBackgroundIndex = 1,
		hoveredBackgroundIndex = 0,
	}
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA8AE66A960A2473C9675F4B17736B00F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SoundMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function(state, action)
	state = state or {
		currentSoundId = 130761235,
		isPlaying = true,
	}

	return state
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXECAB5666B33042A59F9CEEFDEB3FE2A0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ToolboxReducerMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local AssetsMock = require(Plugin.Core.Reducers.AssetsMock)
local NetworkErrorsMock = require(Plugin.Core.Reducers.NetworkErrorsMock)
local PageInfoMock = require(Plugin.Core.Reducers.PageInfoMock)
local VotingReducerMock = require(Plugin.Core.Reducers.VotingReducerMock)

return function(state, action)
	return {
		assets = AssetsMock(state and state.assets, action),
		networkErrors = NetworkErrorsMock(state and state.networkErrors, action),
		pageInfo = PageInfoMock(state and state.pageInfo, action),
		voting = VotingReducerMock(state and state.voting, action),
	}
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA45E8F19C7D94E8BAF763F061050CC55">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AssetsMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function(state, action)
	return {
		idToAssetMap = {},
		idsToRender = {},
		isLoading = false,

		totalAssets = 0,
		assetsReceived = 0,
		hasReachedBottom = false,
	}
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX15EDD12E3E224AD681A74D320EBB69DB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkErrors.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4CBE91F575F14E788ACDE63BB28DDA64">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ReducerLogger</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local maxTableLength = 15

local function getTableLength(t)
	if type(t) ~= "table" then
		return 0
	end
	local l = 0
	for _ in pairs(t) do
		l = l + 1
	end
	return l
end

-- These keys shouldn't be listed in full, just their length
local blacklistKeys = {
	categories = true,
	sorts = true,
}

local function objectToString(name, obj, indent)
	indent = indent or 0
	local tabs = ("\t"):rep(indent)

	local key = tostring(name)
	local value = tostring(obj)

	if type(name) ~= "string" then
		key = ("[%s]"):format(key)
	end

	if type(obj) == "string" then
		value = ("\"%s\""):format(value)
	elseif type(obj) == "table" then
		local length = getTableLength(obj)
		if length > maxTableLength or blacklistKeys[name] then
			value = ("%s (length = %d)"):format(value, length)
		else
			value = "{"
			for k, v in pairs(obj) do
				value = value .. ("\n%s"):format(objectToString(k, v, indent + 1))
			end
			value = value .. ((length > 0) and ("\n%s"):format(tabs) or " ") .. "}"
		end
	end

	return (("%s%s\t = %s"):format(tabs, key, value))
end

return function(reducer, state, action)
	local actionTypeString = action.type and tostring(action.type) or "(action.type == nil)"
	local between = ("-"):rep(40)

	print(between)
	print(("Handling action %s"):format(actionTypeString))
	if action.type == "@@INIT" then
		print(objectToString("State", state, 1))
	end

	print(objectToString(("Action %s"):format(actionTypeString), action, 1))

	local newState = reducer(state, action)

	print(objectToString("New state", newState, 1))

	print(between)
	return newState
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEB89F6D6F6AC43D1BA80CE89F819FC3C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Assets</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Immutable = require(Plugin.Core.Util.Immutable)

local ClearAssets = require(Plugin.Core.Actions.ClearAssets)
local GetAssets = require(Plugin.Core.Actions.GetAssets)
local SetLoading = require(Plugin.Core.Actions.SetLoading)

local function handleAssetsAddedToState(state, assets, totalAssets)
	if not assets then
		if DebugFlags.shouldDebugWarnings() then
			warn("Lua Toolbox: handleAssetsAddedToState() got assets = nil")
		end
		return state
	end

	local newIdToAssetMap = {}
	local newIdsToRender = {}

	for _, asset in ipairs(assets) do
		local id = asset.Asset.Id

		newIdToAssetMap[id] = Immutable.RemoveFromDictionary(asset, "Voting")
		newIdsToRender[#newIdsToRender + 1] = id
	end

	-- Use math.max because sometimes the endpoint returns TotalAssets = 0 even if there results
	local newTotalAssets = math.max(state.totalAssets or 0, totalAssets or 0)
	local newAssetsReceived = (state.assetsReceived or 0) + #newIdsToRender
	local newHasReachedBottom = state.hasReachedBottom or (newAssetsReceived >= newTotalAssets)
		or (#newIdsToRender == 0 and newTotalAssets > 0)

	return Immutable.JoinDictionaries(state, {
		idToAssetMap = Immutable.JoinDictionaries(state.idToAssetMap or {}, newIdToAssetMap),
		idsToRender = Immutable.JoinLists(state.idsToRender or {}, newIdsToRender),

		totalAssets = newTotalAssets,
		assetsReceived = newAssetsReceived,
		hasReachedBottom = newHasReachedBottom,
	})
end

return function(state, action)
	state = state or {
		idToAssetMap = {},
		idsToRender = {},
		isLoading = false,

		totalAssets = 0,
		assetsReceived = 0,
		hasReachedBottom = false,
	}

	if action.type == ClearAssets.name then
		return Immutable.JoinDictionaries(state, {
			idsToRender = {},
			totalAssets = 0,
			assetsReceived = 0,
			hasReachedBottom = false,
		})

	elseif action.type == SetLoading.name then
		return Immutable.JoinDictionaries(state, {
			isLoading = action.isLoading,
		})

	elseif action.type == GetAssets.name then
		return handleAssetsAddedToState(state, action.assets, action.totalResults)
	end

	return state
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX555BBBA9994F460CBD9A5079313E8200">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VotingReducer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Immutable = require(Plugin.Core.Util.Immutable)

local GetAssets = require(Plugin.Core.Actions.GetAssets)
local PostInsertAsset = require(Plugin.Core.Actions.PostInsertAsset)
local PostUnvote = require(Plugin.Core.Actions.PostUnvote)
local PostVote = require(Plugin.Core.Actions.PostVote)

local function handleVoting(state, assetId, voteDirection)
	local userVote = nil
	if voteDirection then
		if voteDirection > 0 then
			userVote = true
		elseif voteDirection < 0 then
			userVote = false
		end
	end

	return Immutable.Set(state, assetId, Immutable.JoinDictionaries(state[assetId], {
		HasVoted = voteDirection ~= 0,
		UserVote = userVote
	}))
end

local function setShowVoteButtons(state, assetId)
	return Immutable.Set(state, assetId, Immutable.JoinDictionaries(state[assetId], {
		showVoteButtons = true,
		CanVote = true,
	}))
end

return function(state, action)
	state = state or {}

	if action.type == GetAssets.name then
		local newVoting = {}
		for _, asset in ipairs(action.assets) do
			newVoting[asset.Asset.Id] = asset.Voting
		end
		return Immutable.JoinDictionaries(state, newVoting)

	elseif action.type == PostInsertAsset.name then
		if action.insertResponse == "true" then
			return setShowVoteButtons(state, action.assetId)
		else
			-- TODO CLIDEVSRVS-1595: Error handling
			if DebugFlags.shouldDebugWarnings() then
				warn("Got false response from PostInsertAsset")
			end
		end

	elseif action.type == PostVote.name then
		if action.voteResponse.Success then
			return handleVoting(state, action.assetId, action.userVote and 1 or -1)
		else
			-- TODO CLIDEVSRVS-1595: Error handling
			if DebugFlags.shouldDebugWarnings() then
				warn("Voting unsucessful")
			end
		end

	elseif action.type == PostUnvote.name then
		if action.unvoteResponse.Success then
			return handleVoting(state, action.assetId, 0)
		else
			-- TODO CLIDEVSRVS-1595: Error handling
			if DebugFlags.shouldDebugWarnings() then
				warn("Unvoting unsucessful")
			end
		end
	end

	return state
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7A1AE6C198AE45D384EFA32216F43646">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PageInfo</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Immutable = require(Plugin.Core.Util.Immutable)
local PageInfoHelper = require(Plugin.Core.Util.PageInfoHelper)

local Category = require(Plugin.Core.Types.Category)
local Sort = require(Plugin.Core.Types.Sort)

local ChangeBackground = require(Plugin.Core.Actions.ChangeBackground)
local GetManageableGroups = require(Plugin.Core.Actions.GetManageableGroups)
local NextPage = require(Plugin.Core.Actions.NextPage)
local UpdatePageInfo = require(Plugin.Core.Actions.UpdatePageInfo)

local function warnIfUpdatePageInfoChangesInvalid(state, changes)
	if changes.categories then
		warn("Lua Toolbox: Cannot change categories array through UpdatePageInfo")
	end

	if changes.sorts then
		warn("Lua Toolbox: Cannot change sorts array through UpdatePageInfo")
	end

	if changes.groups then
		warn("Lua Toolbox: Cannot change groups array through UpdatePageInfo")
	end

	if changes.categoryIndex and (changes.categoryIndex < 1 or changes.categoryIndex > #state.categories) then
		warn("Lua Toolbox: categoryIndex out of range in UpdatePageInfo")
	end

	if changes.sortIndex and (changes.sortIndex < 1 or changes.sortIndex > #state.sorts) then
		warn("Lua Toolbox: sortIndex out of range in UpdatePageInfo")
	end

	-- For groupIndex, allow it to be 0 if #state.groups == 0
	-- Else it has to be >= 1 like the other indices
	if changes.groupIndex and (changes.groupIndex < (#state.groups > 0 and 1 or 0)
		or changes.groupIndex > #state.groups) then
		warn("Lua Toolbox: groupIndex out of range in UpdatePageInfo")
	end

	if changes.categoryIndex and not state.categories[changes.categoryIndex] then
		warn("Lua Toolbox: Changing categoryIndex but category is not valid in UpdatePageInfo")
	end

	if changes.sortIndex and not state.sorts[changes.sortIndex] then
		warn("Lua Toolbox: Changing sortIndex but sortType is not valid in UpdatePageInfo")
	end

	if changes.groupIndex then
		if #state.groups == 0 then
			if changes.groupIndex ~= 0 then
				warn("Lua Toolbox: Changing groupIndex but groupId is not valid in UpdatePageInfo")
			end
		elseif not state.groups[changes.groupIndex] then
			warn("Lua Toolbox: Changing groupIndex but groupId is not valid in UpdatePageInfo")
		end
	end
end

return function(state, action)
	local defaultCategories = Category.CATEGORIES_WITHOUT_GROUPS
	local defaultSorts = Sort.SORT_OPTIONS

	state = state or {
		categories = defaultCategories,
		categoryIndex = 1,

		searchTerm = "",

		sorts = defaultSorts,
		sortIndex = 1,

		groups = {},
		groupIndex = 0,

		page = 1,
		pageSize = Constants.GET_ITEMS_PAGE_SIZE,

		selectedBackgroundIndex = 1,
		hoveredBackgroundIndex = 0,
	}

	if action.type == UpdatePageInfo.name then
		if DebugFlags.shouldDebugWarnings() then
			warnIfUpdatePageInfoChangesInvalid(state, action.changes)
		end

		local newState = Immutable.JoinDictionaries(state, action.changes)

		-- Update the plugin settings. Reducers should be pure functions
		-- but this guarantees that the plugin settings use the most up-
		-- to-date state
		if action.settings then
			action.settings:updateFromPageInfo(newState)
		end

		return newState

	elseif action.type == NextPage.name then
		return Immutable.Set(state, "page", state.page + 1)

	elseif action.type == ChangeBackground.name then
		local newState = Immutable.Set(state, action.selected and "selectedBackgroundIndex" or "hoveredBackgroundIndex", action.index)
		
		if action.settings and action.selected then
			action.settings:setSelectedBackgroundIndex(action.index)
		end

		return newState

	elseif action.type == GetManageableGroups.name then
		local newGroups = {}
		for index, group in ipairs(action.groups) do
			newGroups[index] = {id = group.Id, name = group.Name}
		end

		local newState = Immutable.Set(state, "groups", newGroups)

		if #newGroups > 0 then
			local newIndex = 1
			local oldGroupId = PageInfoHelper.getGroupIdForPageInfo(state)
			-- Check if the ID we had selected exists in the new list
			-- If it does then change index to that
			-- Else set index to 1
			for index, group in ipairs(newGroups) do
				if group.id == oldGroupId then
					newIndex = index
					break
				end
			end

			newState.groupIndex = newIndex
			newState.categories = Category.CATEGORIES

		else
			newState.groupIndex = 0
			newState.categories = Category.CATEGORIES_WITHOUT_GROUPS

			if newState.categoryIndex > #newState.categories then
				newState.categoryIndex = 1
			end
		end

		return newState
	end

	return state
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2A25E33CEB7C430EA43BE786BA593B7C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Sound = require(Plugin.Core.Reducers.Sound)

	it("should return a table with assets, network errors and page info", function()
		local state = Sound(nil, {})

		expect(type(state)).to.equal("table")
		expect(type(state.currentSoundId)).to.equal("number")
		expect(type(state.isPlaying)).to.equal("boolean")
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX819D562345814EC4922A9BFA192BEC9E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkErrorsMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function(state, action)
	return {}
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3CB365400FC24AE6A040D6214AA817B0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VotingReducerMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function(state, action)
	return {}
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD74B44E6B1854A5E8E24486322487957">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ToolboxReducer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)

local Assets = require(Plugin.Core.Reducers.Assets)
local NetworkErrors = require(Plugin.Core.Reducers.NetworkErrors)
local PageInfo = require(Plugin.Core.Reducers.PageInfo)
local ReducerLogger = require(Plugin.Core.Reducers.ReducerLogger)
local Sound = require(Plugin.Core.Reducers.Sound)
local VotingReducer = require(Plugin.Core.Reducers.VotingReducer)

-- TODO CLIDEVSRVS-1595: Error handling/promise rejections

local function ToolboxReducer(state, action)
	return {
		assets = Assets(state and state.assets, action),
		networkErrors = NetworkErrors(state and state.networkErrors, action),
		pageInfo = PageInfo(state and state.pageInfo, action),
		sound = Sound(state and state.sound, action),
		voting = VotingReducer(state and state.voting, action),
	}
end

return function(state, action)
	if DebugFlags.shouldDebugState() then
		return ReducerLogger(ToolboxReducer, state, action)
	else
		return ToolboxReducer(state, action)
	end
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX2AFD6F6E25734946941ADEE443B62DB5">
				<Properties>
					<string name="Name">Actions</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX92804F16164C43E2B7EBB4580E0C2164">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Action</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A helper function to define a Rodux action creator with an associated name.

	Normally when creating a Rodux action, you can just create a function:

		return function(value)
			return {
				type = "MyAction",
				value = value,
			}
		end

	And then when you check for it in your reducer, you either use a constant,
	or type out the string name:

		if action.type == "MyAction" then
			-- change some state
		end

	Typos here are a remarkably common bug. We also have the issue that there's
	no link between reducers and the actions that they respond to!

	`Action` (this helper) provides a utility that makes this a bit cleaner.

	Instead, define your Rodux action like this:

		return Action("MyAction", function(value)
			return {
				value = value,
			}
		end)

	We no longer need to add the `type` field manually.

	Additionally, the returned action creator now has a 'name' property that can
	be checked by your reducer:

		local MyAction = require(Reducers.MyAction)

		...

		if action.type == MyAction.name then
			-- change some state!
		end

	Now we have a clear link between our reducers and the actions they use, and
	if we ever typo a name, we'll get a warning in LuaCheck as well as an error
	at runtime!
]]

return function(name, fn)
	assert(type(name) == "string", "A name must be provided to create an Action")
	assert(type(fn) == "function", "A function must be provided to create an Action")

	return setmetatable({
		name = name,
	}, {
		__call = function(self, ...)
			local result = fn(...)

			assert(type(result) == "table", "An action must return a table")

			result.type = name

			return result
		end
	})
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1AD1B3AB015B420F9BCA2398810F66FE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PausePreviewSound</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function()
	return {}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2C775962F3B74EBCB2BF07E6819ACCAE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Action.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Action = require(Plugin.Core.Actions.Action)

	it("should return a table", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action).to.be.a("table")
	end)

	it("should set the name of the action", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action.name).to.equal("foo")
	end)

	it("should be able to be called as a function", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action).never.to.throw()
	end)

	it("should return a table when called as a function", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action()).to.be.a("table")
	end)

	it("should set the type of the action", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action().type).to.equal("foo")
	end)

	it("should set values", function()
		local action = Action("foo", function(value)
			return {
				value = value
			}
		end)

		expect(action(100).value).to.equal(100)
	end)

	it("should throw when passed a function", function()
		local action = Action("foo", function()
			return function() end
		end)

		expect(action).to.throw()
	end)

	it("should throw with a invalid name", function()
		expect(function()
			Action(nil, function()
				return {}
			end)
		end).to.throw()

		expect(function()
			Action(100, function()
				return {}
			end)
		end).to.throw()
	end)

	it("should throw when passed a invalid function", function()
		expect(function()
			Action("foo", nil)
		end).to.throw()

		expect(function()
			Action("foo", {})
		end).to.throw()
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4B05A0CA2CD940BD98D8333820D7DCEF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ResumePreviewSound</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function()
	return {}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEEE75B9CCF114D3B8A0509901C6B78AE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UpdatePageInfo</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(changes, settings)
	return {
		changes = changes,
		settings = settings,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX62F5531976444FD8A48FE61A70B8F1D4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClearAssets</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function()
	return {}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE77D2C1B9C74490685CF4EB08833215C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SetLoading</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(isLoading)
	return {
		isLoading = isLoading,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX02A8BFF7903A4C139E206BA19F1584BE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NextPage</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function()
	return {}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX76F6BC0F23604531AABD1DABE5333B74">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PostVote</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(assetId, newData, userVote)
	return {
		assetId = assetId,
		voteResponse = newData,
		userVote = userVote,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAC467FA83BAC4633AA7F0802F78BBA40">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PostInsertAsset</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(assetId, newData)
	return {
		assetId = assetId,
		insertResponse = newData,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEF2BD55AAF2C427A91B146B08CAAF773">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ChangeBackground</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(settings, index, selected)
	return {
		settings = settings,
		index = index,
		selected = selected,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6BA27472A7E84411902E52FD5C00A1BF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkError</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(response)
	return {
		response = response,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2F48586ACCCB43B58ADF84EE2CFB9E70">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PostUnvote</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(assetId, newData)
	return {
		assetId = assetId,
		unvoteResponse = newData,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX311E923A4EDE41C98B0794BE888A0027">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayPreviewSound</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(currentSoundId)
	return {
		currentSoundId = currentSoundId,
	}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7E8B562AB9C74EE6A2A1FC9353AFCF32">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GetAssets</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(newData)
	return {
		assets = newData.Results,
		totalResults = newData.TotalResults,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX98FED718328D49AD9DFE2174164F72C6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StopAllSounds</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function()
	return {}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB4A29456D6904F0E945E778193C2EA2F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GetManageableGroups</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function(groups)
	return {
		groups = groups,
	}
end)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8A03D96B36B849FE8AAF5168A0415ED8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StopPreviewSound</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Action = require(Plugin.Core.Actions.Action)

return Action(script.Name, function()
	return {}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBX2C10A7866D394E97BF30F58CF91F34B9">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">main</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[if not plugin or not settings():GetFFlag("StudioLuaWidgetToolbox") then
	return
end

local Plugin = script.Parent.Parent

-- TODO CLILUACORE-295: With the core packages rewrite, this loop might be unnecessary
-- Currently, CorePackages isn't guarenteed to exist when plugins start running
-- So wait until it exists
local CorePackages
repeat
	wait()
	CorePackages = game:FindService("CorePackages")
until CorePackages

local Roact = require(CorePackages:WaitForChild("Roact"))
local Rodux = require(CorePackages:WaitForChild("Rodux"))

local Analytics = require(Plugin.Core.Util.Analytics.Analytics)
local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)
local Settings = require(Plugin.Core.Util.Settings)
local ToolboxTheme = require(Plugin.Core.Util.ToolboxTheme)

local Background = require(Plugin.Core.Types.Background)
local Suggestion = require(Plugin.Core.Types.Suggestion)

local ExternalServicesWrapper = require(Plugin.Core.Components.ExternalServicesWrapper)
local Toolbox = require(Plugin.Core.Components.Toolbox)

local ToolboxReducer = require(Plugin.Core.Reducers.ToolboxReducer)

local NetworkInterface = require(Plugin.Core.Networking.NetworkInterface)

-- TODO CLIDEVSRVS-1357: Improve mouse manager with support for changing icons, or remove it
-- Probably create a MouseProvider and MouseConsumer using Roact context
MouseManager:setPlugin(plugin)
MouseManager:clearIcons()

if DebugFlags.shouldRunTests() then
	local Tests = Plugin.Core
	local RunToolboxTests = require(Plugin.Core.RunToolboxTests)
	RunToolboxTests(Tests)
end

local function createTheme()
	if ToolboxTheme.enableLuaApisForTheme() then
		return ToolboxTheme.new({
			getTheme = function()
				return settings().Studio.Theme
			end,
			isDarkerTheme = function()
				-- Assume "darker" theme if the average main background colour is darker
				local mainColour = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground)
				return (mainColour.r + mainColour.g + mainColour.b) / 3 < 0.5
			end,
			themeChanged = settings().Studio.ThemeChanged,
		})
	else
		return ToolboxTheme.new({
			getTheme = function()
				return settings().Studio["UI Theme"]
			end,
			isDarkerTheme = function()
				return settings().Studio["UI Theme"] == Enum.UITheme.Dark
			end,
			themeChanged = settings().Studio:GetPropertyChangedSignal("UI Theme")
		})
	end
end

local function createToolbox(pluginGui)
	local store = Rodux.Store.new(ToolboxReducer, nil, {
		Rodux.thunkMiddleware
	})
	local settings = Settings.new(plugin)
	local theme = createTheme()
	local networkInterface = NetworkInterface.new()

	local props = {
		initialWidth = pluginGui and pluginGui.AbsoluteSize.x or Constants.TOOLBOX_MIN_WIDTH,
		backgrounds = Background.BACKGROUNDS,
		suggestions = Suggestion.SUGGESTIONS,
	}

	return Roact.createElement(ExternalServicesWrapper, {
		store = store,
		plugin = plugin,
		pluginGui = pluginGui,
		settings = settings,
		theme = theme,
		networkInterface = networkInterface,
	}, {
		Toolbox = Roact.createElement(Toolbox, props)
	})
end

local function main()
	local toolbar = plugin:CreateToolbar("luaToolboxToolbar")
	local toolboxButton = toolbar:CreateButton("luaToolboxButton", "Insert items from the toolbox", Images.TOOLBOX_ICON)

	local dockWidgetPluginGuiInfo = DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Left, true, false,
		0, 0, Constants.TOOLBOX_MIN_WIDTH, Constants.TOOLBOX_MIN_HEIGHT)
	local pluginGui = plugin:CreateDockWidgetPluginGui("Toolbox", dockWidgetPluginGuiInfo)
	pluginGui.Name = "Toolbox"
	pluginGui.Title = "Toolbox"
	pluginGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	toolboxButton.Click:connect(function()
		pluginGui.Enabled = not pluginGui.Enabled
	end)

	toolboxButton:SetActive(pluginGui.Enabled)

	pluginGui:GetPropertyChangedSignal("Enabled"):connect(function()
		toolboxButton:SetActive(pluginGui.Enabled)
	end)

	local toolboxComponent = createToolbox(pluginGui)
	local toolboxHandle = Roact.mount(toolboxComponent, pluginGui, "Toolbox")

	-- Unmount the toolbox when the plugin gui is being destroyed
	pluginGui.AncestryChanged:connect(function(child, parent)
		if parent == nil and toolboxHandle then
			Analytics.sendReports(plugin)

			Roact.unmount(toolboxHandle)
		end
	end)
end

main()
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX549B1DDFE283498B8B45FFDEBA611D36">
				<Properties>
					<string name="Name">Networking</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC6155667A14E423797A92A737DA67A3D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkInterfaceMock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	NetworkingMock

	Provide dummy data for testing
]]--

local Plugin = script.Parent.Parent.Parent

local Promise = require(Plugin.Libs.Http.Promise)

-- public api
local NetworkingMock = {}
NetworkingMock.__index = NetworkingMock

function NetworkingMock.new()
	return setmetatable({}, NetworkingMock)
end

function NetworkingMock:getAssets(pageInfo)
	local fakeItemListContent = {
		responseBody = {
			TotalResults = 7150107,
		}
	}
	local Results = {}
	for i = 1, pageInfo.pageSize or 100, 1 do
		Results[i] = {
			Asset = {
				Id = i,
				Name = "Observation Tower",
				TypeId = 10,
				IsEndorsed = true,
			},
			Creator = {
				Id = i,
				Name = "Quenty",
				Type = 1,
			},
			Thumbnail = {
				Final = true,
				Url = "https://t7.rbxcdn.com/25cf9d71d60973993f9c08eb605ffe99",
				RetryUrl = nil,
				UserId = 0,
				EndpointType = "Avatar",
			},
			Voting = {
				ShowVotes = true,
				UpVotes = 4506,
				DownVotes = 581,
				CanVote = true,
				UserVote = true, -- Vote Up
				HasVoted = true,
				ReasonForNotVoteable = "",
			},
		}
	end
	fakeItemListContent.responseBody.Results = Results

	return Promise.resolve(fakeItemListContent)
end

-- Pass this a list of assets and it returns a promise with the same data structure as returned from the web
function NetworkingMock:resolveAssets(assets, totalResults)
	return Promise.resolve({
		responseBody = {
			TotalResults = totalResults or #assets,
			Results = assets,
		},
	})
end

--para bool, vote up or not
function NetworkingMock:postVote(assetId, bool)
	return 	{
		success = true,
		message = "This is a test message"
	}
end

function NetworkingMock:postUnvote(assetId)
	return 	{
		success = true,
		message = "This is a test message"
	}
end

function NetworkingMock:postInsertAsset(assetId)
	return true
end

function NetworkingMock:getManageableGroups()
	local fakeGroups = {}
	return Promise.resolve(fakeGroups)
end

return NetworkingMock
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX05D75A38ECD542458445B98FD40A88AE">
					<Properties>
						<string name="Name">Requests</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX858C288ABFBC4C2CB241AC6A3741BD31">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PostUnvoteRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local NetworkError = require(Plugin.Core.Actions.NetworkError)
local PostUnvote = require(Plugin.Core.Actions.PostUnvote)

return function(networkInterface, assetId)
	return function(store)
		return networkInterface:postUnvote(assetId):andThen(function(result)
			local data = result.responseBody
			store:dispatch(PostUnvote(assetId, data))
		end, function(result)
			store:dispatch(NetworkError(result))
		end)
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBC1D711DF04D45CF99B834F70905475D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SelectGroupRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local UpdatePageInfoAndSendRequest = require(Plugin.Core.Networking.Requests.UpdatePageInfoAndSendRequest)
local StopAllSounds = require(Plugin.Core.Actions.StopAllSounds)

return function(networkInterface, groupIndex)
	return function(store)
		if store:getState().assets.isLoading then
			return
		end

		store:dispatch(StopAllSounds())

		store:dispatch(UpdatePageInfoAndSendRequest(networkInterface, nil, {
			searchTerm = "",
			sortIndex = 1,
			groupIndex = groupIndex,
			page = 1,
		}))
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDD38C6AD87A1430899848AC85931721A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SelectCategoryRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local UpdatePageInfoAndSendRequest = require(Plugin.Core.Networking.Requests.UpdatePageInfoAndSendRequest)
local StopAllSounds = require(Plugin.Core.Actions.StopAllSounds)

return function(networkInterface, settings, categoryIndex)
	return function(store)
		if store:getState().assets.isLoading then
			return
		end

		store:dispatch(StopAllSounds())

		store:dispatch(UpdatePageInfoAndSendRequest(networkInterface, settings, {
			categoryIndex = categoryIndex,
			searchTerm = "",
			sortIndex = 1,
			page = 1,
		}))

	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX27804A7753CC4D06B15A2DED1B5BBF8D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PostVoteRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local NetworkError = require(Plugin.Core.Actions.NetworkError)
local PostVote = require(Plugin.Core.Actions.PostVote)

return function(networkInterface, assetId, userVote)
	return function(store)
		return networkInterface:postVote(assetId, userVote):andThen(function(result)
			local data = result.responseBody
			store:dispatch(PostVote(assetId, data, userVote))
		end, function(result)
			store:dispatch(NetworkError(result))
		end)
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX41C53F96AED542D190244C8D1D2FA992">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PostInsertAssetRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local NetworkError = require(Plugin.Core.Actions.NetworkError)
local PostInsertAsset = require(Plugin.Core.Actions.PostInsertAsset)

return function(networkInterface, assetId)
	return function(store)
		return networkInterface:postInsertAsset(assetId):andThen(function(result)
			local data = result.responseBody
			store:dispatch(PostInsertAsset(assetId, data))
		end, function(result)
			store:dispatch(NetworkError(result))
		end)
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX909B4883EE1D4DB8BB3B5852089CAF02">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GetAssetsRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local GetAssets = require(Plugin.Core.Actions.GetAssets)
local NetworkError = require(Plugin.Core.Actions.NetworkError)
local SetLoading = require(Plugin.Core.Actions.SetLoading)

return function(networkInterface, pageInfo)
	return function(store)
		if store:getState().assets.isLoading or store:getState().assets.hasReachedBottom then
			return
		end

		store:dispatch(SetLoading(true))
		return networkInterface:getAssets(pageInfo):andThen(function(result)
			local data = result.responseBody
			store:dispatch(GetAssets(data))
			store:dispatch(SetLoading(false))
		end, function(result)
			store:dispatch(NetworkError(result))
			store:dispatch(SetLoading(false))
		end)
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBA52662F04E340EB994F8BE0390CA4E0">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SelectSortRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local UpdatePageInfoAndSendRequest = require(Plugin.Core.Networking.Requests.UpdatePageInfoAndSendRequest)

return function(networkInterface, settings, sortIndex)
	return function(store)
		if store:getState().assets.isLoading then
			return
		end

		store:dispatch(UpdatePageInfoAndSendRequest(networkInterface, settings, {
			sortIndex = sortIndex,
		}))
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX193E9A10650945B19A3045012ED568F1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GetManageableGroupsRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local GetManageableGroups = require(Plugin.Core.Actions.GetManageableGroups)
local NetworkError = require(Plugin.Core.Actions.NetworkError)

return function(networkInterface)
	return function(store)
		return networkInterface:getManageableGroups():andThen(function(result)
			local groups = result.responseBody
			store:dispatch(GetManageableGroups(groups))
		end, function(result)
			store:dispatch(NetworkError(result))
		end)
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8890A6D35B3B41EBB4DDE6854B3C2FCA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">UpdatePageInfoAndSendRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local GetAssetsRequest = require(Plugin.Core.Networking.Requests.GetAssetsRequest)

local ClearAssets = require(Plugin.Core.Actions.ClearAssets)
local UpdatePageInfo = require(Plugin.Core.Actions.UpdatePageInfo)

return function(networkInterface, settings, newPageInfo)
	return function(store)
		if store:getState().assets.isLoading then
			return
		end

		store:dispatch(UpdatePageInfo(newPageInfo, settings))
		store:dispatch(ClearAssets())
		store:dispatch(GetAssetsRequest(networkInterface, store:getState().pageInfo))
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX175271124EF24FCD8311F76185608D40">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NextPageRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local GetAssetsRequest = require(Plugin.Core.Networking.Requests.GetAssetsRequest)

local NextPage = require(Plugin.Core.Actions.NextPage)

return function(networkInterface)
	return function(store)
		if store:getState().assets.isLoading or store:getState().assets.hasReachedBottom then
			return
		end

		store:dispatch(NextPage())
		store:dispatch(GetAssetsRequest(networkInterface, store:getState().pageInfo))
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFF1804A03C8C440DB39D5F8B88FF4358">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ResumePreviewSoundRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local ResumePreviewSound = require(Plugin.Core.Actions.ResumePreviewSound)

return function()
	return function(store)
		store:dispatch(ResumePreviewSound())
	end
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA9BCF6E02A40426CA5A455D76B7BC60F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">RequestSearchRequest</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local Sort = require(Plugin.Core.Types.Sort)

local UpdatePageInfoAndSendRequest = require(Plugin.Core.Networking.Requests.UpdatePageInfoAndSendRequest)
local StopAllSounds = require(Plugin.Core.Actions.StopAllSounds)

return function(networkInterface, settings, searchTerm)
	return function(store)
		if store:getState().assets.isLoading then
			return
		end

		store:dispatch(StopAllSounds())

		local oldPageInfo = store:getState().pageInfo

		local sortIndex = Sort.canSort(searchTerm, oldPageInfo.categoryIndex)
			and oldPageInfo.sortIndex or 1

		store:dispatch(UpdatePageInfoAndSendRequest(networkInterface, settings, {
			searchTerm = searchTerm,
			sortIndex = sortIndex,
			page = 1,
		}))
	end
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX22CA108DFD3D4D8697D224BF8B1DCB4A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkInterface</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	NetworkInterface

	Provides an interface between real Networking implementation and Mock one for production and test
]]--

local Plugin = script.Parent.Parent.Parent

local Networking = require(Plugin.Libs.Http.Networking)

local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local PageInfoHelper = require(Plugin.Core.Util.PageInfoHelper)
local Urls = require(Plugin.Core.Util.Urls)
local Constants = require(Plugin.Core.Util.Constants)

local Category = require(Plugin.Core.Types.Category)

local NetworkInterface = {}
NetworkInterface.__index = NetworkInterface

function NetworkInterface:new()
	local networkImp = {
		_networkImp = Networking.new()

	}
	setmetatable(networkImp, NetworkInterface)

	return networkImp
end

local function printUrl(method, httpMethod, url, payload)
	if DebugFlags.shouldDebugUrls() then
		print(("NetworkInterface:%s()"):format(method))
		print(("\t%s %s"):format(httpMethod:upper() or "method=nil", url or "url=nil"))
		if payload then
			print(("\t%s"):format(tostring(payload)))
		end
	end
end

function NetworkInterface:getAssets(pageInfo)
	local category = PageInfoHelper.getCategoryForPageInfo(pageInfo) or ""
	local searchTerm = pageInfo.searchTerm or ""
	local pageSize = pageInfo.pageSize or Constants.GET_ITEMS_PAGE_SIZE
	local page = pageInfo.page or 1
	local sortType = PageInfoHelper.getSortTypeForPageInfo(pageInfo) or ""
	local groupId = Category.categoryIsGroupAsset(pageInfo.categoryIndex)
		and PageInfoHelper.getGroupIdForPageInfo(pageInfo)
		or 0

	local targetUrl = Urls.constructGetAssetsUrl(category, searchTerm, pageSize, page, sortType, groupId)

	printUrl("getAssets", "GET", targetUrl)
	return self._networkImp:httpGetJson(targetUrl)
end

function NetworkInterface:postVote(assetId, bool)
	local targetUrl = Urls.constructPostVoteUrl()

	local payload = self._networkImp:jsonEncode({
		assetId = assetId,
		vote = bool,
	})

	printUrl("postVote", "POST", targetUrl, payload)
	return self._networkImp:httpPostJson(targetUrl, payload)
end

function NetworkInterface:postUnvote(assetId)
	local targetUrl = Urls.constructPostVoteUrl()

	local payload = self._networkImp:jsonEncode({
		assetId = assetId,
	})

	printUrl("postUnvote", "POST", targetUrl, payload)
	return self._networkImp:httpPostJson(targetUrl, payload)
end

function NetworkInterface:postInsertAsset(assetId)
	local targetUrl = Urls.constructInsertAssetUrl(assetId)

	local payload = self._networkImp:jsonEncode({
		assetId = assetId,
	})

	printUrl("postInsertAsset", "POST", targetUrl, payload)
	return self._networkImp:httpPost(targetUrl, payload)
end

function NetworkInterface:getManageableGroups()
	local targetUrl = Urls.constructGetManageableGroupsUrl()

	printUrl("getManageableGroups", "GET", targetUrl)
	return self._networkImp:httpGetJson(targetUrl)
end

return NetworkInterface
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXCA0E6896A15B4E96B77784ECC8B7EDD1">
				<Properties>
					<string name="Name">Providers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXBBCCA97B30504C0297F67CE01BCD800E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PluginProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local pluginGuiKey = require(Plugin.Core.Keys.pluginGuiKey)
local pluginKey = require(Plugin.Core.Keys.pluginKey)

local PluginProvider = Roact.PureComponent:extend("PluginProvider")

function PluginProvider:init(props)
	self._context[pluginKey] = props.plugin
	self._context[pluginGuiKey] = props.pluginGui
end

function PluginProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return PluginProvider
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0F5D0F2CAA7C4FF5929B3D919F670FFE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PluginProvider.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local PluginProvider = require(Plugin.Core.Providers.PluginProvider)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(PluginProvider)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7569D6DE843E4AF2B418AB5AC6CD5E1D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ModalProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local ModalStatus = require(Plugin.Core.Util.ModalStatus)

local getPlugin = require(Plugin.Core.Consumers.getPlugin)

local ModalProvider = Roact.PureComponent:extend("ModalProvider")

function ModalProvider:init(props)
	-- Must be created under PluginProvider
	local _, pluginGui = getPlugin(self)
	self._context.modalTarget = pluginGui

	local modalStatus = ModalStatus.new()
	self._context._modalStatus = modalStatus

	-- TODO CLIDEVSRVS-1688: Improve this
	self._context.onTooltipTriggered = function(assetId, typeId)
		modalStatus:onTooltipTriggered(assetId, typeId)
	end

	self._context.onDropdownToggled = function(shown)
		modalStatus:onDropdownToggled(shown)
	end

	self._context.isShowingModal = function()
		return modalStatus:isShowingModal()
	end
end

function ModalProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return ModalProvider
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX82B6BF09ABED4D009E9E9DEDC6E886CA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local settingsKey = require(Plugin.Core.Keys.settingsKey)

local SettingsProvider = Roact.PureComponent:extend("SettingsProvider")

function SettingsProvider:init(props)
	self._context[settingsKey] = props.settings
end

function SettingsProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return SettingsProvider
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF083BE94F24B4BDE9847A32743E0869E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ThemeProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local themeKey = require(Plugin.Core.Keys.themeKey)

local ThemeProvider = Roact.Component:extend("ThemeProvider")

function ThemeProvider:init()
	self._context[themeKey] = self.props.theme
end

function ThemeProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

function ThemeProvider:willUnmount()
	self._context[themeKey]:destroy()
end

return ThemeProvider
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1AC80BE8460B41A797523D07E0E571F3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NetworkProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local networkInterfaceKey = require(Plugin.Core.Keys.networkInterfaceKey)

local NetworkProvider = Roact.PureComponent:extend("NetworkProvider")

function NetworkProvider:init(props)
	self._context[networkInterfaceKey] = props.networkInterface
end

function NetworkProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return NetworkProvider
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX990C06B4959D4DB2BB43D90AB051094A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RunToolboxTests</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local CorePackages = game:GetService("CorePackages")

local TestEZ = require(CorePackages.TestEZ)
local TestBootstrap = TestEZ.TestBootstrap
local TextReporter = TestEZ.Reporters.TextReporter

local Workspace = game:GetService("Workspace")

wait()

return function(tests, keepFailures)
	print("Running Toolbox tests")

	-- Create a folder for the tests to mount their components into
	-- Helpful in case a test fails and it doesn't unmount their components
	-- This way we can just delete them all after the tests finish
	local testTarget = Instance.new("Folder")
	testTarget.Name = "ToolboxTestsTarget"
	testTarget.Parent = Workspace

	TestBootstrap:run({tests}, TextReporter)

	if not keepFailures then
		testTarget:Destroy()
	end
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXBE75D32DAD1F41C0A49A1AACA91425EA">
				<Properties>
					<string name="Name">Components</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1B2F1BDAF62246A09322FDFB5384DC35">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Header.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Header = require(Plugin.Core.Components.Header)

	local Workspace = game:GetService("Workspace")

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			Header = Roact.createElement(Header, {
				maxWidth = 200,
				categories = {},
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should have a dropdown and a search bar", function()
		local element = Roact.createElement(MockWrapper, {}, {
			Header = Roact.createElement(Header, {
				maxWidth = 200,
				categories = {},
			}),
		})
		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "Header")

		local header = container.Header
		expect(header.CategoryMenu).to.be.ok()
		expect(header.SearchBar).to.be.ok()
		expect(header.UIPadding).to.be.ok()
		expect(header.UIListLayout).to.be.ok()

		Roact.unmount(instance)
	end)

	--[[describe("the search bar", function()
		it("should stretch to fill remaining space", function()
			local toolboxWidths = {200, 500, 1000}
			local dropdownWidth = 120
			local totalPadding = 9 + 7 + 9 -- 9 on outside, 7 between dropdown and search bar
			local minSearchBarWidth = 100

			for _, toolboxWidth in ipairs(toolboxWidths) do
				local expectedSearchBarWidth = math.max(minSearchBarWidth, toolboxWidth - dropdownWidth - totalPadding)
				local element = Roact.createElement(MockWrapper, {}, {
					Header = Roact.createElement(Header, {
						maxWidth = toolboxWidth,
						categories = {},
					}),
				})
				local container = workspace.ToolboxTestsTarget
				local instance = Roact.mount(element, container, "Header")

				local header = container.Header
				local searchBar = header.SearchBar

				expect(header.SearchBar.AbsoluteSize.x).to.equal(expectedSearchBarWidth)

				Roact.unmount(instance)
			end
		end)
	end)]]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD18E0C57800D4321BBA6E06850247DF5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundElement</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	An element with rounded corners
	Supports different background and border colors
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Colors = require(Plugin.Core.Util.Colors)
local Images = require(Plugin.Core.Util.Images)
local Immutable = require(Plugin.Core.Util.Immutable)

local function RoundElement(isButton)
	local elementType = isButton and "ImageButton" or "ImageLabel"

	return function(props)
		local backgroundProps = {
			-- Necessary to make the rounded background as it uses an image
			BackgroundTransparency = 1,
			Image = Images.ROUNDED_BACKGROUND_IMAGE,
			ImageTransparency = 0,
			ImageColor3 = Colors.WHITE,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Constants.ROUNDED_FRAME_SLICE,

			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),
		}

		local removedProps = Immutable.RemoveFromDictionary(props, Roact.Children, "BackgroundColor3",
			"BackgroundTransparency", "BorderColor3")
		backgroundProps = Immutable.JoinDictionaries(backgroundProps, removedProps)

		-- Because the roundness is achieved through images, we need to set the ImageColor3 and ImageTransparency instead
		if props.BackgroundColor3 then
			backgroundProps.ImageColor3 = props.BackgroundColor3
		end
		if props.BackgroundTransparency then
			backgroundProps.ImageTransparency = props.BackgroundTransparency
		end

		local borderColor3 = props.BorderColor3 or Colors.GRAY_3

		return Roact.createElement(elementType, backgroundProps, {
			Border = Roact.createElement("ImageLabel", {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = Images.ROUNDED_BORDER_IMAGE,
				ImageColor3 = borderColor3,
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Constants.ROUNDED_FRAME_SLICE,
			}, props[Roact.Children])
		})
	end
end

return RoundElement
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA1A3234AAC00483891980DFEAB6E9644">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StyledScrollingFrame.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local StyledScrollingFrame = require(Plugin.Core.Components.StyledScrollingFrame)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			StyledScrollingFrame = Roact.createElement(StyledScrollingFrame),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX80AB4304DAD14F9ABD550B242B6AD5F0">
					<Properties>
						<string name="Name">Asset</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4D8BD915D796408AB1F05CE98599BBEA">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Asset</string>
							<string name="ScriptGuid">{A8B92769-BA68-4A3C-9274-C43F69D32115}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Represents an asset in the grid view of the toolbox
	Takes in data from the endpoint as a prop
	Has events and callbacks for when it is hovered and clicked
	Shows asset icon, name, creator name and the voting details

	Props:
		Asset asset
		number LayoutOrder
		boolean isHovered

		callback onAssetHovered(number assetId)
		callback onAssetHoverEnded(number assetId)

		callback insertAsset(NetworkInterface networkInterface, number assetId)
		callback onAssetInserted()

		number currentSoundId
		boolean isPlaying
		callback onPreviewAudioButtonClicked
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local MouseManager = require(Plugin.Core.Util.MouseManager)
local Images = require(Plugin.Core.Util.Images)
local InsertAsset = require(Plugin.Core.Util.InsertAsset)

local getNetwork = require(Plugin.Core.Consumers.getNetwork)
local getPlugin = require(Plugin.Core.Consumers.getPlugin)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local AssetCreatorName = require(Plugin.Core.Components.Asset.AssetCreatorName)
local AssetIcon = require(Plugin.Core.Components.Asset.AssetIcon)
local AssetName = require(Plugin.Core.Components.Asset.AssetName)
local DraggableButton = require(Plugin.Core.Components.DraggableButton)
local DropShadow = require(Plugin.Core.Components.DropShadow)
local Voting = require(Plugin.Core.Components.Asset.Voting.Voting)

local PostInsertAssetRequest = require(Plugin.Core.Networking.Requests.PostInsertAssetRequest)

local Asset = Roact.PureComponent:extend("Asset")

function Asset:init(props)
	local plugin = getPlugin(self)

	if not props.asset then
		if DebugFlags.shouldDebugWarnings() then
			warn(("Toolbox asset id %s: asset not found"):format(tostring(props.assetId)))
		end
		return
	end

	local assetData = props.asset
	local asset = assetData.Asset
	local assetId = asset.Id
	local assetName = asset.Name
	local assetTypeId = asset.TypeId

	local onAssetHovered = props.onAssetHovered
	local onAssetHoverEnded = props.onAssetHoverEnded
	local canInsertAsset = props.canInsertAsset
	local categoryIndex = props.categoryIndex

	self.onMouseEntered = function(rbx, x, y)
		MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		onAssetHovered(assetId)
	end

	self.onMouseLeave = function(rbx, x, y)
		onAssetHoverEnded(assetId)
		MouseManager:clearIcons()
	end

	self.onInputEnded = function(rbx, input)
		if input.UserInputType == Enum.UserInputType.Focus then
			onAssetHoverEnded(assetId)
		end
	end

	self.onMouseMoved = function(rbx, x, y)
		onAssetHovered(assetId)
	end

	self.onMouseButton2Click = function(rbx, x, y)
		-- TODO CLIDEVSRVS-1247 CLIDEVSRVS-1248 ben.cooper 2018/05/07: On right click, show a context menu
	end

	self.onDragStart = function(rbx, x, y)
		if not canInsertAsset() or not settings():GetFFlag("PluginDragApi") then
			return
		end

		InsertAsset.dragInsertAsset(plugin, assetId, assetName, assetTypeId, self.onAssetInsertionSuccesful)
	end

	self.onClick = function(rbx, x, y)
		if not canInsertAsset() then
			return
		end

		--TODO: CLIDEVSRVS-1691: Replacing category index with assetTypeId for package insertion in lua toolbox
		InsertAsset.insertAsset(plugin, assetId, assetName, assetTypeId, self.onAssetInsertionSuccesful, categoryIndex)
	end

	self.onAssetInsertionSuccesful = function(assetId)
		self.props.insertAsset(getNetwork(self), assetId)
		self.props.onAssetInserted()
	end
end

function Asset:render()
	return withTheme(function(theme)
		local props = self.props

		if not props.asset then
			return
		end

		local assetData = props.asset

		local asset = assetData.Asset
		local assetId = asset.Id
		local assetTypeId = asset.TypeId
		local isEndorsed = asset.IsEndorsed
		local assetName = asset.Name

		local creator = assetData.Creator
		local creatorName = creator.Name

		local votingProps = props.voting or {}
		local showVotes = votingProps.ShowVotes

		local layoutOrder = props.LayoutOrder
		local isHovered = props.isHovered

		local assetOutlineHeight = showVotes and Constants.ASSET_OUTLINE_EXTRA_HEIGHT_WITH_VOTING
			or Constants.ASSET_OUTLINE_EXTRA_HEIGHT

		local isDarkerTheme = theme.isDarkerTheme
		local outlineTheme = theme.asset.outline
		local dropShadowSize = Constants.DROP_SHADOW_SIZE

		return Roact.createElement("Frame", {
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),
			LayoutOrder = layoutOrder,
			BackgroundTransparency = 1,

			-- Need to raise the container up over the other assets to show the outline correctly
			ZIndex = isHovered and 2 or 1,
		}, {
			DropShadow = isHovered and isDarkerTheme and Roact.createElement(DropShadow, {
				-- Copy the size and position of the outline but add a few pixels extra
				AnchorPoint = Vector2.new(0.5, 0),
				Position = UDim2.new(0.5, 0, 0, -(Constants.ASSET_OUTLINE_PADDING + dropShadowSize)),
				Size = UDim2.new(1, 2 * (Constants.ASSET_OUTLINE_PADDING + dropShadowSize),
					1, assetOutlineHeight + (2 * dropShadowSize)),
				ZIndex = -2, -- Ensure it's below the outline
			}),

			Outline = isHovered and Roact.createElement("ImageButton", {
				AnchorPoint = Vector2.new(0.5, 0),
				BackgroundTransparency = isDarkerTheme and 0 or Constants.ASSET_OUTLINE_HOVERED_TRANSPARENCY,

				BackgroundColor3 = outlineTheme.backgroundColor,
				BorderColor3 = outlineTheme.borderColor,

				BorderSizePixel = 1,
				Position = UDim2.new(0.5, 0, 0, -Constants.ASSET_OUTLINE_PADDING),
				Size = UDim2.new(1, 2 * Constants.ASSET_OUTLINE_PADDING, 1, assetOutlineHeight),
				ZIndex = -1,
				AutoButtonColor = false,

				[Roact.Event.MouseLeave] = self.onMouseLeave,
				[Roact.Event.InputEnded] = self.onInputEnded,
			}),

			InnerFrame = Roact.createElement(DraggableButton, {
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 1, 0),

				[Roact.Event.MouseEnter] = self.onMouseEntered,
				[Roact.Event.MouseButton2Click] = self.onMouseButton2Click,
				onMouseMoved = self.onMouseMoved,

				onDragStart = self.onDragStart,
				onClick = self.onClick,
			}, {
				UIListLayout = Roact.createElement("UIListLayout", {
					Padding = UDim.new(0, Constants.ASSET_INNER_PADDING),
					SortOrder = Enum.SortOrder.LayoutOrder,
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
					VerticalAlignment = Enum.VerticalAlignment.Top,
				}),

				AssetIcon = Roact.createElement(AssetIcon, {
					Size = UDim2.new(1, 0, 1, 0),
					LayoutOrder = 0,

					assetId = assetId,
					assetName = assetName,
					isEndorsed = isEndorsed,
					typeId = assetTypeId,
					currentSoundId = props.currentSoundId,
					isPlaying = props.isPlaying,

					onPreviewAudioButtonClicked = props.onPreviewAudioButtonClicked,
				}),

				AssetName = Roact.createElement(AssetName, {
					Size = UDim2.new(1, 0, 0.45, 0),
					LayoutOrder = 1,

					assetId = assetId,
					assetName = assetName,
				}),

				CreatorName = isHovered and Roact.createElement(AssetCreatorName,{
					Size = UDim2.new(1, 0, 0.15, 0),
					LayoutOrder = 2,

					assetId = assetId,
					creatorName = creatorName,
				}),

				Voting = isHovered and showVotes and Roact.createElement(Voting, {
					LayoutOrder = 3,
					assetId = assetId,
					voting = votingProps,
				}),
			}),
		})
	end)
end

local function mapStateToProps(state, props)
	state = state or {}

	local assets = state.assets or {}
	local voting = state.voting or {}

	local idToAssetMap = assets.idToAssetMap or {}

	local assetId = props.assetId

	return {
		asset = idToAssetMap[assetId],
		voting = voting[assetId] or {},
	}
end

local function mapDispatchToProps(dispatch)
	return {
		insertAsset = function(networkInterface, assetId)
			dispatch(PostInsertAssetRequest(networkInterface, assetId))
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(Asset)
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7ADB407E8F71445FAD9E847F015D2908">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetIcon</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Square image with customizable background and optional endorsed badge

	Props:
		number assetId
		number typeId
		boolean isEndorsed
		number LayoutOrder = 0
		number curentSoundId
		boolean isPlaying

		callback onMouseEnter()
		callback onMouseLeave()
		callback onPreviewAudioButtonClicked()
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)
local Urls = require(Plugin.Core.Util.Urls)

local Background = require(Plugin.Core.Types.Background)

local getModal = require(Plugin.Core.Consumers.getModal)
local withModal = require(Plugin.Core.Consumers.withModal)

local AssetIconBadge = require(Plugin.Core.Components.Asset.AssetIconBadge)
local AudioPreviewButton = require(Plugin.Core.Components.AudioPreviewButton)
local TooltipWrapper = require(Plugin.Core.Components.TooltipWrapper)

local AssetIcon = Roact.PureComponent:extend("AssetIcon")

function AssetIcon:init(props)
	self.state = {
		isHovered = false
	}

	self.onMouseEnter = function()
		self:setState({
			isHovered = true
		})

		getModal(self).onTooltipTriggered(props.assetId, Constants.TOOLTIP_TYPE.ASSET_ICON)
	end

	self.onMouseLeave = function()
		self:setState({
			isHovered = false
		})
	end
end

function AssetIcon:render()
	return withModal(function(modalTarget, modalStatus)
		local props = self.props

		local assetId = props.assetId
		local assetName = props.assetName

		local layoutOrder = props.LayoutOrder or 0
		local backgroundIndex = props.backgroundIndex
		local isEndorsed = props.isEndorsed
		local typeId = props.typeId
		local currentSoundId = props.currentSoundId
		local isPlaying = props.isPlaying

		local onMouseEnter = self.onMouseEnter
		local onMouseLeave = self.onMouseLeave
		local onPreviewAudioButtonClicked = props.onPreviewAudioButtonClicked

		local isHovered = self.state.isHovered

		local thumbnailUrl = Urls.constructAssetThumbnailUrl(assetId,
			Constants.ASSET_THUMBNAIL_REQUESTED_IMAGE_SIZE,
			Constants.ASSET_THUMBNAIL_REQUESTED_IMAGE_SIZE)

		local canShowCurrentTooltip = modalStatus:canShowCurrentTooltip(assetId, Constants.TOOLTIP_TYPE.ASSET_ICON)

		local isAudioAsset = typeId == Enum.AssetType.Audio.Value

		return Background.renderBackground(backgroundIndex, {
			Size = UDim2.new(1, 0, 1, 0),
			SizeConstraint = Enum.SizeConstraint.RelativeXX,
			ZIndex = 1,
			LayoutOrder = layoutOrder,

			[Roact.Event.MouseEnter] = onMouseEnter,
			[Roact.Event.MouseLeave] = onMouseLeave,
		}, {
			AssetImage = Roact.createElement("ImageLabel", {
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Image = thumbnailUrl,
			}),

			Badge = isEndorsed and Roact.createElement(AssetIconBadge, {
				assetId = assetId,
				floatLeft = isAudioAsset,
			}),

			PreviewAudioButton = isAudioAsset and Roact.createElement(AudioPreviewButton, {
				Position = UDim2.new(0.65, 0, 0.75, 0),
				Size = UDim2.new(0, Constants.ASSET_PLAY_AUDIO_ICON_SIZE, 0, Constants.ASSET_PLAY_AUDIO_ICON_SIZE),
				ZIndex = 3,

				assetId = assetId,
				currentSoundId = currentSoundId,
				isPlaying = isPlaying,
				onClick = onPreviewAudioButtonClicked,
			}),

			TooltipWrapper = isHovered and Roact.createElement(TooltipWrapper, {
				Text = assetName,
				canShowCurrentTooltip = canShowCurrentTooltip,
				isHovered = isHovered,
			}),
		})
	end)
end

local function mapStateToProps(state, props)
	state = state or {}

	local pageInfo = state.pageInfo or {}
	local selectedBackgroundIndex = pageInfo.selectedBackgroundIndex or 1
	local hoveredBackgroundIndex = pageInfo.hoveredBackgroundIndex or 0

	return {
		backgroundIndex = hoveredBackgroundIndex ~= 0 and hoveredBackgroundIndex or selectedBackgroundIndex
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, nil)(AssetIcon)
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1D02F4A02762482DBC7667F99E0D0752">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetIcon.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local AssetIcon = require(Plugin.Core.Components.Asset.AssetIcon)

	local Workspace = game:GetService("Workspace")

	local assetId = 1234567890

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetIcon = Roact.createElement(AssetIcon, {
				assetId = assetId,
				isEndorsed = false,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should have the correct image", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetIcon = Roact.createElement(AssetIcon, {
				assetId = assetId,
				isEndorsed = false,
			}),
		})

		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "AssetIcon")

		local assetIcon = container.AssetIcon
		local assetImage = assetIcon.AssetImage
		expect(assetImage.Image:match("assetId=" .. assetId)).to.be.ok()

		Roact.unmount(instance)
	end)

	-- TODO CLIDEVSRVS-1687: Either move this test to Types/Background or modify this to dispatch a store action that changes the background
	--[[
	it("should have the correct background", function()
		local backgrounds = {
			{
				Image = "",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			},
			{
				Image = "",
				BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			},
			{
				Image = Images.NO_BACKGROUND_ICON,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			},
		}

		for index, backgroundDetails in ipairs(backgrounds) do
			local element = Roact.createElement(MockWrapper, {}, {
				AssetIcon = Roact.createElement(AssetIcon, {
					assetId = assetId,
					backgroundIndex = index,
					isEndorsed = false,
				}),
			})

			local container = workspace.ToolboxTestsTarget
			local instance = Roact.mount(element, container, "AssetIcon")

			local background = container.AssetIcon
			expect(background.Image).to.equal(backgroundDetails.Image)
			expect(background.BackgroundColor3).to.equal(backgroundDetails.BackgroundColor3)

			Roact.unmount(instance)
		end
	end)
	]]

	it("should have or not have the endorsed badge", function()
		for _, isEndorsed in ipairs({true, false}) do
			local element = Roact.createElement(MockWrapper, {}, {
				AssetIcon = Roact.createElement(AssetIcon, {
					assetId = assetId,
					isEndorsed = isEndorsed,
				}),
			})

			local container = Workspace.ToolboxTestsTarget
			local instance = Roact.mount(element, container, "AssetIcon")

			local assetIcon = container.AssetIcon
			local badge = assetIcon:FindFirstChild("Badge")
			if isEndorsed then
				expect(badge).to.be.ok()
			else
				expect(badge).never.to.be.ok()
			end
			Roact.unmount(instance)
		end
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE6270018D9164678B78C4B54128F32D8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetIconBadge</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	2 line text label that shows the name of an asset

	Props:
		string assetName
		number LayoutOrder = 0

		callback onMouseEnter()
		callback onMouseLeave()
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Images = require(Plugin.Core.Util.Images)
local Constants = require(Plugin.Core.Util.Constants)

local getModal = require(Plugin.Core.Consumers.getModal)
local withModal = require(Plugin.Core.Consumers.withModal)

local TooltipWrapper = require(Plugin.Core.Components.TooltipWrapper)

local AssetIconBadge = Roact.PureComponent:extend("AssetIconBadge")

function AssetIconBadge:init(props)
	self.state = {
		isHovered = false
	}

	self.onMouseEnter = function()
		self:setState({
			isHovered = true
		})

		getModal(self).onTooltipTriggered(props.assetId, Constants.TOOLTIP_TYPE.HIGH_QUALITY_BADGE)
	end

	self.onMouseLeave = function()
		self:setState({
			isHovered = false
		})
	end
end

function AssetIconBadge:render()
	return withModal(function(modalTarget, modalStatus)
		local props = self.props

		local assetId = props.assetId
		local floatLeft = props.floatLeft

		local onMouseEnter = self.onMouseEnter
		local onMouseLeave = self.onMouseLeave

		local isHovered = self.state.isHovered

		local canShowCurrentTooltip = modalStatus:canShowCurrentTooltip(assetId, Constants.TOOLTIP_TYPE.HIGH_QUALITY_BADGE)

		local edgeOffset = 0.06

		return Roact.createElement("ImageLabel", {
			AnchorPoint = Vector2.new(floatLeft and 0 or 1, 1),
			BackgroundTransparency = 1,
			Position = UDim2.new(floatLeft and edgeOffset or (1 - edgeOffset), 0, 1.06, 0),
			Size = UDim2.new(0, Constants.ASSET_ENDORSED_BADGE_ICON_SIZE, 0, Constants.ASSET_ENDORSED_BADGE_ICON_SIZE),
			Image = Images.ENDORSED_BADGE_ICON,
			ZIndex = 2,

			[Roact.Event.MouseEnter] = onMouseEnter,
			[Roact.Event.MouseLeave] = onMouseLeave,
		}, {
			TooltipWrapper = isHovered and Roact.createElement(TooltipWrapper, {
				Text = Constants.ENDORSED_BADGE_TOOLTIP_TEXT,
				canShowCurrentTooltip = canShowCurrentTooltip,
				isHovered = isHovered,
			})
		})
	end)
end

return AssetIconBadge
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX92107AA824C64912904C587849A804B8">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetName</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	2 line text label that shows the name of an asset

	Props:
		string assetName
		number LayoutOrder = 0

		callback onMouseEnter()
		callback onMouseLeave()
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local getModal = require(Plugin.Core.Consumers.getModal)
local withModal = require(Plugin.Core.Consumers.withModal)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local TooltipWrapper = require(Plugin.Core.Components.TooltipWrapper)

local AssetName = Roact.PureComponent:extend("AssetName")

function AssetName:init(props)
	self.state = {
		isHovered = false
	}

	self.onMouseEnter = function()
		self:setState({
			isHovered = true
		})

		getModal(self).onTooltipTriggered(props.assetId, Constants.TOOLTIP_TYPE.ASSET_NAME)
	end

	self.onMouseLeave = function()
		self:setState({
			isHovered = false
		})
	end
end

function AssetName:render()
	return withTheme(function(theme)
		return withModal(function(modalTarget, modalStatus)
			local props = self.props

			local assetId = props.assetId
			local assetName = props.assetName
			local layoutOrder = props.LayoutOrder or 0

			local canShowCurrentTooltip = modalStatus:canShowCurrentTooltip(assetId, Constants.TOOLTIP_TYPE.ASSET_NAME)

			local assetNameTheme = theme.asset.assetName
			local isHovered = self.state.isHovered

			return Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				LayoutOrder = layoutOrder,
				Size = UDim2.new(1, 0, 0, Constants.ASSET_NAME_HEIGHT),
				Text = assetName,
				TextColor3 = assetNameTheme.textColor,

				Font = Constants.FONT,
				TextSize = Constants.ASSET_NAME_FONT_SIZE,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextWrapped = true,
				ClipsDescendants = true,
				TextTruncate = Enum.TextTruncate.AtEnd,

				[Roact.Event.MouseEnter] = self.onMouseEnter,
				[Roact.Event.MouseLeave] = self.onMouseLeave,
			}, {
				TooltipWrapper = isHovered and Roact.createElement(TooltipWrapper, {
					Text = assetName,
					canShowCurrentTooltip = canShowCurrentTooltip,
					isHovered = isHovered,
				})
			})
		end)
	end)
end

return AssetName
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX401E8D397AB84BB3B8AD7EDD9C1ABD7F">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetIconBadge.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local AssetIconBadge = require(Plugin.Core.Components.Asset.AssetIconBadge)
	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetIconBadge = Roact.createElement(AssetIconBadge),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX693FFFB802784EC182CC83C241E0D514">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetCreatorName.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local AssetCreatorName = require(Plugin.Core.Components.Asset.AssetCreatorName)

	local Workspace = game:GetService("Workspace")

	local creatorNameString = "Example name here"

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetCreatorName = Roact.createElement(AssetCreatorName, {
				creatorName = creatorNameString,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should say the creator's name", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetCreatorName = Roact.createElement(AssetCreatorName, {
				creatorName = creatorNameString,
			}),
		})
		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "AssetCreatorName")
		local assetCreatorName = container.AssetCreatorName
		-- Use match to handle localization
		expect(assetCreatorName.Text:match(creatorNameString)).to.be.ok()
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1A150833C17643A8B49A4C1BA6F6187A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetCreatorName</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Text label that shows the name of an asset creator

	Props:
		string creatorName = ""
		number LayoutOrder = 0

		callback onMouseEnter()
		callback onMouseLeave()
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local getModal = require(Plugin.Core.Consumers.getModal)
local withModal = require(Plugin.Core.Consumers.withModal)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local TooltipWrapper = require(Plugin.Core.Components.TooltipWrapper)

local AssetCreatorName = Roact.PureComponent:extend("AssetCreatorName")

function AssetCreatorName:init(props)
	self.state = {
		isHovered = false
	}

	self.onMouseEnter = function()
		self:setState({
			isHovered = true
		})

		getModal(self).onTooltipTriggered(props.assetId, Constants.TOOLTIP_TYPE.CREATOR_NAME)
	end

	self.onMouseLeave = function()
		self:setState({
			isHovered = false
		})
	end
end

function AssetCreatorName:render()
	return withTheme(function(theme)
		return withModal(function(modalTarget, modalStatus)
			local props = self.props

			local creatorNameField = ("by %s"):format(props.creatorName)
			local layoutOrder = props.LayoutOrder or 0

			local assetId = props.assetId
			local creatorName = props.creatorName

			local canShowCurrentTooltip = modalStatus:canShowCurrentTooltip(assetId, Constants.TOOLTIP_TYPE.CREATOR_NAME)

			local creatorNameTheme = theme.asset.creatorName

			local isHovered = self.state.isHovered

			return Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				LayoutOrder = layoutOrder,
				Size = UDim2.new(1, 0, 0, Constants.ASSET_CREATOR_NAME_HEIGHT),
				Text = creatorNameField,
				TextColor3 = creatorNameTheme.textColor,
				Font = Constants.FONT,
				TextSize = Constants.ASSET_CREATOR_NAME_FONT_SIZE,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextYAlignment = Enum.TextYAlignment.Top,
				ClipsDescendants = true,
				TextTruncate = Enum.TextTruncate.AtEnd,

				[Roact.Event.MouseEnter] = self.onMouseEnter,
				[Roact.Event.MouseLeave] = self.onMouseLeave,
			}, {
				TooltipWrapper = isHovered and Roact.createElement(TooltipWrapper, {
					Text = creatorName,
					canShowCurrentTooltip = canShowCurrentTooltip,
					isHovered = isHovered,
				})
			})
		end)
	end)
end

return AssetCreatorName
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX97400DC21D8848AB8456D45207DC377B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Asset.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Asset = require(Plugin.Core.Components.Asset.Asset)

	local Workspace = game:GetService("Workspace")

	local asset = {
		Asset = {
			Id = 12345,
			IsEndorsed = false,
			Name = "Hello, world!",
		},
		Creator = {
			Name = "Foo",
		},
		Voting = {
			UpVotes = 150,
			DownVotes = 10,
			ShowVotes = true,
		},
	}

	local function createTestAsset(container, name)
		local element = Roact.createElement(MockWrapper, {}, {
			Asset = Roact.createElement(Asset, {
				asset = asset,

				LayoutOrder = 1,
				isHovered = false,
			}),
		})

		return Roact.mount(element, container or nil, name or "")
	end

	it("should create and destroy without errors", function()
		local instance = createTestAsset()
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = Workspace.ToolboxTestsTarget
		local instance = createTestAsset(container, "Asset")
		local asset = container.Asset

		expect(asset.InnerFrame).to.be.ok()

		expect(asset.InnerFrame.UIListLayout).to.be.ok()
		expect(asset.InnerFrame.AssetIcon).to.be.ok()
		expect(asset.InnerFrame.AssetName).to.be.ok()

		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5DBCC2EC6E7F4E94B1034F02005B264D">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AssetName.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local AssetName = require(Plugin.Core.Components.Asset.AssetName)

	local Workspace = game:GetService("Workspace")

	local assetNameString = "Example name here"

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetName = Roact.createElement(AssetName, {
				assetName = assetNameString,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should say the assets's name", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AssetName = Roact.createElement(AssetName, {
				assetName = assetNameString,
			}),
		})
		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "AssetName")
		local assetNameObject = container.AssetName
		expect(assetNameObject.Text).to.equal(assetNameString)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXBDA2DE3CFE744FE1A8853F645BF8AB5D">
						<Properties>
							<string name="Name">Voting</string>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX31202461CD184DC59BA9279EB5789D7B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VoteButtons.spec</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local VoteButtons = require(Plugin.Core.Components.Asset.Voting.VoteButtons)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			VoteButtons = Roact.createElement(VoteButtons, {
				voting = {
					HasVoted = false,
					UserVote = false,
				},
			})
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3653C849970F442AA254A43FB4F76055">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Voting.spec</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Voting = require(Plugin.Core.Components.Asset.Voting.Voting)

	local Workspace = game:GetService("Workspace")

	local votes = {{0, 0}, {50, 0}, {0, 50}, {80, 20}}

	local function createTestVoting(upVotes, downVotes, container, name)
		local element = Roact.createElement(MockWrapper, {}, {
			Voting = Roact.createElement(Voting, {
				voting = {
					UpVotes = upVotes,
					DownVotes = downVotes,
					ShowVotes = true,
				}
			}),
		})

		return Roact.mount(element, container or nil, name or "")
	end

	it("should create and destroy without errors", function()
		local instance = createTestVoting(150, 10)
		Roact.unmount(instance)
	end)

	it("should show the total number of votes", function()
		for _, voteTotals in ipairs(votes) do
			local upVotes = voteTotals[1]
			local downVotes = voteTotals[2]
			local totalVotes = upVotes + downVotes

			local container = Workspace.ToolboxTestsTarget
			local instance = createTestVoting(upVotes, downVotes, container, "Voting")
			local voteCountLabel = container.Voting.VoteCount
			expect(voteCountLabel.Text:match(totalVotes)).to.be.ok()
			Roact.unmount(instance)
		end
	end)

	it("should have a bar showing ratio of up to down votes", function()
		for _, voteTotals in ipairs(votes) do
			local upVotes = voteTotals[1]
			local downVotes = voteTotals[2]
			local totalVotes = upVotes + downVotes
			local ratio = (totalVotes ~= 0) and upVotes / totalVotes or 1

			local container = Workspace.ToolboxTestsTarget
			local instance = createTestVoting(upVotes, downVotes, container, "Voting")
			local ratioBar = container.Voting.VoteBar.Background.UpVotes
			local size = ratioBar.Size.X.Scale
			expect(math.abs(size - ratio) <= 0.01).to.equal(true)
			Roact.unmount(instance)
		end
	end)
end
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC24630A879C94618A1D0AE263E819D2B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VoteBar.spec</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local VoteBar = require(Plugin.Core.Components.Asset.Voting.VoteBar)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			VoteBar = Roact.createElement(VoteBar, {
				voting = {
					UpVotes = 0,
					DownVotes = 0,
				},
			})
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD61E45A550B94F41B7CB40CCA8DBFD35">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VoteButtons</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--[[

	callback onVoteRequested(NetworkInterface networkInterface, number assetId, bool vote)
	callback onUnvoteRequested(NetworkInterface networkInterface, number assetId)
]]

local Plugin = script.Parent.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)

local getNetwork = require(Plugin.Core.Consumers.getNetwork)

local VoteButton = require(Plugin.Core.Components.Asset.Voting.VoteButton)

local PostUnvoteRequest = require(Plugin.Core.Networking.Requests.PostUnvoteRequest)
local PostVoteRequest = require(Plugin.Core.Networking.Requests.PostVoteRequest)

local VoteButtons = Roact.PureComponent:extend("VoteButtons")

function VoteButtons:init(props)
	local networkInterface = getNetwork(self)
	local assetId = self.props.assetId

	local onVoteRequested = self.props.onVoteRequested
	local onUnvoteRequested = self.props.onUnvoteRequested

	self.onVoteUpClicked = function(rbx, x, y)
		if self.props.voting.UserVote then
			onUnvoteRequested(networkInterface, assetId)
		else
			onVoteRequested(networkInterface, assetId, true)
		end
	end

	self.onVoteDownClicked = function(rbx, x, y)
		if self.props.voting.UserVote then
			onVoteRequested(networkInterface, assetId, false)
		else
			onUnvoteRequested(networkInterface, assetId)
		end
	end
end

function VoteButtons:render()
	local props = self.props

	local layoutOrder = props.LayoutOrder or 0

	return Roact.createElement("Frame", {
		BackgroundTransparency = 1,
		LayoutOrder = layoutOrder,
		Size = UDim2.new(1, 0, 0, Constants.ASSET_VOTING_HEIGHT),
	}, {
		UIListLayout = Roact.createElement("UIListLayout", {
			SortOrder = Enum.SortOrder.LayoutOrder,
			FillDirection = Enum.FillDirection.Horizontal,
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
		}),

		VoteUpButton = Roact.createElement(VoteButton, {
			isVoteUp = true,

			hasVoted = props.voting.HasVoted,
			userVote = props.voting.UserVote,

			onClicked = self.onVoteUpClicked,
		}),

		VoteDownButton = Roact.createElement(VoteButton, {
			isVoteUp = false,

			hasVoted = props.voting.HasVoted,
			userVote = props.voting.UserVote,

			onClicked = self.onVoteDownClicked,
		}),
	})
end

local function mapDispatchToProps(dispatch)
	return {
		onVoteRequested = function(networkInterface, assetId, bool)
			dispatch(PostVoteRequest(networkInterface, assetId, bool))
		end,

		onUnvoteRequested = function(networkInterface, assetId)
			dispatch(PostUnvoteRequest(networkInterface, assetId))
		end
	}
end

return RoactRodux.UNSTABLE_connect2(nil, mapDispatchToProps)(VoteButtons)
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX15665DFF43254F789899DE15EBD51AA8">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VoteButton</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)

local VoteButton = Roact.PureComponent:extend("VoteButton")

function VoteButton:init(props)
	self.state = {
		isHovered = false,
		voteDownButtonHovered = false
	}

	self.onMouseEntered = function(rbx, x, y)
		MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		self:setState({
			isHovered = true
		})
	end

	self.onMouseLeft = function(rbx, x, y)
		MouseManager:clearIcons()
		self:setState({
			isHovered = false
		})
	end
end

function VoteButton:render()
	local props = self.props
	local state = self.state

	local hasVoted = props.hasVoted
	local userVotedThisButton = props.userVote

	-- TODO CLIDEVSRVS-1593: Improve handling of isVoteUp
	local isVoteUp = props.isVoteUp

	if not isVoteUp then
		userVotedThisButton = not userVotedThisButton
	end

	local isHovered = state.isHovered
	local onClicked = props.onClicked

	return Roact.createElement("ImageButton", {
		BackgroundTransparency = 1,
		LayoutOrder = isVoteUp and 1 or 2,
		AutoButtonColor = true,

		Image = (hasVoted and userVotedThisButton) and (isVoteUp and Images.THUMB_UP_GREEN or Images.THUMB_DOWN_RED)
			or (isVoteUp and Images.THUMB_UP_GREY or Images.THUMB_DOWN_GREY),
		ImageTransparency = (isHovered and 0) or 0.2,
		Size = UDim2.new(0, Constants.THUMB_ICON_WIDTH, 0, Constants.THUMB_ICON_HEIGHT),

		[Roact.Event.MouseEnter] = self.onMouseEntered,
		[Roact.Event.MouseLeave] = self.onMouseLeft,
		[Roact.Event.MouseButton1Click] = onClicked,
	})
end

return VoteButton
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5E3603E79B774C67BD5A85AF7D8C6059">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Voting</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[--[[
	Shows either the current voting status of an asset (the ratio of up
	votes to down votes and the total votes), or butons for a user to vote
	on an asset.

	Props:
		number assetId
		Voting voting
			number UpVotes
			number DownVotes
			boolean CanVote
			boolean UserVote
			boolean HasVoted
			boolean ShowVotes
			boolean showVoteButtons = false
		number LayoutOrder = 0
]]

local Plugin = script.Parent.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local VoteBar = require(Plugin.Core.Components.Asset.Voting.VoteBar)
local VoteButtons = require(Plugin.Core.Components.Asset.Voting.VoteButtons)

local function Voting(props)
	local showVotes = props.voting.ShowVotes
	local showVoteButtons = props.voting.showVoteButtons or false

	if showVotes then
		if showVoteButtons then
			return Roact.createElement(VoteButtons, props)
		else
			return Roact.createElement(VoteBar, props)
		end
	else
		return nil
	end
end

return Voting
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDB03B5A686964344808187EAEF858C8B">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VoteButton.spec</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local VoteButton = require(Plugin.Core.Components.Asset.Voting.VoteButton)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(VoteButton)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC42091A842EC49FE9F2534183FF16926">
							<Properties>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VoteBar</string>
								<string name="ScriptGuid"></string>
								<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local function VoteBar(props)
	return withTheme(function(theme)
		local layoutOrder = props.LayoutOrder or 0

		local votingTheme = theme.asset.voting

		local upVotes = props.voting.UpVotes
		local downVotes = props.voting.DownVotes
		local totalVotes = upVotes + downVotes
		local voteRatio = (totalVotes ~= 0) and upVotes / totalVotes or 1

		local votesLabel = ("%d vote%s"):format(totalVotes, totalVotes ~= 1 and "s" or "")

		return Roact.createElement("Frame", {
			BackgroundTransparency = 1,
			LayoutOrder = layoutOrder,
			Size = UDim2.new(1, 0, 0, Constants.ASSET_VOTING_HEIGHT),
		}, {
			UIListLayout = Roact.createElement("UIListLayout", {
				SortOrder = Enum.SortOrder.LayoutOrder,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
			}),

			VoteBar = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				LayoutOrder = 0,
				Size = UDim2.new(1, 0, 0, Constants.ASSET_VOTE_BAR_OUTER_HEIGHT),
			}, {
				Background = Roact.createElement("Frame", {
					AnchorPoint = Vector2.new(0, 0.5),
					BackgroundColor3 = votingTheme.downVotes,
					BorderSizePixel = 0,
					Position = UDim2.new(0, 0, 0.5, 0),
					Size = UDim2.new(1, 0, 0, Constants.ASSET_VOTE_BAR_HEIGHT),
				}, {
					UpVotes = Roact.createElement("Frame", {
						BackgroundColor3 = votingTheme.upVotes,
						BorderSizePixel = 0,
						Size = UDim2.new(voteRatio, 0, 1, 0),
					}),
				}),
			}),

			VoteCount = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				LayoutOrder = 1,
				Size = UDim2.new(1, 0, 0, Constants.ASSET_VOTE_COUNT_HEIGHT),
				Text = votesLabel,
				TextColor3 = votingTheme.textColor,

				Font = Constants.FONT,
				TextSize = Constants.ASSET_VOTE_COUNT_FONT_SIZE,
			}),
		})
	end)
end

return VoteBar
]]></ProtectedString>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX1CD578A3DD8245B8A4D48578F05D61C1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SoundPreviewComponent.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local SoundPreviewComponent = require(Plugin.Core.Components.SoundPreviewComponent)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			SoundPreviewComponent = Roact.createElement(SoundPreviewComponent),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE357B4D1022F4C2FA798F9923EEBBFA3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Toast.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local Toast = require(Plugin.Core.Components.Toast)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(Toast)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX3837AFE64DAD44C2B25D3F719C62D7D0">
					<Properties>
						<string name="Name">Footer</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7AF85434676F413E854DDB5658C5BC04">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Footer</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Footer of the toolbox

	Props:
		Backgrounds backgrounds
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)


local getSettings = require(Plugin.Core.Consumers.getSettings)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local FooterButton = require(Plugin.Core.Components.Footer.FooterButton)

local ChangeBackground = require(Plugin.Core.Actions.ChangeBackground)

local Footer = Roact.PureComponent:extend("Footer")

function Footer:init(props)
	local settings = getSettings(self)

	self.inputEnded = function(rbx, input)
		if input.UserInputType == Enum.UserInputType.Focus then
			props.onBackgroundSelectorHoverEnded(settings, 0)
		end
	end

	self.onHoverStarted = function(index)
		MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		props.onBackgroundSelectorHovered(settings, index)
	end

	self.onHoverEnded = function(index)
		MouseManager:clearIcons()
		props.onBackgroundSelectorHoverEnded(settings, index)
	end

	self.onClick = function(index)
		props.onBackgroundSelectorClicked(settings, index)
	end
end

function Footer:render()
	return withTheme(function(theme)
		local props = self.props

		local backgrounds = props.backgrounds
		local selectedBackgroundIndex = props.selectedBackgroundIndex
		local hoveredBackgroundIndex = props.hoveredBackgroundIndex

		local footerTheme = theme.footer

		local backgroundComponents = {
			UIListLayout = Roact.createElement("UIListLayout", {
				FillDirection = Enum.FillDirection.Horizontal,
				SortOrder = Enum.SortOrder.LayoutOrder,
				Padding = UDim.new(0, 5),
			}),

			BackgroundTextLabel = Roact.createElement("TextLabel", {
				Size = UDim2.new(0, 65, 1, 0),
				Text = "Background:",
				Font = Constants.FONT,
				TextSize = Constants.FONT_SIZE_SMALL,
				TextXAlignment = Enum.TextXAlignment.Left,
				BackgroundTransparency = 1,

				TextColor3 = footerTheme.labelTextColor,
			}),
		}

		for index, background in ipairs(backgrounds) do
			local name = background.name

			local isSelected = index == selectedBackgroundIndex
			local isHovered = index == hoveredBackgroundIndex

			backgroundComponents[name] = Roact.createElement(FooterButton, {
				index = index,
				name = name,

				isSelected = isSelected,
				isHovered = isHovered,

				onHoverStarted = self.onHoverStarted,
				onHoverEnded = self.onHoverEnded,
				onClick = self.onClick,
			})
		end

		return Roact.createElement("ImageButton", {
			AnchorPoint = Vector2.new(0, 1),
			Position = UDim2.new(0, 0, 1, 0),
			Size = UDim2.new(1, 0, 0, Constants.FOOTER_HEIGHT),

			BackgroundColor3 = footerTheme.backgroundColor,
			BorderColor3 = footerTheme.borderColor,

			ZIndex = 2,
			AutoButtonColor = false,

			[Roact.Event.InputEnded] = self.inputEnded,
		}, {
			UIPadding = Roact.createElement("UIPadding", {
				PaddingBottom = UDim.new(0, 0),
				PaddingLeft = UDim.new(0, 6),
				PaddingRight = UDim.new(0, 6),
				PaddingTop = UDim.new(0, 0),
			}),

			Frame = Roact.createElement("ImageButton", {
				AnchorPoint = Vector2.new(0, 0.5),
				Position = UDim2.new(0, 0, 0.5, 0),
				Size = UDim2.new(1, 0, 0, 24),
				BackgroundTransparency = 1,
				AutoButtonColor = false,
			}, backgroundComponents),
		})
	end)
end

local function mapStateToProps(state, props)
	state = state or {}

	local pageInfo = state.pageInfo or {}

	return {
		selectedBackgroundIndex = pageInfo.selectedBackgroundIndex or 1,
		hoveredBackgroundIndex = pageInfo.hoveredBackgroundIndex or 0,
	}
end

local function mapDispatchToProps(dispatch)
	return {
		onBackgroundSelectorHovered = function(settings, index)
			dispatch(ChangeBackground(settings, index, false))
		end,

		onBackgroundSelectorHoverEnded = function(settings, index)
			dispatch(ChangeBackground(settings, 0, false))
		end,

		onBackgroundSelectorClicked = function(settings, index)
			dispatch(ChangeBackground(settings, index, true))
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(Footer)
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX329A231C260D499780A3317E07BAF3D7">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">FooterButton</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local Background = require(Plugin.Core.Types.Background)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local RoundButton = require(Plugin.Core.Components.RoundButton)

local FooterButton = Roact.PureComponent:extend("FooterButton")

function FooterButton:init(props)
	self.onMouseEnter = function(rbx, x, y)
		props.onHoverStarted(props.index)
	end

	self.onMouseLeave = function(rbx, x, y)
		props.onHoverEnded(props.index)
	end

	self.onMouseButton1Down = function(rbx, x, y)
		props.onClick(props.index)
	end
end

function FooterButton:render()
	return withTheme(function(theme)
		local props = self.props

		local index = props.index
		local name = props.name

		local isSelected = props.isSelected
		local isHovered = props.isHovered

		local footerTheme = theme.footer
		local buttonTheme = footerTheme.button

		return Roact.createElement(RoundButton, {
			AnchorPoint = Vector2.new(0, 0.5),
			LayoutOrder = index,
			Size = UDim2.new(0, 58, 1, 0),

			BackgroundColor3 = isSelected and buttonTheme.backgroundSelectedColor or buttonTheme.backgroundColor,
			BorderColor3 = (isSelected or isHovered) and buttonTheme.borderSelectedColor or buttonTheme.borderColor,

			[Roact.Event.MouseEnter] = self.onMouseEnter,
			[Roact.Event.MouseLeave] = self.onMouseLeave,
			[Roact.Event.MouseButton1Down] = self.onMouseButton1Down,
		}, {
			UIPadding = Roact.createElement("UIPadding", {
				PaddingBottom = UDim.new(0, 6),
				PaddingLeft = UDim.new(0, 6),
				PaddingRight = UDim.new(0, 6),
				PaddingTop = UDim.new(0, 6),
			}),

			Icon = Background.renderIcon(index, {
				AnchorPoint = Vector2.new(0, 0.5),
				Position = UDim2.new(0, 0, 0.5, 0),
				Size = UDim2.new(0, Constants.BACKGROUND_ICON_SIZE, 0, Constants.BACKGROUND_ICON_SIZE),
			}),

			TextLabel = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Position = UDim2.new(0, 14, 0, -1),
				Size = UDim2.new(1, -14, 1, 0),

				TextColor3 = isSelected and buttonTheme.textSelectedColor or buttonTheme.textColor,

				Font = Constants.FONT,
				Text = name,
				TextSize = Constants.FONT_SIZE_SMALL,
			}),
		})
	end)
end

return FooterButton
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDD993E0586A74561BC85252C9E8BC49E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">FooterButton.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local FooterButton = require(Plugin.Core.Components.Footer.FooterButton)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			FooterButton = Roact.createElement(FooterButton),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3DADFE25D3F640F1AB60533C447561EC">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Footer.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local Colors = require(Plugin.Core.Util.Colors)
	local MockWrapper = require(Plugin.Core.Util.MockWrapper)
	local ToolboxTheme = require(Plugin.Core.Util.ToolboxTheme)

	local Footer = require(Plugin.Core.Components.Footer.Footer)

	local Workspace = game:GetService("Workspace")

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			Footer = Roact.createElement(Footer, {
				backgrounds = {},
				selectedBackgroundIndex = 1,
				hoveredBackgroundIndex = 0,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should have the correct background buttons", function()
		local backgrounds = {
			{
				name = "Test1",
			},
			{
				name = "Example",
			},
			{
				name = "Hello world"
			}
		}

		local element = Roact.createElement(MockWrapper, {}, {
			Footer = Roact.createElement(Footer, {
				backgrounds = backgrounds,
				selectedBackgroundIndex = 1,
				hoveredBackgroundIndex = 0,
			}),
		})

		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "Footer")

		local footer = container.Footer
		local frame = footer.Frame -- Container frame inside the footer

		for _, background in ipairs(backgrounds) do
			expect(frame[background.name]).to.be.ok()
		end

		-- "+ 2" for the text label and UIListLayout
		expect(#frame:GetChildren()).to.equal(#backgrounds + 2)

		Roact.unmount(instance)
	end)

	it("should select and hover the correct background buttons", function()
		if ToolboxTheme.enableLuaApisForTheme() then
			-- TODO CLIDEVSRVS-1687: Fix this test for the new theme APIs
			-- It checks the colours of buttons but they can be different with the new API
			return
		end

		local backgrounds = {
			{
				name = "Test1",
			},
			{
				name = "Example",
			},
			{
				name = "Hello world"
			}
		}
		local selectedIndex = 1
		local hoveredIndex = 2

		local element = Roact.createElement(MockWrapper, {}, {
			Footer = Roact.createElement(Footer, {
				backgrounds = backgrounds,
				selectedBackgroundIndex = selectedIndex,
				hoveredBackgroundIndex = hoveredIndex,
			}),
		})

		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "Footer")

		local footer = container.Footer
		local frame = footer.Frame -- Container frame inside the footer

		for index, background in ipairs(backgrounds) do
			if index == selectedIndex then
				expect(frame[background.name].ImageColor3).to.equal(Colors.BLUE_PRIMARY)
			else
				expect(frame[background.name].ImageColor3).to.equal(Colors.WHITE)
			end

			if index == hoveredIndex or index == selectedIndex then
				expect(frame[background.name].Border.ImageColor3).to.equal(Colors.BLUE_PRIMARY)
			else
				expect(frame[background.name].Border.ImageColor3).to.equal(Colors.GRAY_3)
			end
		end

		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX948F699D4E664555917DD4255575BA39">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Toast</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Message to the user that appears at the bottom of their screen

	Props:
		string Text
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Colors = require(Plugin.Core.Util.Colors)
local Constants = require(Plugin.Core.Util.Constants)

local RoundFrame = require(Plugin.Core.Components.RoundFrame)

-- TODO CLIDEVSRVS-1591: Finish this
local function Toast(props)
	local text = props.Text or ""

	local fontSize = Constants.FONT_SIZE_SMALL
	local font = Constants.FONT

	local textBounds = Constants.getTextSize(text, fontSize, font)

	local horizontalPadding = 12
	local verticalPadding = 8
	local width = horizontalPadding + textBounds.x + horizontalPadding
	local height = verticalPadding + textBounds.y + verticalPadding

	local distFromBottom = 16

	return Roact.createElement(RoundFrame, {
		AnchorPoint = Vector2.new(0.5, 1),
		Position = UDim2.new(0.5, 0, 1, -distFromBottom),
		Size = UDim2.new(0, width, 0, height),
		ZIndex = 10,

		BackgroundColor3 = Colors.GRAY_2,
		BackgroundTransparency = 0.2,
	}, {
		TextLabel = Roact.createElement("TextLabel", {
			Position = UDim2.new(0, 0, 0, -1),
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
			Text = text,
			Font = Constants.FONT,
			TextSize = Constants.FONT_SIZE_SMALL,
			TextColor3 = Colors.GRAY_6
		})
	})
end

return Toast
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC1BEC0167BB84D07BBF92931EE6B82BB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Tooltip.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Tooltip = require(Plugin.Core.Components.Tooltip)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			Tooltip = Roact.createElement(Tooltip),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX543F7EBFC104401EA39FB47D4E8CFD69">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ExternalServicesWrapper</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local ModalProvider = require(Plugin.Core.Providers.ModalProvider)
local NetworkProvider = require(Plugin.Core.Providers.NetworkProvider)
local PluginProvider = require(Plugin.Core.Providers.PluginProvider)
local SettingsProvider = require(Plugin.Core.Providers.SettingsProvider)
local ThemeProvider = require(Plugin.Core.Providers.ThemeProvider)

local function ExternalServicesWrapper(props)
	local store = props.store
	local plugin = props.plugin
	local pluginGui = props.pluginGui
	local settings = props.settings
	local theme = props.theme
	local networkInterface = props.networkInterface

	return Roact.createElement(RoactRodux.StoreProvider, {
		store = store
	}, {
		Roact.createElement(PluginProvider, {
			plugin = plugin,
			pluginGui = pluginGui,
		}, {
			Roact.createElement(SettingsProvider, {
				settings = settings,
			}, {
				Roact.createElement(ThemeProvider, {
					theme = theme,
				}, {
					Roact.createElement(ModalProvider, {}, {
						Roact.createElement(NetworkProvider, {
							networkInterface = networkInterface,
						}, props[Roact.Children])
					}),
				}),
			}),
		}),
	})
end

return ExternalServicesWrapper
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7EC24D7E437146689BAF158E5031A103">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundButton.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local RoundButton = require(Plugin.Core.Components.RoundButton)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(RoundButton)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX18BF618EA78F4557B52369B9694A9ED2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AssetGridContainer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A grid of assets. Use Layouter.calculateAssetsHeight() to know how tall it will be when the assets are rendered.

	Props:
		UDim2 Position = UDim2.new(0, 0, 0, 0)
		UDim2 Size = UDim2.new(1, 0, 1, 0)

		{number -> Asset} idToAssetMap
		[number] assetIds

		number currentSoundId
		boolean isPlaying

		callback onPreviewAudioButtonClicked()
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)

local getModal = require(Plugin.Core.Consumers.getModal)

local Asset = require(Plugin.Core.Components.Asset.Asset)

local PlayPreviewSound = require(Plugin.Core.Actions.PlayPreviewSound)
local PausePreviewSound = require(Plugin.Core.Actions.PausePreviewSound)
local ResumePreviewSound = require(Plugin.Core.Actions.ResumePreviewSound)

local Analytics = require(Plugin.Core.Util.Analytics.Analytics)

local AssetGridContainer = Roact.PureComponent:extend("AssetGridContainer")

function AssetGridContainer:init(props)
	self.state = {
		hoveredAssetId = 0,
	}

	-- Keep track of the timestamp an asset was last inserted
	-- Prevents double clicking on assets inserting 2 instead of just 1
	self.lastAssetInsertedTime = 0

	self.onAssetInserted = function()
		self.lastAssetInsertedTime = tick()
	end

	self.canInsertAsset = function()
		return tick() - self.lastAssetInsertedTime > Constants.TIME_BETWEEN_ASSET_INSERTION
	end

	self.onAssetHovered = function(assetId)
		if self.state.hoveredAssetId == 0 and self.state.hoveredAssetId ~= assetId and
			not getModal(self).isShowingModal() then
			self:setState({
				hoveredAssetId = assetId,
			})
		end
	end

	self.onAssetHoverEnded = function(assetId)
		self:setState({
			hoveredAssetId = 0,
		})
	end

	self.onFocusLost = function(rbx, input)
		if input.UserInputType == Enum.UserInputType.Focus then
			self.onAssetHoverEnded()
		end
	end

	self.onPreviewAudioButtonClicked = function(assetId)
		local currentSoundId = self.props.currentSoundId
		if currentSoundId == assetId then
			if self.props.isPlaying then
				self.props.pauseASound()

				Analytics.onSoundPaused()
				Analytics.onSoundPausedCounter()

			else
				self.props.resumeASound()

				Analytics.onSoundPlayed()
				Analytics.onSoundPlayedCounter()
			end
		else
			self.props.playASound(assetId)

			Analytics.onSoundPlayed()
			Analytics.onSoundPlayedCounter()
		end
	end
end

function AssetGridContainer.getDerivedStateFromProps(nextProps, lastState)
	if not nextProps.assetIds[lastState.hoveredAssetId] then
		return {
			hoveredAssetId = 0
		}
	end
end

function AssetGridContainer:render()
	local props = self.props
	local state = self.state

	local assetIds = props.assetIds

	local position = props.Position or UDim2.new(0, 0, 0, 0)
	local size = props.Size or UDim2.new(1, 0, 1, 0)

	local currentSoundId = props.currentSoundId
	local isPlaying = props.isPlaying

	local categoryIndex = props.categoryIndex

	local onPreviewAudioButtonClicked = self.onPreviewAudioButtonClicked

	local hoveredAssetId = state.hoveredAssetId

	local assetElements = {
		UIGridLayout = Roact.createElement("UIGridLayout", {
			CellPadding = UDim2.new(0, Constants.BETWEEN_ASSETS_HORIZONTAL_PADDING,
				0, Constants.BETWEEN_ASSETS_VERTICAL_PADDING),
			CellSize = UDim2.new(0, Constants.ASSET_WIDTH, 0, Constants.ASSET_HEIGHT),
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
			SortOrder = Enum.SortOrder.LayoutOrder,
		})
	}

	for index, assetId in ipairs(assetIds) do
		assetElements[tostring(assetId)] = Roact.createElement(Asset, {
			assetId = assetId,
			LayoutOrder = index,

			isHovered = assetId == hoveredAssetId,

			currentSoundId = currentSoundId,
			isPlaying = isPlaying,

			categoryIndex = categoryIndex,

			onAssetHovered = self.onAssetHovered,
			onAssetHoverEnded = self.onAssetHoverEnded,

			onPreviewAudioButtonClicked = onPreviewAudioButtonClicked,

			onAssetInserted = self.onAssetInserted,
			canInsertAsset = self.canInsertAsset,
		})
	end

	return Roact.createElement("Frame", {
		Position = position,
		Size = size,
		BackgroundTransparency = 1,

		[Roact.Event.InputEnded] = self.onFocusLost,
	}, assetElements)
end

local function mapStateToProps(state, props)
	state = state or {}

	local sound = state.sound or {}
	local pageInfo = state.pageInfo or {}

	return {
		currentSoundId = sound.currentSoundId or 0,
		isPlaying = sound.isPlaying or false,
		categoryIndex = pageInfo.categoryIndex or 1,
	}
end

local function mapDispatchToProps(dispatch)
	return {
		playASound = function(currentSoundId)
			dispatch(PlayPreviewSound(currentSoundId))
		end,

		pauseASound = function()
			dispatch(PausePreviewSound())
		end,

		resumeASound = function()
			dispatch(ResumePreviewSound())
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(AssetGridContainer)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFA39A771E1CB47899F9DE7AE6A29AE58">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundButton</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A button with rounded corners
	Supports different background and border colors
]]

local Plugin = script.Parent.Parent.Parent

local RoundElement = require(Plugin.Core.Components.RoundElement)

return RoundElement(true)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1AF930DC76734535AEADBEDFE4880C69">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SortComponent.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local SortComponent = require(Plugin.Core.Components.SortComponent)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			SortComponent = Roact.createElement(SortComponent),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5784E54EE4F84909B83B59B5E7D66DE1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundElement.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	--[[local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local RoundElement = require(Plugin.Core.Components.RoundElement)]]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF61EE2BCD90643A894FBCB69C1B9733E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DropdownMenu.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local DropdownMenu = require(Plugin.Core.Components.DropdownMenu)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			DropdownMenu = Roact.createElement(DropdownMenu, {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, 100, 0, 20),
				selectedIndex = 1,
				items = {},
				onItemClicked = function() end,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE1FFE2D682CF4236BE3439289A677800">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DraggableButton.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local DraggableButton = require(Plugin.Core.Components.DraggableButton)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(DraggableButton)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE939D20B421F4ABEA8EA5F025BA9F014">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DropShadow</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)
local Immutable = require(Plugin.Core.Util.Immutable)

local function DropShadow(props)
	local newProps = Immutable.JoinDictionaries(props, {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Image = Images.DROP_SHADOW_IMAGE,
		ImageColor3 = Constants.DROP_SHADOW_COLOR,
		ImageTransparency = Constants.DROP_SHADOW_TRANSPARENCY,
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Constants.DROP_SHADOW_SLICE_CENTER,
	})

	return Roact.createElement("ImageLabel", newProps)
end

return DropShadow
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD07B28FE60264B3FAD6B38929B7D03C7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InfoBanner.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local InfoBanner = require(Plugin.Core.Components.InfoBanner)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			InfoBanner = Roact.createElement(InfoBanner),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCDAF5FF2A179476FAE34BA3798D92B21">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPreviewButton</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A play/pause button for audio

	Props:
		UDim2 Position
		UDim2 Size
		number ZIndex
		number assetId
		number currentSoundId
		bool isPlaying

		callback onClick(number assetId)
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Images = require(Plugin.Core.Util.Images)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local AudioPreviewButton = Roact.PureComponent:extend("AudioPreviewButton")

function AudioPreviewButton:init(props)
	self.state = {
		isHovered = false,
	}

	self.onMouseEnter = function()
		self:setState({
			isHovered = true,
		})
	end

	self.onMouseLeave = function()
		self:setState({
			isHovered = false,
		})
	end
end

function AudioPreviewButton:render()
	return withTheme(function(theme)
		local props = self.props
		local state = self.state

		local position = props.Position or UDim2.new(0, 0, 0, 0)
		local size = props.Size or UDim2.new(0, 32, 0, 32)
		local zIndex = props.ZIndex or 0

		local assetId = props.assetId

		local currentSoundId = props.currentSoundId
		local isPlaying = props.isPlaying
		local isDarkerTheme = theme.isDarkerTheme
		local showPauseIcon = (currentSoundId == assetId) and isPlaying
		local isHovered = state.isHovered
		local imagePauseAudio = isDarkerTheme and Images.LIGHT_PAUSE_AUDIO or Images.PAUSE_AUDIO
		local imagePauseAudioHovered = isDarkerTheme and Images.LIGHT_PAUSE_AUDIO_HOVERED or Images.PAUSE_AUDIO_HOVERED
		local imagePlayAudio = isDarkerTheme and Images.LIGHT_PLAY_AUDIO or Images.PLAY_AUDIO
		local imagePlayAudioHovered = isDarkerTheme and Images.LIGHT_PLAY_AUDIO_HOVERED or Images.PLAY_AUDIO_HOVERED

		local image = showPauseIcon and (isHovered and imagePauseAudioHovered or imagePauseAudio)
			or (isHovered and imagePlayAudioHovered or imagePlayAudio)

		return Roact.createElement("ImageButton", {
			Position = position,
			Size = size,
			ZIndex = zIndex,

			Image = image,
			BackgroundTransparency = 1,

			[Roact.Event.MouseEnter] = self.onMouseEnter,
			[Roact.Event.MouseLeave] = self.onMouseLeave,
			[Roact.Event.MouseButton1Click] = function(rbx)
				props.onClick(assetId)
			end,
		})
	end)
end

return AudioPreviewButton
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX43F731C7280C4EBB829EFC819C7698D0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPreviewButton.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local AudioPreviewButton = require(Plugin.Core.Components.AudioPreviewButton)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			AudioPreviewButton = Roact.createElement(AudioPreviewButton),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCB4F0C76B66548499FDFAC52C7585C02">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StyledScrollingFrame</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Scrolling frame component with a custom scrollbar that mimics the Studio start page

	Props:
		UDim2 Position = UDim2.new(0, 0, 0, 0)
		UDim2 Size = UDim2.new(1, 0, 1, 0)
		UDim2 CanvasSize = UDim2.new(1, 0, 1, 0)
		number LayoutOrder = 1
		number ZIndex = 1
		boolean Visible = true

		callback onScroll()
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local function StyledScrollingFrame(props)
	return withTheme(function(theme)
		local position = props.Position or UDim2.new(0, 0, 0, 0)
		local size = props.Size or UDim2.new(1, 0, 1, 0)
		local canvasSize = props.CanvasSize or UDim2.new(1, 0, 1, 0)

		local layoutOrder = props.LayoutOrder or 1
		local zindex = props.ZIndex or 1
		local visible = (props.Visible ~= nil and props.Visible) or (props.Visible == nil)

		local onScroll = props.onScroll
		local ref = props[Roact.Ref]
		local children = props[Roact.Children]

		local scrollingFrameTheme = theme.scrollingFrame

		return Roact.createElement("Frame", {
			Position = position,
			Size = size,
			BackgroundTransparency = 1,

			LayoutOrder = layoutOrder,
			ZIndex = zindex,
			Visible = visible,
		}, {
			ScrollBarBackground = Roact.createElement("Frame", {
				AnchorPoint = Vector2.new(1, 0),
				Position = UDim2.new(1, 0, 0, 0),
				Size = UDim2.new(0, Constants.SCROLLBAR_BACKGROUND_THICKNESS, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = scrollingFrameTheme.scrollbarBackgroundColor,
			}),

			ScrollingFrame = Roact.createElement("ScrollingFrame", {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, -Constants.SCROLLBAR_PADDING, 1, 0),
				CanvasSize = canvasSize,
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				ScrollBarThickness = Constants.SCROLLBAR_THICKNESS,
				ZIndex = 2,

				TopImage = Images.SCROLLBAR_TOP_IMAGE,
				MidImage = Images.SCROLLBAR_MIDDLE_IMAGE,
				BottomImage = Images.SCROLLBAR_BOTTOM_IMAGE,

				ScrollBarImageColor3 = scrollingFrameTheme.scrollbarImageColor,

				ScrollingEnabled = true,
				ElasticBehavior = Enum.ElasticBehavior.Always,
				ScrollingDirection = Enum.ScrollingDirection.Y,

				[Roact.Change.CanvasPosition] = onScroll,
				[Roact.Ref] = ref,
			}, children),
		})
	end)
end

return StyledScrollingFrame
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEC3C9E9DC0474A7A94C9265E31E5DF0E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TooltipWrapper</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	This wrapper creates desired component and listen to the mouse event for the tooltip.
	This component provide tooltip with position and text it needs to show.

	Props:
		Instance target
		string Text
		bool canShowCurrentTooltip
		bool isHovered
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)

local withModal = require(Plugin.Core.Consumers.withModal)

local Tooltip = require(Plugin.Core.Components.Tooltip)

local TooltipWrapper = Roact.PureComponent:extend("TooltipWrapper")

function TooltipWrapper:init(props)
	self.state = {
		showToolTip = false,
	}

	self.targetTime = tick() + Constants.TOOLTIP_SHOW_UP_DELAY
	self.mousePos = nil

	self.onHovered = function()
		spawn(function()
			-- probabebly don't need this
			while self.props.isHovered do
				local currentTime = tick()
				if self and currentTime >= self.targetTime and (not self.state.showToolTip) and self._handle then
					self:setState({
						showToolTip = true,
					})
				else
					wait(0.1)
				end
			end
		end)
	end

	self.onUnhovered = function()
		self.targetTime = 0
		self.mousePos = nil
	end

	self.inputBegan = function(rbx, input)
		if input.UserInputType == Enum.UserInputType.MouseMovement then
			self.mousePos = input.Position
			self:setState({
				showToolTip = false
			})
		end
	end

	self.inputEnded = function(rbx, input)
		if input.UserInputType ~= Enum.UserInputType.MouseMovement then
			self:setState({
				showToolTip = false,
			})
		end
	end

	self.inputChanged = function(rbx, input)
		self.targetTime = tick() + Constants.TOOLTIP_SHOW_UP_DELAY
		self.mousePos = input.Position
	end
end

function TooltipWrapper:render()
	return withModal(function(modalTarget)
		local props = self.props
		local state = self.state

		if props.isHovered then
			self.onHovered()
		else
			self.onUnhovered()
		end

		local sizeConstraint = props.SizeConstraint or Enum.SizeConstraint.RelativeXY

		local text = props.Text
		local mousePos = self.mousePos

		local canShowCurrentTooltip = props.canShowCurrentTooltip

		local content = {}

		if state.showToolTip and mousePos and not DebugFlags.shouldDisableTooltips()
			and canShowCurrentTooltip and modalTarget then
			local targetWidth = modalTarget.AbsoluteSize.X
			local targetHeight = modalTarget.AbsoluteSize.Y
			content.TooltipPortal = Roact.createElement(Roact.Portal, {
				target = modalTarget,
			}, {
				Tooltip = Roact.createElement(Tooltip, {
					position = mousePos,
					text = text,

					targetWidth = targetWidth,
					targetHeight = targetHeight,
				}),
			})
		end

		return Roact.createElement("Frame",{
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
			SizeConstraint = sizeConstraint,

			[Roact.Event.InputBegan] = self.inputBegan,
			[Roact.Event.InputChanged] = self.inputChanged,
			[Roact.Event.InputEnded] = self.inputEnded,
		}, content)
	end)
end

return TooltipWrapper
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX516AD99A2EEE4B4795F9ED0D8110748F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Toolbox.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local Category = require(Plugin.Core.Types.Category)
	local Suggestion = require(Plugin.Core.Types.Suggestion)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Toolbox = require(Plugin.Core.Components.Toolbox)

	local Workspace = game:GetService("Workspace")

	local function createTestToolbox(container, name)
		local element = Roact.createElement(MockWrapper, {}, {
			Toolbox = Roact.createElement(Toolbox, {
				backgrounds = {},
				categories = Category.CATEGORIES,
				suggestions = Suggestion.SUGGESTIONS,
			}),
		})

		return Roact.mount(element, container or nil, name or "")
	end

	it("should create and destroy without errors", function()
		local instance = createTestToolbox()
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = Workspace.ToolboxTestsTarget
		local instance = createTestToolbox(container, "ToolboxComponent")
		local toolbox = container.ToolboxComponent

		expect(toolbox.Header).to.be.ok()
		expect(toolbox.MainView).to.be.ok()
		expect(toolbox.Footer).to.be.ok()

		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX23FB9C93D29342298AECE1A6F517EFE8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SortComponent</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A dropdown menu with a descriptive "sort by" label

	Props:
		UDim2 Position
		UDim2 Size
		number ZIndex
		Sorts sorts
		number sortIndex

		callback onSortSelected()
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local DropdownMenu = require(Plugin.Core.Components.DropdownMenu)

local function SortComponent(props)
	return withTheme(function(theme)
		local position = props.Position or UDim2.new(0, 0, 0, 0)
		local size = props.Size or UDim2.new(1, 0, 1, 0)
		local zindex = props.ZIndex or 1

		local sortByText = "Sort by:"
		local sortByFont = Constants.FONT
		local sortByFontSize = Constants.FONT_SIZE_LARGE

		local sortByWidth = Constants.getTextSize(sortByText, sortByFontSize, sortByFont).x

		local sortComponentTheme = theme.sortComponent

		return Roact.createElement("Frame", {
			Position = position,
			Size = size,
			ZIndex = zindex,
			BackgroundTransparency = 1,
		}, {
			UIPadding = Roact.createElement("UIPadding", {
				PaddingBottom = UDim.new(0, Constants.SORT_COMPONENT_OUTER_PADDING),
				PaddingLeft = UDim.new(0, Constants.SORT_COMPONENT_OUTER_PADDING),
				PaddingRight = UDim.new(0, Constants.SORT_COMPONENT_OUTER_PADDING),
				PaddingTop = UDim.new(0, Constants.SORT_COMPONENT_OUTER_PADDING),
			}),

			UIListLayout = Roact.createElement("UIListLayout", {
				FillDirection = Enum.FillDirection.Horizontal,
				SortOrder = Enum.SortOrder.LayoutOrder,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				Padding = UDim.new(0, Constants.SORT_COMPONENT_INNER_PADDING),
			}),

			Label = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				Size = UDim2.new(0, sortByWidth, 1, 0),
				Text = sortByText,
				Font = sortByFont,
				TextSize = sortByFontSize,
				TextColor3 = sortComponentTheme.labelTextColor,
				LayoutOrder = 0,
			}),

			DropdownMenu = Roact.createElement(DropdownMenu, {
				Size = UDim2.new(0, Constants.SORT_COMPONENT_CATEGORY_DROPDOWN_WIDTH, 1, 0),
				LayoutOrder = 1,
				items = props.sorts,
				selectedDropDownIndex = props.sortIndex,
				onItemClicked = props.onSortSelected,
			})
		})
	end)
end

return SortComponent
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX259F8A4BF53C4A3396D2B0385B96837A">
					<Properties>
						<string name="Name">SearchBar</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX17AB982F3D22440788436FBD97B57E90">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBarButtons</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local SearchBarButtons = Roact.PureComponent:extend("SearchBar")

function SearchBarButtons:init()
	self.state = {
		isSearchButtonHovered = false,
		isClearButtonHovered = false,
	}

	self.onClearButtonHovered = function()
		if not self.state.isClearButtonHovered then
			MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		end
		self:setState({
			isClearButtonHovered = true,
		})
	end

	self.onClearButtonHoverEnded = function()
		if self.state.isClearButtonHovered then
			MouseManager:popIcon(Images.CURSOR_POINTING_HAND)
		end
		self:setState({
			isClearButtonHovered = false,
		})
	end

	self.onClearButtonClicked = function()
		self.props.onClearButtonClicked()

		-- Stop hovering on the clear button so that when it reappears,
		-- it doesn't start in a hover state
		self.onClearButtonHoverEnded()
	end

	self.onSearchButtonHovered = function()
		if not self.state.isSearchButtonHovered then
			MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		end
		self:setState({
			isSearchButtonHovered = true,
		})
	end

	self.onSearchButtonHoverEnded = function()
		if self.state.isSearchButtonHovered then
			MouseManager:popIcon(Images.CURSOR_POINTING_HAND)
		end
		self:setState({
			isSearchButtonHovered = false,
		})
	end
end

function SearchBarButtons:render()
	return withTheme(function(theme)
		local props = self.props
		local state = self.state

		local isSearchButtonHovered = state.isSearchButtonHovered
		local isClearButtonHovered = state.isClearButtonHovered

		local showClearButton = props.showClearButton


		local onSearchButtonClicked = props.onSearchButtonClicked

		local buttonWidth = Constants.SEARCH_BAR_BUTTON_WIDTH
		local buttonsWidth = (2 * buttonWidth) + 1
		local buttonInset = Constants.SEARCH_BAR_BUTTON_INSET

		local searchBarTheme = theme.searchBar

		return Roact.createElement("Frame", {
			AnchorPoint = Vector2.new(1, 0),
			Position = UDim2.new(1, 0, 0, 0),
			Size = UDim2.new(0, buttonsWidth, 1, 0),
			BackgroundTransparency = 1,
		}, {
			ClearButton = showClearButton and Roact.createElement("ImageButton", {
				AnchorPoint = Vector2.new(0, 0),
				Position = UDim2.new(0, buttonInset, 0, buttonInset),
				Size = UDim2.new(0, buttonWidth - (2 * buttonInset), 1, -(2 * buttonInset)),
				BackgroundTransparency = 1,

				[Roact.Event.MouseEnter] = self.onClearButtonHovered,
				[Roact.Event.MouseMoved] = self.onClearButtonHovered,
				[Roact.Event.MouseLeave] = self.onClearButtonHoverEnded,
				[Roact.Event.MouseButton1Down] = self.onClearButtonClicked,
			}, {
				ImageLabel = Roact.createElement("ImageLabel", {
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.new(0, Constants.SEARCH_BAR_BUTTON_ICON_SIZE,
						0, Constants.SEARCH_BAR_BUTTON_ICON_SIZE),
					BackgroundTransparency = 1,
					Image = isClearButtonHovered and Images.CLEAR_ICON_HOVER or Images.CLEAR_ICON,
					ImageColor3 = isClearButtonHovered and searchBarTheme.clearButton.imageSelectedColor
						or searchBarTheme.clearButton.imageColor
				}),
			}),

			-- Thin dividing line between the text box
			Line = Roact.createElement("Frame", {
				AnchorPoint = Vector2.new(0, 0),
				-- Remove a pixel from top and bottom
				-- So it doesn't overlap the external border
				Position = UDim2.new(0, buttonWidth, 0, 1),
				Size = UDim2.new(0, 1, 1, -2),
				BackgroundColor3 = searchBarTheme.divideLineColor,
				BorderSizePixel = 0,
			}),

			SearchButton = Roact.createElement("ImageButton", {
				AnchorPoint = Vector2.new(1, 0),
				Position = UDim2.new(1, -buttonInset, 0, buttonInset), -- Negative inset because anchor point
				Size = UDim2.new(0, buttonWidth - (2 * buttonInset), 1, -(2 * buttonInset)),
				BackgroundTransparency = 1,

				[Roact.Event.MouseEnter] = self.onSearchButtonHovered,
				[Roact.Event.MouseMoved] = self.onSearchButtonHovered,
				[Roact.Event.MouseLeave] = self.onSearchButtonHoverEnded,
				[Roact.Event.MouseButton1Down] = onSearchButtonClicked,
			}, {
				ImageLabel = Roact.createElement("ImageLabel", {
					AnchorPoint = Vector2.new(0.5, 0.5),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.new(0, Constants.SEARCH_BAR_BUTTON_ICON_SIZE,
						0, Constants.SEARCH_BAR_BUTTON_ICON_SIZE),
					BackgroundTransparency = 1,
					Image = Images.SEARCH_ICON,
					ImageColor3 = isSearchButtonHovered and searchBarTheme.searchButton.imageSelectedColor
						or searchBarTheme.searchButton.imageColor
				}),
			}),
		})
	end)
end

return SearchBarButtons
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF5D63B94D85140569C808F9A0A8ADCBD">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBarButtons.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local SearchBarButtons = require(Plugin.Core.Components.SearchBar.SearchBarButtons)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			SearchBarButtons = Roact.createElement(SearchBarButtons)
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX244F0520CE584FCF82703B0CE028EEBB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBar</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Search Bar Component

	Implements a search bar component with a text box that dynamically moves as you type, and a button to request a search.

	Props:
		number width : how wide the search bar is
		number LayoutOrder = 0 : optional layout order for UI layouts
		string searchTerm

		callback onSearchRequested(string searchTerm) : callback for when the user presses the enter key
			or clicks the search button
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local RoundButton = require(Plugin.Core.Components.RoundButton)
local SearchBarButtons = require(Plugin.Core.Components.SearchBar.SearchBarButtons)

local SearchBar = Roact.PureComponent:extend("SearchBar")

local function stripSearchTerm(searchTerm)
	return searchTerm and searchTerm:gsub("\n", " ") or ""
end

function SearchBar:init()
	self.state = {
		text = "",
		lastSearchTermAsProp = "",

		isFocused = false,
		isContainerHovered = false,
	}

	self.textBoxRef = Roact.createRef()

	self.requestSearch = function()
		self.props.onSearchRequested(self.state.text)
	end

	self.onContainerHovered = function()
		if not self.state.isContainerHovered then
			MouseManager:pushIcon(Images.CURSOR_I_BEAM)
		end
		self:setState({
			isContainerHovered = true,
		})
	end

	self.onContainerHoverEnded = function()
		if self.state.isContainerHovered then
			MouseManager:popIcon(Images.CURSOR_I_BEAM)
			-- MouseManager:clearIcons()
		end
		self:setState({
			isContainerHovered = false,
		})
	end

	self.onBackgroundClicked = function()
		-- Check if the search button was clicked or not
		-- If it was clicked, we don't want to focus on the text box
		if self.textBoxRef and self.textBoxRef.current then
			self.textBoxRef.current:CaptureFocus()
		end
	end

	self.onBackgroundFocusLost = function(rbx, input)
		if input.UserInputType == Enum.UserInputType.Focus then
			self:onFocusLost(false)
		end
	end

	self.onTextChanged = function(rbx)
		local text = stripSearchTerm(rbx.Text)
		if self.state.text ~= text then
			self:setState({
				text = text,
			})
		end
	end

	self.onTextBoxFocused = function(rbx)
		self:setState({
			isFocused = true,
		})
	end

	self.onTextBoxFocusLost = function(rbx, enterPressed, inputObject)
		self:onFocusLost(enterPressed)
	end

	self.onClearButtonClicked = function()
		-- Also clear the hovered state because otherwise when it gets set to
		-- visible = false because the text is empty, it won't get the mouse
		-- leave event
		self:setState({
			text = "",
		})

		self.requestSearch()
	end
end

function SearchBar.getDerivedStateFromProps(nextProps, lastState)
	-- Check if the search term passed in as a prop is different to the last
	-- one passed in. If it is, then that means the user searched for
	-- something externally (e.g. clicking on a suggestion) or the search
	-- was cleared because the category changed. In that case, we should
	-- override our own text value with what was passed in. The check is so
	-- that it only happens once, rather than every time the search bar is
	-- rerendered.
	local searchTerm = stripSearchTerm(nextProps.searchTerm)
	local lastSearchTermAsProp = lastState.lastSearchTermAsProp or ""

	if (searchTerm ~= lastSearchTermAsProp) then
		return {
			text = searchTerm,
			lastSearchTermAsProp = searchTerm
		}
	end

	return {}
end

function SearchBar:onFocusLost(enterPressed)
	self:setState({
		isFocused = false,
		isContainerHovered = false,
	})

	MouseManager:popIcon(Images.CURSOR_I_BEAM)

	if (enterPressed) then
		self.requestSearch()
	end
end

function SearchBar:render()
	return withTheme(function(theme)
		local props = self.props
		local state = self.state

		local containerWidth = props.width
		local layoutOrder = props.LayoutOrder or 0

		local text = state.text

		local isFocused = state.isFocused
		local isContainerHovered = state.isContainerHovered

		local showClearButton = #text > 0

		--[[
		By default, TextBoxes let you keep typing infinitely and it will just go out of the bounds
		(unless you set properties like ClipDescendants, TextWrapped)
		Elsewhere, text boxes shift their contents to the left as you're typing past the bounds
		So what you're typing is on the screen

		This is implemented here by:
		- Set ClipsDescendants = true on the container
		- Get the width of the container, subtracting any padding and the width of the button on the right
		- Get the width of the text being rendered (this is calculated in the Roact.Change.Text event)
		- If the text is shorter than the parent, then:
			- Anchor the text label to the left side of the parent
			- Set its width = container width
		- Else
			- Anchor the text label to the right side of the parent
			- Sets its width = text width (with AnchorPoint = (1, 0), this grows to the left)
		]]

		local innerPadding = 4

		local buttonsWidth = (2 * Constants.SEARCH_BAR_BUTTON_WIDTH) + 1
		-- Let the text box get closer to the buttons
		local adjustedButtonsWidth = buttonsWidth - 6

		local parentWidth = containerWidth - adjustedButtonsWidth - (2 * innerPadding)

		local textWidth = Constants.getTextSize(text).x
		local isShorterThanParent = textWidth < parentWidth

		local searchBarTheme = theme.searchBar
		local focusOrHovered = isFocused or isContainerHovered

		return Roact.createElement("Frame", {
			Size = UDim2.new(0, containerWidth, 1, 0),
			BackgroundTransparency = 1,
			LayoutOrder = layoutOrder,
		}, {
			Background = Roact.createElement(RoundButton, {
				Position = UDim2.new(0, -1, 0, -1),
				Size = UDim2.new(1, 2, 1, 2),

				BorderColor3 = focusOrHovered and searchBarTheme.borderSelectedColor or searchBarTheme.borderColor,
				ClipsDescendants = true,

				BackgroundColor3 = searchBarTheme.backgroundColor,

				[Roact.Event.MouseEnter] = self.onContainerHovered,
				[Roact.Event.MouseMoved] = self.onContainerHovered,
				[Roact.Event.MouseLeave] = self.onContainerHoverEnded,
				[Roact.Event.MouseButton1Down] = self.onBackgroundClicked,
				[Roact.Event.InputEnded] = self.onBackgroundFocusLost,
			}, {
				-- Parent the text box to another frame to make the logic for calculating position with the padding easier
				TextContainer = Roact.createElement("Frame", {
					Position = UDim2.new(0, innerPadding, 0, innerPadding),
					Size = UDim2.new(1, -(adjustedButtonsWidth + (innerPadding * 2)), 1, -innerPadding * 2),
					BackgroundTransparency = 1,
					ZIndex = 2,
				}, {
					TextBox = Roact.createElement("TextBox", {
						AnchorPoint = Vector2.new(isShorterThanParent and 0 or 1, 0),
						Position = UDim2.new(isShorterThanParent and 0 or 1, 0, 0, 0),
						Size = UDim2.new(0, textWidth, 1, 0),
						BackgroundTransparency = 1,

						ClearTextOnFocus = false,
						Font = Constants.FONT,
						TextSize = Constants.FONT_SIZE_MEDIUM,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextColor3 = searchBarTheme.textColor,
						Text = text,

						PlaceholderText = "Search",
						PlaceholderColor3 = searchBarTheme.placeholderTextColor,

						-- Get a reference to the text box so that clicking on the container can call :CaptureFocus()
						[Roact.Ref] = self.textBoxRef,

						[Roact.Change.Text] = self.onTextChanged,
						[Roact.Event.Focused] = self.onTextBoxFocused,
						[Roact.Event.FocusLost] = self.onTextBoxFocusLost,
					}),
				}),

				Buttons = Roact.createElement(SearchBarButtons, {
					showClearButton = showClearButton,
					onClearButtonClicked = self.onClearButtonClicked,
					onSearchButtonClicked = self.requestSearch,
				})
			}),
		})
	end)
end

return SearchBar
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3A66AFDCFCF1421BA839E3A38E03574A">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBar.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local SearchBar = require(Plugin.Core.Components.SearchBar.SearchBar)

	local Workspace = game:GetService("Workspace")

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			SearchBar = Roact.createElement(SearchBar, {
				width = 100,
				onSearchRequested = function() end,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	describe("the textbox", function()
		it("should move as text is typed", function()
			local width = 200
			local element = Roact.createElement(MockWrapper, {}, {
				SearchBar = Roact.createElement(SearchBar, {
					width = width,
				}),
			})
			local container = Workspace.ToolboxTestsTarget
			local instance = Roact.mount(element, container, "SearchBar")
			local searchBar = container.SearchBar
			local textBox = searchBar.Background.Border.TextContainer.TextBox

			local str = ("abcdefghijklmnopqrstuvwxyz"):rep(2)

			textBox.Text = str:sub(1, 1)
			local previousWidth = textBox.AbsoluteSize.x

			for i = 1, #str, 1 do
				local text = str:sub(1, i)
				textBox.Text = text

				local width = textBox.AbsoluteSize.x
				expect(width >= previousWidth).to.equal(true)
				previousWidth = width
			end

			Roact.unmount(instance)
		end)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX7B7F3F9666C94B1FBE4DC6CF54449AB0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TooltipWrapper.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local TooltipWrapper = require(Plugin.Core.Components.TooltipWrapper)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			TooltipWrapper = Roact.createElement(TooltipWrapper),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEA4D5F4D20364A40A7650DF11A4E8B31">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Tooltip</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Generic tooltip

	Props:
		Vector2 Position 		where we want to show the Tooltip
		string Text 		the texts that are going to be showing on the tooltip
		number targetWidth
		number targetHeight
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local DropShadow = require(Plugin.Core.Components.DropShadow)

local function Tooltip(props)
	return withTheme(function(theme)
		local position = props.position
		if not position then
			return
		end

		local text = props.text or ""

		local targetWidth = props.targetWidth
		local targetHeight = props.targetHeight

		local fontSize = Constants.FONT_SIZE_SMALL
		local textBound = Constants.getTextSize(text, fontSize, Constants.FONT, Vector2.new(100, 9000))

		local targetX = position.X
		local targetY = position.Y

		local tooltipTargetWidth = textBound.X + 2 * Constants.TOOLTIP_PADDING
		local tooltipTargetHeight = textBound.Y + 2 * Constants.TOOLTIP_PADDING

		if targetX + tooltipTargetWidth >= targetWidth then
			targetX = targetWidth - tooltipTargetWidth
		end

		if targetY + tooltipTargetHeight >= targetHeight then
			targetY = targetHeight - tooltipTargetHeight
		end

		local tooltipTheme = theme.tooltip

		return Roact.createElement("Frame", {
			Position = UDim2.new(0, targetX, 0, targetY),
			Size = UDim2.new(0, tooltipTargetWidth, 0, tooltipTargetHeight),
			BackgroundTransparency = 1,
		}, {
			DropShadow = Roact.createElement(DropShadow, {
				Position = UDim2.new(0, 2, 0, 2),
				Size = UDim2.new(1, 4, 1, 4),
				ZIndex = 1,
			}),

			ContentFrame = Roact.createElement("Frame", {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 1, 0),
				ZIndex = 2,

				BackgroundColor3 = tooltipTheme.backgroundColor,
				BorderColor3 = tooltipTheme.borderColor,
			}, {
				UIPadding = Roact.createElement("UIPadding", {
					PaddingBottom = UDim.new(0, Constants.TOOLTIP_PADDING),
					PaddingLeft = UDim.new(0, Constants.TOOLTIP_PADDING),
					PaddingRight = UDim.new(0, Constants.TOOLTIP_PADDING),
					PaddingTop = UDim.new(0, Constants.TOOLTIP_PADDING),
				}),

				Label = Roact.createElement("TextLabel", {
					Position = UDim2.new(0, 0, 0, 0),
					Size = UDim2.new(1, 0, 1, 0),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Text = text,

					TextColor3 = tooltipTheme.textColor,

					Font = Constants.FONT,
					TextSize = fontSize,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					TextWrapped = true,
					LineHeight = Constants.TOOLTIP_LINE_HEIGHT,
					ZIndex = 10,
				}),
			})
		})
	end)
end

return Tooltip
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXD4B176C47E54447FBE14C85956C64DDB">
					<Properties>
						<string name="Name">MainView</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCA6DE692C2FC4B0F805AE70CF4AA5298">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MainViewHeader</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Analytics = require(Plugin.Core.Util.Analytics.Analytics)
local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Layouter = require(Plugin.Core.Util.Layouter)
local PageInfoHelper = require(Plugin.Core.Util.PageInfoHelper)

local Category = require(Plugin.Core.Types.Category)

local getNetwork = require(Plugin.Core.Consumers.getNetwork)
local getSettings = require(Plugin.Core.Consumers.getSettings)

local SortComponent = require(Plugin.Core.Components.SortComponent)
local Suggestions = require(Plugin.Core.Components.Suggestions.Suggestions)

local RequestSearchRequest = require(Plugin.Core.Networking.Requests.RequestSearchRequest)
local SelectSortRequest = require(Plugin.Core.Networking.Requests.SelectSortRequest)

local MainViewHeader = Roact.PureComponent:extend("MainViewHeader")

function MainViewHeader:init()
	local networkInterface = getNetwork(self)
	local settings = getSettings(self)

	-- TODO CLIDEVSRVS-1688: This was copied from Header.lua. Move this to a separate file?
	self.onSearchRequested = function(searchTerm)
		if type(searchTerm) ~= "string" and DebugFlags.shouldDebugWarnings() then
			warn(("Toolbox onSearchRequested searchTerm = %s is not a string"):format(tostring(searchTerm)))
		end

		Analytics.onTermSearched(PageInfoHelper.getCategory(self.props.categories, self.props.categoryIndex), searchTerm)

		self.props.requestSearch(networkInterface, settings, searchTerm)
	end

	self.onSortSelected = function(index)
		if self.props.sortIndex ~= index then
			self.props.selectSort(networkInterface, settings, index)
		end
	end

	self.onSuggestionSelected = function(index)
		self.onSearchRequested(self.props.suggestions[index])
	end
end

function MainViewHeader:render()
	local props = self.props

	local categoryIndex = props.categoryIndex or 0

	local searchTerm = props.searchTerm or ""

	local sorts = props.sorts or {}
	local sortIndex = props.sortIndex or 0

	local suggestions = props.suggestions or {}

	local onSortSelected = self.onSortSelected
	local onSuggestionSelected = self.onSuggestionSelected

	local containerWidth = props.containerWidth or 0

	local headerHeight = 0
	local headerChildren = {}

	local showSort = #searchTerm > 0
	local showSuggestions = searchTerm == ""

	-- Only the free assets have sort and suggestions
	if not Category.categoryIsFreeAsset(categoryIndex) then
		showSort = false
		showSuggestions = false
	end

	if showSort then
		local top = headerHeight
		local height = Constants.SORT_COMPONENT_HEIGHT
		headerHeight = headerHeight + height

		headerChildren.SortComponent = Roact.createElement(SortComponent, {
			Position = UDim2.new(0, 0, 0, top),
			Size = UDim2.new(1, 0, 0, height),
			ZIndex = 2,

			sorts = sorts,
			sortIndex = sortIndex,
			onSortSelected = onSortSelected,
		})
	end

	if showSuggestions then
		local padding = showSort and Constants.MAIN_VIEW_VERTICAL_PADDING or 0
		local top = headerHeight + padding
		local height = Layouter.calculateSuggestionsHeight(Constants.SUGGESTIONS_INTRO_TEXT, suggestions, containerWidth)
		headerHeight = headerHeight + padding + height

		headerChildren.Suggestions = Roact.createElement(Suggestions, {
			Position = UDim2.new(0, 0, 0, top),
			Size = UDim2.new(1, 0, 0, height),
			maxWidth = containerWidth,
			ZIndex = 1,

			initialText = Constants.SUGGESTIONS_INTRO_TEXT,
			suggestions = suggestions,
			onSuggestionSelected = onSuggestionSelected,
		})
	end

	-- Fake some extra padding if there's no header
	headerHeight = math.max(headerHeight, Constants.MIN_WIDTH_EXTRA_PADDING)

	return Roact.createElement("Frame", {
		-- Shift the header up a little bit
		Position = UDim2.new(0, 0, 0, -2),
		Size = UDim2.new(0, containerWidth, 0, headerHeight),
		BackgroundTransparency = 1,
		ZIndex = 2,
	}, headerChildren)
end

local function mapStateToProps(state, props)
	state = state or {}

	local pageInfo = state.pageInfo or {}

	return {
		categories = pageInfo.categories or {},
		categoryIndex = pageInfo.categoryIndex or 1,

		searchTerm = pageInfo.searchTerm or "",

		sorts = pageInfo.sorts or {},
		sortIndex = pageInfo.sortIndex or 1,
	}
end

local function mapDispatchToProps(dispatch)
	return {
		selectSort = function(networkInterface, settings, sortIndex)
			dispatch(SelectSortRequest(networkInterface, settings, sortIndex))
		end,

		requestSearch = function(networkInterface, settings, searchTerm)
			dispatch(RequestSearchRequest(networkInterface, settings, searchTerm))
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(MainViewHeader)
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC340350CBE05459895DE29D9092BC066">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MainView.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local Constants = require(Plugin.Core.Util.Constants)
	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Suggestion = require(Plugin.Core.Types.Suggestion)

	local MainView = require(Plugin.Core.Components.MainView.MainView)

	local Workspace = game:GetService("Workspace")

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			MainView = Roact.createElement(MainView, {
				assets = {},
				suggestions = Suggestion.SUGGESTIONS,
				maxWidth = 100,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local toolboxWidth = 100

		local element = Roact.createElement(MockWrapper, {}, {
			MainView = Roact.createElement(MainView, {
				assets = {},
				suggestions = Suggestion.SUGGESTIONS,
				maxWidth = toolboxWidth,
			}),
		})

		local container = Workspace.ToolboxTestsTarget
		local instance = Roact.mount(element, container, "MainView")
		local mainView = container.MainView

		local scrollingFrameOuter = mainView.ScrollingFrame
		expect(scrollingFrameOuter).to.be.ok()

		local scrollingFrame = scrollingFrameOuter.ScrollingFrame
		expect(scrollingFrame).to.be.ok()

		local uiPadding = scrollingFrame.UIPadding
		expect(uiPadding).to.be.ok()

		local scrollContainer = scrollingFrame.Container
		expect(scrollContainer).to.be.ok()

		local header = scrollContainer.Header
		expect(header).to.be.ok()

		local suggestions = header.Suggestions
		expect(suggestions).to.be.ok()

		local assetGridContainer = scrollContainer.AssetGridContainer
		expect(assetGridContainer).to.be.ok()

		local innerHeight = suggestions.AbsoluteSize.y + assetGridContainer.AbsoluteSize.y + Constants.MAIN_VIEW_VERTICAL_PADDING
		expect(scrollContainer.AbsoluteSize.y).to.be.equal(innerHeight)

		local paddingTop = uiPadding.PaddingTop.Offset
		local paddingBottom = uiPadding.PaddingBottom.Offset
		expect(scrollingFrame.CanvasSize.Y.Offset).to.be.equal(paddingTop + innerHeight + paddingBottom)

		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6B68AD088DB14551B093F4006AE6B759">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MainView</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Central part of the toolbox

	Props:
		UDim2 position = UDim2.new(0, 0, 0, 0)
		UDim2 size = UDim2.new(1, 0, 1, 0)

		[number] idsToRender

		number maxWidth

		number categoryIndex

		Suggestions suggestions

		NetworkErrors networkErrors

		boolean isLoading

		callback selectSort()
		callback requestSearch()
		callback nextPage()
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)
local Layouter = require(Plugin.Core.Util.Layouter)

local getNetwork = require(Plugin.Core.Consumers.getNetwork)

local AssetGridContainer = require(Plugin.Core.Components.AssetGridContainer)
local InfoBanner = require(Plugin.Core.Components.InfoBanner)
local LoadingIndicator = require(Plugin.Core.Components.LoadingIndicator)
local MainViewHeader = require(Plugin.Core.Components.MainView.MainViewHeader)
local StyledScrollingFrame = require(Plugin.Core.Components.StyledScrollingFrame)
local Toast = require(Plugin.Core.Components.Toast)

local NextPageRequest = require(Plugin.Core.Networking.Requests.NextPageRequest)

local disableNetworkErrorsToasts = true

local MainView = Roact.PureComponent:extend("MainView")

function MainView:init(props)
	local networkInterface = getNetwork(self)

	self.state = {
		lowerIndexToRender = 0,
		upperIndexToRender = 0,
		assetIds = {},
	}

	self.headerHeight = 0
	self.containerWidth = 0
	self.scrollingFrameRef = Roact.createRef()

	self.onScroll = function()
		local scrollingFrame = self.scrollingFrameRef.current
		local canvasY = scrollingFrame.CanvasPosition.Y
		local windowHeight = scrollingFrame.AbsoluteWindowSize.Y
		local canvasHeight = scrollingFrame.CanvasSize.Y.Offset

		-- Where the bottom of the scrolling frame is relative to canvas size
		local bottom = canvasY + windowHeight
		local dist = canvasHeight - bottom

		if dist < Constants.DIST_FROM_BOTTOM_BEFORE_NEXT_PAGE then
			self.requestNextPage()
		end

		self:calculateRenderBounds()
	end

	self.requestNextPage = function()
		self.props.nextPage(networkInterface)
	end
end

function MainView.getDerivedStateFromProps(nextProps, lastState)
	local lowerBound = lastState.lowerIndexToRender or 0
	local upperBound = lastState.upperIndexToRender or 0

	local assetIds = Layouter.sliceAssetsFromBounds(nextProps.idsToRender or { }, lowerBound, upperBound)

	return {
		assetIds = assetIds,
		lowerIndexToRender = lowerBound,
		upperIndexToRender = upperBound,
	}
end

function MainView:didMount()
	self.scrollingFrameRef.current:GetPropertyChangedSignal("AbsoluteSize"):connect(function()
		self:calculateRenderBounds()
	end)
	self:calculateRenderBounds()
end

function MainView:calculateRenderBounds()
	local lowerBound, upperBound = Layouter.calculateRenderBoundsForScrollingFrame(self.scrollingFrameRef.current,
		self.containerWidth, self.headerHeight)

	-- If either bound has changed then recalculate the assets
	if lowerBound ~= self.state.lowerIndexToRender or upperBound ~= self.state.upperIndexToRender then
		local assetIds = Layouter.sliceAssetsFromBounds(self.props.idsToRender or {}, lowerBound, upperBound)

		self:setState({
			assetIds = assetIds,
			lowerIndexToRender = lowerBound,
			upperIndexToRender = upperBound,
		})
	end
end

function MainView:didUpdate(prevProps, prevState)
	-- Check if the toolbox has empty space
	-- If there is then request the next page
	local spaceToDisplay = self.state.upperIndexToRender - self.state.lowerIndexToRender
	local displayed = #self.state.assetIds

	if displayed < spaceToDisplay and displayed ~= 0 then
		self.requestNextPage()
	end
end

function MainView:render()
	local props = self.props
	local state = self.state

	local position = props.Position or UDim2.new(0, 0, 0, 0)
	local size = props.Size or UDim2.new(1, 0, 1, 0)

	local categoryIndex = props.categoryIndex or 0
	local suggestions = props.suggestions or {}
	local searchTerm = props.searchTerm or ""

	local isLoading = props.isLoading or false

	local maxWidth = props.maxWidth or 0

	local networkErrors = props.networkErrors or {}
	local networkError = networkErrors[#networkErrors]

	-- Need to calculate height for both rendered assets and all assets
	local idsToRender = props.idsToRender or {}
	local assetIds = state.assetIds or {}

	local assetCount = #assetIds
	local allAssetCount = #idsToRender

	local lowerIndexToRender = state.lowerIndexToRender or 0

	local containerWidth = maxWidth - (2 * Constants.MAIN_VIEW_PADDING)
		- Constants.SCROLLBAR_BACKGROUND_THICKNESS - Constants.SCROLLBAR_PADDING

	-- Add a bit extra to the container so we can see the details of the assets on the last row
	local gridContainerHeight = Layouter.calculateAssetsHeight(assetCount, containerWidth)
		+ Constants.ASSET_OUTLINE_EXTRA_HEIGHT
	local allAssetsHeight = Layouter.calculateAssetsHeight(allAssetCount, containerWidth)
		+ Constants.ASSET_OUTLINE_EXTRA_HEIGHT

	local headerHeight, headerToBodyPadding = Layouter.calculateMainViewHeaderHeight(categoryIndex, searchTerm,
		suggestions, containerWidth)

	local innerHeight = headerHeight + gridContainerHeight + headerToBodyPadding
	local fullInnerHeight = headerHeight + allAssetsHeight + headerToBodyPadding
	local canvasHeight = fullInnerHeight + (2 * Constants.MAIN_VIEW_PADDING)

	local hasResults = assetCount > 0
	local showInfoBanner = not hasResults and not isLoading

	-- Need to shift the position of AssetGridContainer depending on how many rows we've cut off the start
	local assetsPerRow = Layouter.getAssetsPerRow(containerWidth)
	local assetHeight = Layouter.getAssetCellHeightWithPadding()
	local gridContainerOffset = math.max(math.floor(lowerIndexToRender / assetsPerRow) * assetHeight, 0)

	self.containerWidth = containerWidth
	self.headerHeight = headerHeight

	return Roact.createElement("Frame", {
		Position = position,
		Size = size,
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
	}, {
		ScrollingFrame = Roact.createElement(StyledScrollingFrame, {
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),
			CanvasSize = UDim2.new(0, 0, 0, canvasHeight),
			ZIndex = 1,
			Visible = not showInfoBanner,

			[Roact.Ref] = self.scrollingFrameRef,
			onScroll = self.onScroll,
		}, {
			UIPadding = Roact.createElement("UIPadding", {
				PaddingBottom = UDim.new(0, Constants.MAIN_VIEW_PADDING),
				PaddingLeft = UDim.new(0, Constants.MAIN_VIEW_PADDING),
				PaddingRight = UDim.new(0, Constants.MAIN_VIEW_PADDING),
				PaddingTop = UDim.new(0, Constants.MAIN_VIEW_PADDING),
			}),

			Container = Roact.createElement("Frame", {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, containerWidth, 0, innerHeight),
				BackgroundTransparency = 1,
			}, {
				Header = Roact.createElement(MainViewHeader, {
					suggestions = suggestions,
					containerWidth = containerWidth,
				}),

				AssetGridContainer = Roact.createElement(AssetGridContainer, {
					Position = UDim2.new(0, 0, 0, headerHeight + headerToBodyPadding + gridContainerOffset),
					Size = UDim2.new(1, 0, 0, gridContainerHeight),

					assetIds = assetIds,

					categoryIndex = categoryIndex,

					ZIndex = 1,
				}),
			}),
		}),

		InfoBanner = showInfoBanner and Roact.createElement(InfoBanner, {
			Position = UDim2.new(0, 0, 0, 32),
			Text = "No results found",
			ZIndex = 2,
		}),

		LoadingIndicator = isLoading and Roact.createElement(LoadingIndicator, {
			AnchorPoint = Vector2.new(0.5, 1),
			Position = UDim2.new(0.5, 0, 1, -16),
			ZIndex = 3,
		}),

		-- TODO CLIDEVSRVS-1591: Temporarily disable until finished
		NetworkError = (not disableNetworkErrorsToasts) and networkError and Roact.createElement(Toast, {
			Text = ("Network Error: %s"):format(networkError and networkError.responseBody or "")
		}),
	})
end

local function mapStateToProps(state, props)
	state = state or {}

	local assets = state.assets or {}
	local pageInfo = state.pageInfo or {}

	return {
		idsToRender = assets.idsToRender or {},

		isLoading = assets.isLoading or false,

		networkErrors = state.networkErrors or {},

		categories = pageInfo.categories or {},
		categoryIndex = pageInfo.categoryIndex or 1,

		searchTerm = pageInfo.searchTerm or "",
	}
end

local function mapDispatchToProps(dispatch)
	return {
		nextPage = function(networkInterface)
			dispatch(NextPageRequest(networkInterface))
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(MainView)
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD48FB0242D9544239898AC2193CA6EFB">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MainViewHeader.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local MainViewHeader = require(Plugin.Core.Components.MainView.MainViewHeader)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			MainViewHeader = Roact.createElement(MainViewHeader),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXCCE95543A5CE4E46892947AA46C7CD8A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LoadingIndicator</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Loading indicator

	Props:
		Vector2 AnchorPoint = Vector2.new(0, 0)
		UDim2 Position = UDim2.new(0, 0, 0, 0)
		UDim2 Size = UDim2.new(0, 92, 0, 24)
		number ZIndex = 0
		boolean Visible = true
		number count = 3
		number gapRatio = 1.5
		number endRatio = 0.25
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local RunService = game:GetService("RunService")

local animationCallbacks = {}

RunService.RenderStepped:connect(function(deltaTime)
	for callback, _ in pairs(animationCallbacks) do
		callback(deltaTime)
	end
end)

local LoadingIndicator = Roact.PureComponent:extend("LoadingIndicator")

local animationSpeed = 5
local defaultBlockCount = 3

function LoadingIndicator:init()
	self.state = {
		animationTime = math.pi / 2,
		sinTime = 1,
		direction = 1,
		index = 1,
	}
end

function LoadingIndicator:didMount()
	self.callback = function(deltaTime)
		self:updateAnimation(deltaTime)
	end
	animationCallbacks[self.callback] = true
end

function LoadingIndicator:willUnmount()
	animationCallbacks[self.callback] = nil
end

function LoadingIndicator:updateAnimation(deltaTime)
	self:setState(function(prevState, props)
		local newAnimationTime = prevState.animationTime + deltaTime
		local newSinTime = math.sin(newAnimationTime * animationSpeed)

		local direction = prevState.direction
		local newDirection = direction
		local newIndex = prevState.index

		-- If sin has changed sign, move to the next block
		if (direction > 0 and newSinTime < 0) or (direction < 0 and newSinTime > 0) then
			newDirection = -direction
			newIndex = newIndex + 1

			if newIndex > (self.props.count or defaultBlockCount) then
				newIndex = 1
			end
		end

		return {
			animationTime = newAnimationTime,
			sinTime = newSinTime,
			direction = newDirection,
			index = newIndex,
		}
	end)
end

function LoadingIndicator:render()
	return withTheme(function(theme)
		local props = self.props
		local state = self.state

		local loadingIndicatorTheme = theme.loadingIndicator

		local baseColor = loadingIndicatorTheme.baseColor
		local endColor = loadingIndicatorTheme.endColor

		local anchorPoint = props.AnchorPoint or Vector2.new(0, 0)
		local position = props.Position or UDim2.new(0, 0, 0, 0)
		local size = props.Size or UDim2.new(0, 92, 0, 24)
		local zindex = props.ZIndex or 0
		local visible = (props.Visible ~= nil and props.Visible) or (props.Visible == nil)

		local blockCount = props.count or defaultBlockCount

		local gapBetweenBlockRatio = props.gapRatio or 1.5
		local endRatio = props.endRatio or 0.25

		local blockWidth = 1 / (blockCount + (blockCount * gapBetweenBlockRatio) - gapBetweenBlockRatio + (2 * endRatio))
		local gapWidth = blockWidth * gapBetweenBlockRatio

		local smallHeight = 0.6

		local children = {
			UIListLayout = Roact.createElement("UIListLayout", {
				SortOrder = Enum.SortOrder.LayoutOrder,
				FillDirection = Enum.FillDirection.Horizontal,
				Padding = UDim.new(gapWidth, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),
		}

		local sinTime = math.abs(state.sinTime)
		local index = state.index

		for i = 1, blockCount, 1 do
			local height = i == index and smallHeight + ((1 - smallHeight) * sinTime) or smallHeight

			local color = i == index and baseColor:lerp(endColor, sinTime) or baseColor

			children["Frame" .. i] = Roact.createElement("Frame", {
				Size = UDim2.new(blockWidth, 0, height, 0),
				LayoutOrder = i,
				BorderSizePixel = 0,
				BackgroundColor3 = color,
			})
		end

		return Roact.createElement("Frame", {
			AnchorPoint = anchorPoint,
			Position = position,
			Size = size,
			ZIndex = zindex,
			BorderSizePixel = 0,
			Visible = visible,
			BackgroundTransparency = 1,
		}, children)
	end)
end

return LoadingIndicator
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX77DEB76C52C04CE598EC2090CC5A8D03">
					<Properties>
						<string name="Name">Suggestions</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1EF06333704348D7A230D032E030D0AF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Suggestions.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local Suggestion = require(Plugin.Core.Types.Suggestion)

	local Suggestions = require(Plugin.Core.Components.Suggestions.Suggestions)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			Suggestions = Roact.createElement(Suggestions, {
				initialText = "Initial text",
				suggestions = Suggestion.SUGGESTIONS,
				maxWidth = 100,
			}),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX42DFF9F31A9142969722176A27177E00">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SuggestionsLabel</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local function SuggestionsLabel(props)
	return withTheme(function(theme)
		local text = props.Text or ""
		local textWidth = Constants.getTextSize(text).x

		local suggestionsTheme = theme.suggestionsComponent

		return Roact.createElement("TextLabel", {
			BackgroundTransparency = 1,
			Size = UDim2.new(0, textWidth, 1, 0),
			Text = text,
			Font = Constants.FONT,
			TextSize = Constants.SUGGESTIONS_FONT_SIZE,
			TextColor3 = suggestionsTheme.labelTextColor,
			LayoutOrder = 0,
			TextXAlignment = Enum.TextXAlignment.Left,
		})
	end)
end

return SuggestionsLabel
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX452E0CAC334943CE8E1CEECD30264B2B">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Suggestions</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	The suggestions at the top of the toolbox, "Try searching for: NPC Vehicle etc."

	Props:
		UDim2 Position = UDim2.new(0, 0, 0, 0)
		UDim2 Size = UDim2.new(1, 0, 1, 0)
		number ZIndex
		number maxWidth
		Suggestions suggestions

		callback onSuggestionSelected(number index)
]]

local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Layouter = require(Plugin.Core.Util.Layouter)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local function Suggestions(props)
	return withTheme(function(theme)
		local position = props.Position or UDim2.new(0, 0, 0, 0)
		local size = props.Size or UDim2.new(1, 0, 1, 0)
		local zindex = props.ZIndex or 1

		local initialText = props.initialText
		local suggestions = props.suggestions
		local maxWidth = props.maxWidth
		local onSuggestionSelected = props.onSuggestionSelected

		local rows = Layouter.layoutSuggestions(initialText,
			suggestions,
			maxWidth,
			onSuggestionSelected)

		return Roact.createElement("Frame", {
			Position = position,
			Size = size,
			ZIndex = zindex,
			BackgroundTransparency = 1,
		}, rows)
	end)
end

return Suggestions
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA91669DA08A84EAC9D526B8134F8B909">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SuggestionsLabel.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local SuggestionsLabel = require(Plugin.Core.Components.Suggestions.SuggestionsLabel)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			SuggestionsLabel = Roact.createElement(SuggestionsLabel)
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0E8EA0CCD7204DB7909BC58E28BFE804">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SuggestionsButton</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local SuggestionsButton = Roact.PureComponent:extend("SuggestionsButton")

function SuggestionsButton:init(props)
	self.state = {
		isHovered = false,
	}

	self.onMouseEnter = function(rbx, x, y)
		MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		self:setState({
			isHovered = true,
		})
	end

	self.onMouseLeave = function(rbx, x, y)
		MouseManager:clearIcons()
		self:setState({
			isHovered = false,
		})
	end

	self.onInputChanged = function(rbx, input)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then
			MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
			self:setState({
				isHovered = true,
			})
		end
	end

	self.onActivated = function(rbx, input)
		MouseManager:clearIcons()
		self.props.onClicked(self.props.LayoutOrder)
	end
end

function SuggestionsButton:render()
	return withTheme(function(theme)
		local props = self.props
		local state = self.state

		local isHovered = state.isHovered

		local text = props.Text or ""
		local textWidth = Constants.getTextSize(text).x
		local layoutOrder = props.LayoutOrder or 0

		local suggestionsTheme = theme.suggestionsComponent

		local textColor = isHovered and suggestionsTheme.textHoveredColor or suggestionsTheme.textColor

		return Roact.createElement("TextButton", {
			BackgroundTransparency = 1,
			Size = UDim2.new(0, textWidth, 1, 0),
			Text = text,
			Font = Constants.FONT,
			TextSize = Constants.SUGGESTIONS_FONT_SIZE,

			TextColor3 = textColor,

			LayoutOrder = layoutOrder,
			TextXAlignment = Enum.TextXAlignment.Left,

			[Roact.Event.MouseEnter] = self.onMouseEnter,
			[Roact.Event.MouseLeave] = self.onMouseLeave,
			[Roact.Event.InputChanged] = self.onInputChanged,
			[Roact.Event.Activated] = self.onActivated,
		}, {
			Underline = isHovered and Roact.createElement("Frame", {
				BorderSizePixel = 0,
				Position = UDim2.new(0, 0, 0.5, (Constants.SUGGESTIONS_FONT_SIZE / 2) - 1),
				Size = UDim2.new(1, 0, 0, 1),
				BackgroundColor3 = suggestionsTheme.underlineColor,
			})
		})
	end)
end

return SuggestionsButton
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC1FD4810933046798BDED58640C6C75C">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SuggestionsButton.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local SuggestionsButton = require(Plugin.Core.Components.Suggestions.SuggestionsButton)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			SuggestionsButton = Roact.createElement(SuggestionsButton)
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXD5ED19D99FE54BF8ADEDB697F1C4A552">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DropShadow.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local DropShadow = require(Plugin.Core.Components.DropShadow)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			DropShadow = Roact.createElement(DropShadow),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX746427ACB5594478BD6BE5C74D32702B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InfoBanner</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Info banner

	Props:
		UDim2 Position = UDim2.new(0, 0, 0, 0)
		UDim2 Size = UDim2.new(1, 0, 0, 42)
		number ZIndex = 0
		boolean Visible = true
		string Text = ""
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local function InfoBanner(props)
	return withTheme(function(theme)
		local fontSize = Constants.FONT_SIZE_LARGE
		local height = fontSize + (2 * Constants.INFO_BANNER_PADDING)

		local position = props.Position or UDim2.new(0, 0, 0, 0)
		local size = props.Size or UDim2.new(1, 0, 0, height)
		local zindex = props.ZIndex or 0
		local visible = (props.Visible ~= nil and props.Visible) or (props.Visible == nil)
		local text = props.Text or ""

		local infoBannerTheme = theme.infoBanner

		return Roact.createElement("TextLabel", {
			Position = position,
			Size = size,
			BorderSizePixel = 0,
			BackgroundColor3 = infoBannerTheme.backgroundColor,
			ZIndex = zindex,
			Visible = visible,
			Text = text,
			TextColor3 = infoBannerTheme.textColor,
			Font = Constants.FONT,
			TextSize = fontSize,
			TextXAlignment = Enum.TextXAlignment.Center,
			TextYAlignment = Enum.TextYAlignment.Center,
			TextWrapped = true,
			ClipsDescendants = true,
		})
	end)
end

return InfoBanner
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX93B599B89C6341AE87DCE572CD364B2E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SoundPreviewComponent</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Urls = require(Plugin.Core.Util.Urls)

local getPlugin = require(Plugin.Core.Consumers.getPlugin)

local StopPreviewSound = require(Plugin.Core.Actions.StopPreviewSound)

local SoundPreviewComponent = Roact.Component:extend("SoundPreviewComponent")

function SoundPreviewComponent:init(props)
	self.ref = Roact.createRef()

	local plugin = getPlugin(self)

	self.updateSound = function()
		local soundObj = self.ref.current
		local props = self.props
		local currentSoundId = props.currentSoundId
		local isPlaying = props.isPlaying

		if not soundObj then return end

		local lastSoundId = self.lastSoundId

		if currentSoundId == 0 or not isPlaying then
			if soundObj.isPlaying then
				soundObj.Playing = false

				-- I don't know why even pausing the sound will casue c++ the request the soundId
				plugin:PauseSound(soundObj)
			end
		else
			if currentSoundId == lastSoundId then
				soundObj.Playing = true
				plugin:ResumeSound(soundObj)
			else
				soundObj.Playing = true
				soundObj.SoundId = Urls.constructAssetIdString(currentSoundId)
				plugin:PlaySound(soundObj)

				self.lastSoundId = currentSoundId
			end
		end
	end

	self.onSoundEnded = function(soundId)
		self.props.stopASound()
	end
end

function SoundPreviewComponent:render()
	return Roact.createElement("Sound", {
		[Roact.Ref] = self.ref,
		[Roact.Event.Ended] = self.onSoundEnded
	})
end

function SoundPreviewComponent:didUpdate()
	self.updateSound()
end

local function mapStateToProps(state, props)
	state = state or {}

	local sound = state.sound or {}

	return {
		-- Sound Playing
		currentSoundId = sound.currentSoundId or 0,
		isPlaying = sound.isPlaying or false,
	}
end

local function mapDispatchToProps(dispatch)
	return {
		stopASound = function()
			dispatch(StopPreviewSound())
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(SoundPreviewComponent)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAA90E385DF2E4464B46DAC861A28B6AD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundFrame.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local RoundFrame = require(Plugin.Core.Components.RoundFrame)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(RoundFrame)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA6D7782EED034CF0BA1D79EF2F4CD5D7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AssetGridContainer.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local AssetGridContainer = require(Plugin.Core.Components.AssetGridContainer)

	--[[local function tableLength(tbl)
		local i = 0
		for _ in pairs(tbl) do
			i = i + 1
		end
		return i
	end]]

	local function createTestAssetGridContainer(name, container, idToAssetMap)
		idToAssetMap = idToAssetMap or {}
		local assetIds = { }
		for id, _ in pairs(idToAssetMap) do
			assetIds[#assetIds + 1] = id
		end

		local element = Roact.createElement(MockWrapper, {}, {
			AssetGridContainer = Roact.createElement(AssetGridContainer, {
				idToAssetMap = idToAssetMap,
				assetIds = assetIds,
			}),
		})

		return Roact.mount(element, container or nil, name or "")
	end

	it("should create and destroy without errors", function()
		local instance = createTestAssetGridContainer()
		Roact.unmount(instance)
	end)

	-- TODO CLIDEVSRVS-1687: This test depends on idToAssetMap being correct in the store
	--[[
	it("should have a grid layout and assets with correct names", function()
		local idToAssetMap = {
			[12355] = {
				Asset = {
					Id = 12345,
					IsEndorsed = false,
					Name = "Asset 1!",
				},
				Creator = {
					Name = "Foo",
				},
				Voting = {
					UpVotes = 150,
					DownVotes = 10,
				},
			},
			[67890] = {
				Asset = {
					Id = 67890,
					IsEndorsed = false,
					Name = "Asset 2",
				},
				Creator = {
					Name = "Foo",
				},
				Voting = {
					UpVotes = 150,
					DownVotes = 10,
				},
			},
			[13579] = {
				Asset = {
					Id = 13579,
					IsEndorsed = false,
					Name = "Asset 3",
				},
				Creator = {
					Name = "Foo",
				},
				Voting = {
					UpVotes = 150,
					DownVotes = 10,
				},
			}
		}

		local container = workspace.ToolboxTestsTarget
		local instance = createTestAssetGridContainer("AssetGridContainer", container, idToAssetMap)

		local assetGridContainer = container.AssetGridContainer

		expect(assetGridContainer.UIGridLayout).to.be.ok()

		for _, asset in pairs(idToAssetMap) do
			expect(assetGridContainer[asset.Asset.Id]).to.be.ok()
		end

		-- Add one for the UIGridLayout
		expect(#assetGridContainer:GetChildren()).to.equal(tableLength(idToAssetMap) + 1)

		Roact.unmount(instance)
	end)
	]]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9D4E5682DDFD491285739022A99C7CA6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Toolbox</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	The toolbox itself

	Props (many of these come from the store):
		number initialWidth = 0
		number initialSelectedBackgroundIndex = 1
		number initialSelectedCategoryIndex = 1
		string initialSearchTerm = ""
		number initialSelectedSortIndex = 1

		Backgrounds backgrounds
		Categories categories
		Suggestions suggestions
		Sorts sorts

		callback loadManageableGroups()
		callback updatePageInfo()
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Constants = require(Plugin.Core.Util.Constants)

local getNetwork = require(Plugin.Core.Consumers.getNetwork)
local getSettings = require(Plugin.Core.Consumers.getSettings)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local Footer = require(Plugin.Core.Components.Footer.Footer)
local Header = require(Plugin.Core.Components.Header)
local MainView = require(Plugin.Core.Components.MainView.MainView)
local SoundPreviewComponent = require(Plugin.Core.Components.SoundPreviewComponent)

local GetManageableGroupsRequest = require(Plugin.Core.Networking.Requests.GetManageableGroupsRequest)
local UpdatePageInfoAndSendRequest = require(Plugin.Core.Networking.Requests.UpdatePageInfoAndSendRequest)

local Toolbox = Roact.PureComponent:extend("Toolbox")

function Toolbox:handleInitialSettings()
	local networkInterface = getNetwork(self)
	local settings = getSettings(self)
	local initialSettings = settings:loadInitialSettings()

	-- Load the initial values and make sure they're safe
	local initialSelectedCategoryIndex = initialSettings.categoryIndex or 1
	if initialSelectedCategoryIndex < 1 or initialSelectedCategoryIndex > #self.props.categories then
		initialSelectedCategoryIndex = 1
	end

	local initialSearchTerm = initialSettings.searchTerm or ""

	local initialSelectedSortIndex = initialSettings.sortIndex or 1
	if initialSelectedSortIndex < 1 or initialSelectedSortIndex > #self.props.sorts then
		initialSelectedSortIndex = 1
	end

	local initialSelectedBackgroundIndex = initialSettings.backgroundIndex or 1

	-- Set the initial page info for the toolbox
	-- This will trigger a web request to load the first round of assets
	self.props.updatePageInfo(networkInterface, settings, {
		categoryIndex = initialSelectedCategoryIndex,
		searchTerm = initialSearchTerm,
		sortIndex = initialSelectedSortIndex,
		groupIndex = 0,
		page = 1,
		pageSize = Constants.GET_ITEMS_PAGE_SIZE,
		selectedBackgroundIndex = initialSelectedBackgroundIndex,
	})
end

function Toolbox:init(props)
	self.state = {
		toolboxWidth = math.max(props.initialWidth or 0, Constants.TOOLBOX_MIN_WIDTH),
	}

	self.onAbsoluteSizeChange = function(rbx)
		local toolboxWidth = math.max(rbx.AbsoluteSize.x, Constants.TOOLBOX_MIN_WIDTH)
		if self.state.toolboxWidth ~= toolboxWidth then
			self:setState({
				toolboxWidth = toolboxWidth,
			})
		end
	end

	self:handleInitialSettings()
end

function Toolbox:didMount()
	-- Once the roact components have loaded, load the groups
	self.props.loadManageableGroups(getNetwork(self))
end

function Toolbox:render()
	return withTheme(function(theme)
		local props = self.props
		local state = self.state

		local toolboxWidth = state.toolboxWidth

		local backgrounds = props.backgrounds
		local suggestions = props.suggestions or {}

		local toolboxTheme = theme.toolbox

		return Roact.createElement("Frame", {
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 1, 0),

			BorderSizePixel = 0,
			BackgroundColor3 = toolboxTheme.backgroundColor,

			[Roact.Change.AbsoluteSize] = self.onAbsoluteSizeChange,
		}, {
			Header = Roact.createElement(Header, {
				maxWidth = toolboxWidth,
			}),

			MainView = Roact.createElement(MainView, {
				Position = UDim2.new(0, 0, 0, Constants.HEADER_HEIGHT + 1),
				Size = UDim2.new(1, 0, 1, -(Constants.HEADER_HEIGHT + Constants.FOOTER_HEIGHT + 2)),

				maxWidth = toolboxWidth,
				suggestions = suggestions,
			}),

			Footer = Roact.createElement(Footer, {
				backgrounds = backgrounds,
			}),

			AudioPreview = Roact.createElement(SoundPreviewComponent)
		})
	end)
end

local function mapStateToProps(state, props)
	state = state or {}

	local pageInfo = state.pageInfo or {}

	return {
		categories = pageInfo.categories or {},
		sorts = pageInfo.sorts or {},
	}
end

local function mapDispatchToProps(dispatch)
	return {
		loadManageableGroups = function(networkInterface)
			dispatch(GetManageableGroupsRequest(networkInterface))
		end,

		updatePageInfo = function(networkInterface, settings, newPageInfo)
			dispatch(UpdatePageInfoAndSendRequest(networkInterface, settings, newPageInfo))
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(Toolbox)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6D0F454F540A4601847656BA7E0B3149">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DraggableButton</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Has callbacks for clicking and drag starting.

	Props:
		callback onDragStart()
		callback onClick()

	Other props forwarded onto the inner ImageButton
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Immutable = require(Plugin.Core.Util.Immutable)

local DraggableButton = Roact.PureComponent:extend("DraggableButton")

-- How far the user has to move their mouse before we start a drag operation
-- versus click-to-insert
local MAX_DIST_BEFORE_DRAG = 4

function DraggableButton:init(props)
	-- Is the component currently clicked and where was it clicked
	self.clicked = false
	self.clickPosition = Vector2.new(0, 0)

	-- When the user clicks, we wait for them to release the mouse before
	-- firing a click event. If they move the mouse too much whilst clicked
	-- then we start a drag instead.
	self.willFireClickOnMouseUp = false

	if DebugFlags.shouldDebugWarnings() then
		if props[Roact.Event.MouseButton1Down] then
			warn("MouseButton1Down should not be defined on DraggableButton. Use onMouseDown instead.")
		end
		if props[Roact.Event.MouseMoved] then
			warn("MouseButton1Down should not be defined on DraggableButton. Use onMouseMoved instead.")
		end
		if props[Roact.Event.MouseButton1Up] then
			warn("MouseButton1Up should not be defined on DraggableButton. Use onMouseUp instead.")
		end
	end

	self.onMouseButton1Down = function(rbx, x, y)
		self.clicked = true
		self.clickPosition = Vector2.new(x, y)
		self.willFireClickOnMouseUp = true

		if props.onMouseDown then
			props.onMouseDown(rbx, x, y)
		end
	end

	self.onMouseMoved = function(rbx, x, y)
		if self.clicked and self.willFireClickOnMouseUp then
			local movedDist = (Vector2.new(x, y) - self.clickPosition).magnitude

			if movedDist > MAX_DIST_BEFORE_DRAG then
				self.willFireClickOnMouseUp = false

				if props.onDragStart then
					props.onDragStart(rbx, x, y)
				end
			end
		end

		if props.onMouseMoved then
			props.onMouseMoved(rbx, x, y)
		end
	end

	self.onMouseButton1Up = function(rbx, x, y)
		self.clicked = false
		self.clickPosition = Vector2.new(x, y)

		-- The mouse was down and not moved enough to start a drag
		-- So fire a click instead
		if self.willFireClickOnMouseUp then
			self.willFireClickOnMouseUp = false
			if props.onClick then
				props.onClick(rbx, x, y)
			end
		end

		if props.onMouseUp then
			props.onMouseUp(rbx, x, y)
		end
	end
end

function DraggableButton:render()
	local props = Immutable.JoinDictionaries(self.props, {
		[Roact.Event.MouseButton1Down] = self.onMouseButton1Down,
		[Roact.Event.MouseMoved] = self.onMouseMoved,
		[Roact.Event.MouseButton1Up] = self.onMouseButton1Up,
	})
	props = Immutable.RemoveFromDictionary(props, "onDragStart", "onClick", "onMouseDown", "onMouseMoved", "onMouseUp")

	return Roact.createElement("ImageButton", props)
end

return DraggableButton
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEE434A52114442EABA6E2DFA8A06A448">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Header</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Header of the toolbox

	Props:
		Categories categories
		number categoryIndex
		string searchTerm
		Groups groups
		number groupIndex

		number maxWidth

		callback onCategorySelected(number index)
		callback onSearchRequested(string searchTerm)
		callback onGroupSelected()
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local RoactRodux = require(CorePackages.RoactRodux)

local Analytics = require(Plugin.Core.Util.Analytics.Analytics)
local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local PageInfoHelper = require(Plugin.Core.Util.PageInfoHelper)

local Category = require(Plugin.Core.Types.Category)

local getNetwork = require(Plugin.Core.Consumers.getNetwork)
local getSettings = require(Plugin.Core.Consumers.getSettings)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local DropdownMenu = require(Plugin.Core.Components.DropdownMenu)
local SearchBar = require(Plugin.Core.Components.SearchBar.SearchBar)

local RequestSearchRequest = require(Plugin.Core.Networking.Requests.RequestSearchRequest)
local SelectCategoryRequest = require(Plugin.Core.Networking.Requests.SelectCategoryRequest)
local SelectGroupRequest = require(Plugin.Core.Networking.Requests.SelectGroupRequest)

local Header = Roact.PureComponent:extend("Header")

function Header:init()
	local networkInterface = getNetwork(self)
	local settings = getSettings(self)

	self.onCategorySelected = function(index)
		if self.props.categoryIndex ~= index then
			Analytics.onCategorySelected(
				PageInfoHelper.getCategory(self.props.categories, self.props.categoryIndex),
				PageInfoHelper.getCategory(self.props.categories, index)
			)

			self.props.selectCategory(networkInterface, settings, index)
		end
	end

	self.onGroupSelected = function(index)
		if self.props.groupIndex ~= index then
			self.props.selectGroup(networkInterface, index)
		end
	end

	self.onSearchRequested = function(searchTerm)
		if type(searchTerm) ~= "string" and DebugFlags.shouldDebugWarnings() then
			warn(("Toolbox onSearchRequested searchTerm = %s is not a string"):format(tostring(searchTerm)))
		end

		Analytics.onTermSearched(PageInfoHelper.getCategory(self.props.categories, self.props.categoryIndex), searchTerm)

		self.props.requestSearch(networkInterface, settings, searchTerm)
	end
end

function Header:render()
	return withTheme(function(theme)
		local props = self.props

		local categories = props.categories
		local categoryIndex = props.categoryIndex or 0
		local onCategorySelected = self.onCategorySelected

		local searchTerm = props.searchTerm
		local onSearchRequested = self.onSearchRequested

		local groups = props.groups
		local groupIndex = props.groupIndex
		local onGroupSelected = self.onGroupSelected

		local maxWidth = props.maxWidth or 0
		local searchBarWidth = math.max(100, maxWidth
				- (2 * Constants.HEADER_OUTER_PADDING)
				- Constants.HEADER_CATEGORY_DROPDOWN_WIDTH
				- Constants.HEADER_INNER_PADDING)

		local isGroupCategory = Category.categoryIsGroupAsset(props.categoryIndex)

		local headerTheme = theme.header

		return Roact.createElement("ImageButton", {
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 0, Constants.HEADER_HEIGHT),
			BackgroundColor3 = headerTheme.backgroundColor,
			BorderColor3 = headerTheme.borderColor,
			ZIndex = 2,
			AutoButtonColor = false,
		},{
			UIPadding = Roact.createElement("UIPadding", {
				PaddingBottom = UDim.new(0, Constants.HEADER_OUTER_PADDING),
				PaddingLeft = UDim.new(0, Constants.HEADER_OUTER_PADDING),
				PaddingRight = UDim.new(0, Constants.HEADER_OUTER_PADDING),
				PaddingTop = UDim.new(0, Constants.HEADER_OUTER_PADDING),
			}),

			UIListLayout = Roact.createElement("UIListLayout", {
				FillDirection = Enum.FillDirection.Horizontal,
				SortOrder = Enum.SortOrder.LayoutOrder,
				Padding = UDim.new(0, Constants.HEADER_INNER_PADDING),
			}),

			CategoryMenu = Roact.createElement(DropdownMenu, {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, Constants.HEADER_CATEGORY_DROPDOWN_WIDTH, 1, 0),
				LayoutOrder = 0,
				visibleDropDownCount = 8,
				selectedDropDownIndex = categoryIndex,

				items = categories,
				onItemClicked = onCategorySelected,
			}),

			SearchBar = not isGroupCategory and Roact.createElement(SearchBar, {
				width = searchBarWidth,
				LayoutOrder = 1,

				searchTerm = searchTerm,
				onSearchRequested = onSearchRequested,
			}),

			GroupMenu = isGroupCategory and Roact.createElement(DropdownMenu, {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, searchBarWidth, 1, 0),
				LayoutOrder = 1,
				visibleDropDownCount = 8,
				selectedDropDownIndex = groupIndex,

				items = groups,
				onItemClicked = onGroupSelected,
			}),
		})
	end)
end

local function mapStateToProps(state, props)
	state = state or {}

	local pageInfo = state.pageInfo or {}

	return {
		categories = pageInfo.categories or {},
		categoryIndex = pageInfo.categoryIndex or 1,
		searchTerm = pageInfo.searchTerm or "",
		groups = pageInfo.groups or {},
		groupIndex = pageInfo.groupIndex or 0,
	}
end

local function mapDispatchToProps(dispatch)
	return {
		selectCategory = function(networkInterface, settings, categoryIndex)
			dispatch(SelectCategoryRequest(networkInterface, settings, categoryIndex))
		end,

		selectGroup = function(networkInterface, groupIndex)
			dispatch(SelectGroupRequest(networkInterface, groupIndex))
		end,

		requestSearch = function(networkInterface, settings, searchTerm)
			dispatch(RequestSearchRequest(networkInterface, settings, searchTerm))
		end,
	}
end

return RoactRodux.UNSTABLE_connect2(mapStateToProps, mapDispatchToProps)(Header)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE0ECFF9E15DD4FDD852FFFBC4BFD8B9E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DropdownMenu</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A drop down menu

	Props:
		UDim2 Position
		UDim2 Size
		number LayoutOrder = 0
		number selectedDropDownIndex
		number visibleDropDownCount = 5
		number rowHeight = 24
		[string] items

		callback onItemClicked(number index)
]]

local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Images = require(Plugin.Core.Util.Images)
local MouseManager = require(Plugin.Core.Util.MouseManager)

local getModal = require(Plugin.Core.Consumers.getModal)
local withModal = require(Plugin.Core.Consumers.withModal)
local withTheme = require(Plugin.Core.Consumers.withTheme)

local StyledScrollingFrame = require(Plugin.Core.Components.StyledScrollingFrame)
local RoundButton = require(Plugin.Core.Components.RoundButton)
local RoundFrame = require(Plugin.Core.Components.RoundFrame)

local DropdownMenu = Roact.PureComponent:extend("DropdownMenu")

function DropdownMenu:init(props)
	self.state = {
		isShowingDropdown = false,
		showDropDownButtonHovered = false,
		dropdownHoveredItemIndex = 0
	}

	self.currentSelectionRef = Roact.createRef()

	self.openDropdown = function()
		self:setState(function(prevState, props)
			getModal(self).onDropdownToggled(true)

			return {
				isShowingDropdown = true,
			}
		end)
	end

	self.showDropDownButtonEntered = function()
		MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
		self:setState({
			showDropDownButtonHovered = true,
		})
	end

	self.showDropDownButtonLeft = function()
		MouseManager:clearIcons()
		self:setState({
			showDropDownButtonHovered = false,
		})
	end

	self.closeDropdown = function()
		MouseManager:popIcon(Images.CURSOR_POINTING_HAND)
		MouseManager:clearIcons()

		getModal(self).onDropdownToggled(false)

		self:setState({
			isShowingDropdown = false,
		})
	end

	self.focusLost = function(rbx, input)
		if input.UserInputType == Enum.UserInputType.Focus then
			self.closeDropdown()
		end
	end
end

function DropdownMenu:render()
	return withTheme(function(theme)
		return withModal(function(modalTarget)
			local props = self.props
			local state = self.state

			local position = props.Position
			local size = props.Size
			local layoutOrder = props.LayoutOrder or 0

			local items = props.items or {}
			local length = #items
			local visibleCount = math.min(props.visibleDropDownCount or 5, length)
			local rowHeight = props.rowHeight or 24
			local selectedDropDownIndex = props.selectedDropDownIndex or 1

			if selectedDropDownIndex > #items then
				selectedDropDownIndex = 0
			end

			local onItemClicked = props.onItemClicked
			local dropdownHoveredItemIndex = state.dropdownHoveredItemIndex
			local showDropDownButtonHovered = state.showDropDownButtonHovered

			local currentSelection = self.currentSelectionRef and self.currentSelectionRef.current

			local indexInRange = selectedDropDownIndex > 0 and selectedDropDownIndex <= #items

			local currentSelectionText = "Choose one"
			if indexInRange and items[selectedDropDownIndex] and items[selectedDropDownIndex].name then
				currentSelectionText = items[selectedDropDownIndex].name
			end

			local selectedBarWidth = Constants.DROPDOWN_SELECTED_BAR
			local textInset = selectedBarWidth + Constants.DROPDOWN_TEXT_INSET
			local dropdownIconSize = Constants.DROPDOWN_ICON_SIZE
			local dropdownIconFromRight = Constants.DROPDOWN_ICON_FROM_RIGHT

			local isShowingDropdown = state.isShowingDropdown
			local hoverOrShow = isShowingDropdown or showDropDownButtonHovered

			local isDarkerTheme = theme.isDarkerTheme
			local dropdownTheme = theme.dropdownMenu
			local currentSelectionTheme = dropdownTheme.currentSelection
			local itemTheme = dropdownTheme.item

			-- Show the current selection object as blue when hovered or clicked, but only in a lighter theme
			local showCurrentSelectionActive = hoverOrShow

			local currentSelectionBorderColor = showCurrentSelectionActive and currentSelectionTheme.borderSelectedColor
				or currentSelectionTheme.borderColor
			local currentSelectionBackgroundColor = showCurrentSelectionActive and currentSelectionTheme.backgroundSelectedColor
				or currentSelectionTheme.backgroundColor
			local currentSelectionTextColor = showCurrentSelectionActive and currentSelectionTheme.textSelectedColor
				or currentSelectionTheme.textColor
			local dropdownIconColor = (isDarkerTheme or hoverOrShow) and currentSelectionTheme.iconSelectedColor
				or currentSelectionTheme.iconColor

			local dropdownFrame = {}
			if isShowingDropdown and currentSelection then
				local scrollButtons = {
					UIListLayout = Roact.createElement("UIListLayout", {
						FillDirection = Enum.FillDirection.Vertical,
						SortOrder = Enum.SortOrder.LayoutOrder
					})
				}

				for index, data in ipairs(items) do
					if not data.name and DebugFlags.shouldDebugWarnings() then
						warn(("Index %d in DropdownMenu doesn't have a 'name' member"):format(index))
					end
					-- let if error if we got incorrect data
					local itemName = data.name
					local isHovered = dropdownHoveredItemIndex == index

					scrollButtons[itemName] = Roact.createElement("ImageButton",{
						Size = UDim2.new(1, -Constants.SCROLLBAR_BACKGROUND_THICKNESS + Constants.SCROLLBAR_PADDING, 0, rowHeight),
						BackgroundColor3 = isHovered and itemTheme.backgroundSelectedColor or itemTheme.backgroundColor,
						BorderSizePixel = 0,
						LayoutOrder = index,
						ZIndex = 2,

						AutoButtonColor = false,

						[Roact.Event.MouseButton1Down] = function(rbx, x, y)
							if onItemClicked then
								onItemClicked(index)
							end
							self.closeDropdown()
						end,

						[Roact.Event.InputEnded] = self.focusLost,

						[Roact.Event.MouseEnter] = function(rbx, x, y)
							MouseManager:pushIcon(Images.CURSOR_POINTING_HAND)
							self:setState({
								dropdownHoveredItemIndex = index,
							})
						end,

						[Roact.Event.MouseLeave] = function(rbx, x, y)
							if self.state.dropdownHoveredItemIndex == index then
								MouseManager:clearIcons()
								self:setState({
									dropdownHoveredItemIndex = 0,
								})
							end
						end,
					}, {
						SelectedBar = not isDarkerTheme and Roact.createElement("Frame", {
							Size = UDim2.new(0, selectedBarWidth, 1, 0),
							BorderSizePixel = 0,
							BackgroundColor3 = dropdownTheme.item.selectedBarColor,
							Visible = isHovered,
							ZIndex = 2,
						}),

						TextLabel = Roact.createElement("TextLabel", {
							Position = UDim2.new(0, textInset, 0, 0),
							Size = UDim2.new(1, -textInset, 1, 0),
							BackgroundTransparency = 1,
							Text = itemName,
							TextColor3 = itemTheme.textColor,
							Font = Constants.FONT,
							TextSize = Constants.FONT_SIZE_MEDIUM,
							TextXAlignment = Enum.TextXAlignment.Left,
							TextYAlignment = Enum.TextYAlignment.Center,
							TextTruncate = Enum.TextTruncate.AtEnd,
							ClipsDescendants = true,
							ZIndex = 3,
						})
					})
				end

				local currentSelectionSize = currentSelection.AbsoluteSize
				local currentSelectionTopLeft = currentSelection.AbsolutePosition
				local offsetFromButton = 2

				local width = currentSelectionSize.x
				local height = visibleCount * rowHeight
				local top = currentSelectionTopLeft.y + currentSelectionSize.y + offsetFromButton
				local left = currentSelectionTopLeft.x

				-- Put the scrolling frame behind the background frame, but set
				-- the background frame to be transparent. This way we see the
				-- border on top of the scrolling frame, but not the background.
				-- If the scrolling frame was a child of the rounded frame's
				-- border then it gets rendered on top of the border. This works
				-- ok for the elements in the dropdown as you can set their
				-- background to transparent, but it doesn't work for background
				-- of the scrollbar

				dropdownFrame.StyledScrollingFrame = Roact.createElement(StyledScrollingFrame, {
					Position = UDim2.new(0, left, 0, top),
					Size = UDim2.new(0, width, 0, height),
					CanvasSize = UDim2.new(0, 0, 0, length * rowHeight),
					ZIndex = 1,
				}, scrollButtons)

				dropdownFrame.DropDownContainer = Roact.createElement(RoundFrame, {
					Position = UDim2.new(0, left, 0, top),
					Size = UDim2.new(0, width, 0, height),
					BackgroundTransparency = 1,
					ZIndex = 2,
					BorderColor3 = dropdownTheme.dropdownFrame.borderColor,
				})
			end

			return Roact.createElement("Frame", {
				Position = position,
				Size = size,
				BackgroundTransparency = 1,
				LayoutOrder = layoutOrder
			}, {
				CurrentSelection = Roact.createElement(RoundButton, {
					Position = UDim2.new(0, -1, 0, -1),
					Size = UDim2.new(1, 2, 1, 2),

					BackgroundColor3 = currentSelectionBackgroundColor,
					BorderColor3 = currentSelectionBorderColor,

					[Roact.Ref] = self.currentSelectionRef,

					[Roact.Event.MouseButton1Down] = self.openDropdown,
					[Roact.Event.MouseEnter] = self.showDropDownButtonEntered,
					[Roact.Event.MouseLeave] = self.showDropDownButtonLeft,
					[Roact.Event.InputEnded] = self.focusLost,
				}, {
					CurrentSelectionLabel = Roact.createElement("TextLabel", {
						Position = UDim2.new(0, textInset, 0, 0),
						Size = UDim2.new(1, -(textInset + dropdownIconSize + dropdownIconFromRight), 1, 0),
						BackgroundTransparency = 1,
						TextColor3 = currentSelectionTextColor,
						Text = currentSelectionText,
						Font = Constants.FONT,
						TextSize = Constants.FONT_SIZE_MEDIUM,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Center,
						ClipsDescendants = true,
						TextTruncate = Enum.TextTruncate.AtEnd,
					}),

					DropDownIcon = Roact.createElement("ImageLabel", {
						AnchorPoint = Vector2.new(1, 0.5),
						Size = UDim2.new(0, dropdownIconSize, 0, dropdownIconSize),
						Position = UDim2.new(1, -dropdownIconFromRight, 0.5, 0),
						Image = Images.ARROW_DOWN_ICON,
						ImageColor3 = dropdownIconColor,
						BackgroundTransparency = 1,
					}),
				}),

				Portal = isShowingDropdown and Roact.createElement(Roact.Portal, {
					target = modalTarget,
				}, {
					ClickEventDetectFrame = Roact.createElement("ImageButton", {
						ZIndex = 10,
						Position = UDim2.new(0, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						BackgroundTransparency = 1,
						AutoButtonColor = false,

						[Roact.Event.MouseButton1Down] = self.closeDropdown,
					}, dropdownFrame)
				})
			})
		end)
	end)
end

return DropdownMenu
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB739DAA4CB854959949013FB2802935F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundFrame</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A frame with rounded corners
	Supports different background and border colors
]]

local Plugin = script.Parent.Parent.Parent

local RoundElement = require(Plugin.Core.Components.RoundElement)

return RoundElement(false)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD3BDC8BF33EF447FA1B08B43038B4EC4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LoadingIndicator.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local CorePackages = game:GetService("CorePackages")
	local Roact = require(CorePackages.Roact)

	local MockWrapper = require(Plugin.Core.Util.MockWrapper)

	local LoadingIndicator = require(Plugin.Core.Components.LoadingIndicator)

	it("should create and destroy without errors", function()
		local element = Roact.createElement(MockWrapper, {}, {
			LoadingIndicator = Roact.createElement(LoadingIndicator),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7AC013CE93F04E95BE96A0E9B7414E9D">
				<Properties>
					<string name="Name">Consumers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC284C632C94948DA8954A0681B995FDB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">withTheme</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local ThemeConsumer = require(Plugin.Core.Consumers.ThemeConsumer)

return function(callback)
	return Roact.createElement(ThemeConsumer, {
		render = callback,
	})
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA8EDD09E3706478CAEA17D049EEAAB73">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getPlugin</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local pluginGuiKey = require(Plugin.Core.Keys.pluginGuiKey)
local pluginKey = require(Plugin.Core.Keys.pluginKey)

return function(component)
	return component._context[pluginKey], component._context[pluginGuiKey]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB32CA1709A494F61940654B83B2684C9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ModalConsumer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local getModal = require(Plugin.Core.Consumers.getModal)

local ModalConsumer = Roact.Component:extend("ModalConsumer")

-- TODO CLIDEVSRVS-1688: Improve this
local function getDataFromModalStatus(modalStatus)
	return {
		currentTooltipAssetId = modalStatus._currentTooltipAssetId,
		currentTooltipTypeId = modalStatus._currentTooltipTypeId,
		isDropdownShown = modalStatus._isDropdownShown,
	}
end

function ModalConsumer:init()
	local modalData = getModal(self)
	self.modalTarget = modalData.modalTarget
	self._modalStatus = modalData._modalStatus

	-- TODO CLIDEVSRVS-1688: Fix this
	-- Duplicating data between this and modal status
	self.state = getDataFromModalStatus(self._modalStatus)
end

function ModalConsumer:render()
	return self.props.render(self.modalTarget, self._modalStatus)
end

function ModalConsumer:didMount()
	self.disconnectModalListener = self._modalStatus:subscribe(function()
		self:setState(getDataFromModalStatus(self._modalStatus))
	end)
end

function ModalConsumer:willUnmount()
	self.disconnectModalListener()
end

return ModalConsumer
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX46B057A8F1304628BCDE4D6DD495DE10">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getSettings</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local settingsKey = require(Plugin.Core.Keys.settingsKey)

return function(component)
	return component._context[settingsKey]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX50D9EEE8F0B246888F26B4779AB31CC5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">withModal</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local ModalConsumer = require(Plugin.Core.Consumers.ModalConsumer)

return function(callback)
	return Roact.createElement(ModalConsumer, {
		render = callback,
	})
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5480FF51F2F54A2BBC91591B758517CB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ThemeConsumer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local getTheme = require(Plugin.Core.Consumers.getTheme)

local ThemeConsumer = Roact.Component:extend("ThemeConsumer")

function ThemeConsumer:init()
	local theme = getTheme(self)

	self.theme = theme
	self.state = {
		themeValues = theme.values,
	}
end

function ThemeConsumer:render()
	return self.props.render(self.state.themeValues)
end

function ThemeConsumer:didMount()
	self.disconnectThemeListener = self.theme:subscribe(function(newValues)
		self:setState({
			themeValues = newValues,
		})
	end)
end

function ThemeConsumer:willUnmount()
	self.disconnectThemeListener()
end

return ThemeConsumer
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX03C7CBCAACFB430AA9135E182300F348">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getNetwork</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local networkInterfaceKey = require(Plugin.Core.Keys.networkInterfaceKey)

return function(component)
	return component._context[networkInterfaceKey]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6EE8E802AF3845D6A1733B4711553DFB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getModal</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function(component)
	return {
		modalTarget = component._context.modalTarget,
		_modalStatus = component._context._modalStatus,
		onTooltipTriggered = component._context.onTooltipTriggered,
		onDropdownToggled = component._context.onDropdownToggled,
		isShowingModal = component._context.isShowingModal,
	}
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC8B6E3969F7D4A6C899C7536E3EC74CF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getTheme</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local themeKey = require(Plugin.Core.Keys.themeKey)

return function(component)
	return component._context[themeKey]
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1E3D6751E85241E89C793D40AF303ACC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">withPlugin</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local PluginConsumer = require(Plugin.Core.Consumers.PluginConsumer)

return function(callback)
	return Roact.createElement(PluginConsumer, {
		render = callback,
	})
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFE0BAF42631A49A0B9932F0812C8D5BD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PluginConsumer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local getPlugin = require(Plugin.Core.Consumers.getPlugin)

local PluginConsumer = Roact.Component:extend("PluginConsumer")

function PluginConsumer:init()
	self.plugin, self.pluginGui = getPlugin(self)
end

function PluginConsumer:render()
	return self.props.render(self.plugin, self.pluginGui)
end

return PluginConsumer
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8E2232CFE667462E8DF552B673361D40">
				<Properties>
					<string name="Name">Types</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX88232239C8CB450789D23545B5E6BC7E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sort</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Category = require(Plugin.Core.Types.Category)

local Sort = {}

Sort.SORT_OPTIONS = {
	{name = "Relevance", sort = "Relevance"},
	{name = "Most Taken", sort = "MostTaken"},
	{name = "Favorites", sort = "Favorites"},
	{name = "Updated", sort = "Updated"},
	{name = "Ratings", sort = "Ratings"}
}

function Sort.canSort(searchTerm, categoryIndex)
	return searchTerm ~= "" and Category.categoryIsFreeAsset(categoryIndex)
end

return Sort
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX18195A9FA715490B9E619AAA653EE01A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Category</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local BuiltInPluginGetPackageAPIEnabled = settings():GetFFlag("BuiltInPluginGetPackageAPIEnabled")

local Category = {}

Category.CATEGORIES_WITHOUT_GROUPS = {}
Category.CATEGORIES = {}

-- Turns a category value into a variable name that can be used as a constant
-- Assumes no spaces in the category and instead uppercase letters indicate new words
-- So it puts _ between them and removes any _ at the start
-- And uppercases the whole word
-- e.g. "FreeModels" -> "FREE_MODELS"
local function categoryToConstant(category)
	return category:gsub("%u", "_%1"):upper():gsub("^_", "")
end

-- Adds a category to the CATEGORIES table
-- If isGroupOnly = false or nil then also adds to CATEGORIES_WITHOUT_GROUPS
-- Puts a global into Category to get the index of a certain category
local function addCategory(name, category, isGroupOnly)
	local categoryObject = {
		name = name,
		category = category,
	}

	local index = #Category.CATEGORIES + 1
	if not isGroupOnly then
		Category.CATEGORIES_WITHOUT_GROUPS[index] = categoryObject
	end
	Category.CATEGORIES[index] = categoryObject

	Category[categoryToConstant(category)] = index
end

function Category.categoryIsPackage(index)
	return BuiltInPluginGetPackageAPIEnabled and index
		and (index == Category.MY_PACKAGES or index == Category.GROUP_PACKAGES)
end

function Category.categoryIsFreeAsset(index)
	return index and index <= Category.FREE_AUDIO
end

function Category.categoryIsGroupAsset(index)
	return index and index >= Category.GROUP_MODELS
end

local function init()
	local assetTypes = {"Models", "Decals", "Meshes", "Audio"}

	for _, assetType in ipairs(assetTypes) do
		addCategory(assetType, "Free" .. assetType)
	end

	for _, assetType in ipairs(assetTypes) do
		addCategory("My " .. assetType, "My" .. assetType)
	end

	for _, assetType in ipairs(assetTypes) do
		addCategory("Recent " .. assetType, "Recent" .. assetType)
	end

	if BuiltInPluginGetPackageAPIEnabled then
		addCategory("My Packages", "MyPackages")
	end

	for _, assetType in ipairs(assetTypes) do
		addCategory("Group " .. assetType, "Group" .. assetType, true)
	end

	if BuiltInPluginGetPackageAPIEnabled then
		addCategory("Group Packages", "GroupPackages", true)
	end
end

if #Category.CATEGORIES == 0 then
	init()
end

return Category
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBFE35B9B2B8E4238A8D47CFEDEF13B45">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Background</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Colors = require(Plugin.Core.Util.Colors)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Images = require(Plugin.Core.Util.Images)
local Immutable = require(Plugin.Core.Util.Immutable)

local withTheme = require(Plugin.Core.Consumers.withTheme)

local Background = {}

Background.BACKGROUNDS = {
	{
		name = "White",
	},
	{
		name = "Black",
	},
	{
		name = "None",
	}
}

-- Indices from the above table so we don't use magic numbers elsewhere
Background.WHITE = 1
Background.BLACK = 2
Background.NONE = 3

function Background.renderIcon(background, props)
	local elementType = "Frame"

	if background == Background.WHITE then
		props = Immutable.JoinDictionaries(props, {
			BackgroundColor3 = Colors.WHITE,
			BorderColor3 = Colors.GRAY_3,
		})

	elseif background == Background.BLACK then
		props = Immutable.JoinDictionaries(props, {
			BackgroundColor3 = Colors.GRAY_1,
			BorderColor3 = Colors.GRAY_1,
		})

	elseif background == Background.NONE then
		elementType = "ImageLabel"
		props = Immutable.JoinDictionaries(props, {
			BackgroundColor3 = Colors.WHITE,
			BorderColor3 = Colors.GRAY_3,
			Image = Images.NO_BACKGROUND_ICON,
		})

	else
		if DebugFlags.shouldDebugWarnings() then
			warn(("Toolbox background %s is not valid"):format(tostring(background)))
		end

		return nil
	end

	return Roact.createElement(elementType, props)
end

function Background.renderBackground(background, props, children)
	return withTheme(function(theme)
		local tileCount = 8

		local isDarkerTheme = theme.isDarkerTheme
		local iconTheme = theme.asset.icon

		local backgroundColor = Color3.fromRGB(255, 255, 255)
		local image = ""
		local hasBorder = false

		if background == Background.BLACK then
			backgroundColor = Color3.fromRGB(0, 0, 0)

		elseif background == Background.NONE then
			if isDarkerTheme then
				backgroundColor = theme.toolbox.backgroundColor
				hasBorder = true
			else
				image = Images.NO_BACKGROUND_ICON
			end
		end

		props = Immutable.JoinDictionaries(props, {
			BackgroundColor3 = backgroundColor,
			Image = image,
			BorderColor3 = iconTheme.borderColor,
			BorderSizePixel = hasBorder and 1 or 0,
			ScaleType = Enum.ScaleType.Tile,
			TileSize = UDim2.new(1 / tileCount, 0, 1 / tileCount, 0),
		})

		return Roact.createElement("ImageLabel", props, children)
	end)
end

return Background
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7750714ADB54432987E64F32BC8048B1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Suggestion</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Suggestion = {}

Suggestion.SUGGESTIONS = {
	"NPC",
	"Vehicle",
	"Weapon",
	"Building",
	"Light",
}

return Suggestion
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX5C4BAB08AC544DFBAB253BCF1E828242">
				<Properties>
					<string name="Name">Util</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD4D3DC02B23A4862923E8373202FEE96">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Layouter</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)

local Constants = require(Plugin.Core.Util.Constants)

local Category = require(Plugin.Core.Types.Category)

local SuggestionsButton = require(Plugin.Core.Components.Suggestions.SuggestionsButton)
local SuggestionsLabel = require(Plugin.Core.Components.Suggestions.SuggestionsLabel)

local Layouter = {}

function Layouter.getAssetsPerRow(width)
	return math.floor((width + Constants.BETWEEN_ASSETS_HORIZONTAL_PADDING)
		/ (Constants.ASSET_WIDTH + Constants.BETWEEN_ASSETS_HORIZONTAL_PADDING))
end

function Layouter.getAssetCellHeightWithPadding()
	return Constants.ASSET_HEIGHT + Constants.BETWEEN_ASSETS_VERTICAL_PADDING
end

function Layouter.calculateAssetsHeight(assetCount, maxWidth)
	-- TODO CLIDEVSRVS-1587: All of this is terrible, make it better
	-- This calculates how tall to make the grid container based on how its
	-- going to layout the assets. First get how wide the container is, from
	-- that how many assets can we fit per row. So then how many rows are
	-- needed for all the assets and from that get the height of the
	-- container. In the future, this might be replaceable by
	-- SizeFromContents

	if assetCount == 0 or maxWidth == 0 then
		return 0
	end

	local assetsPerRow = Layouter.getAssetsPerRow(maxWidth)
	if assetsPerRow == 0 then
		return 0
	end

	local rowsNeeded = math.ceil(assetCount / assetsPerRow)
	return ((Constants.ASSET_HEIGHT + Constants.BETWEEN_ASSETS_VERTICAL_PADDING) * rowsNeeded)
		- Constants.BETWEEN_ASSETS_VERTICAL_PADDING
end

function Layouter.sliceAssetsFromBounds(idsToRender, lowerBound, upperBound)
	local assetIds = {}

	lowerBound = lowerBound or 1
	upperBound = math.min(upperBound or #idsToRender, #idsToRender)

	if lowerBound > 0 and upperBound >= lowerBound then
		for i = lowerBound, upperBound, 1 do
			assetIds[#assetIds + 1] = idsToRender[i]
		end
	end

	return assetIds
end

function Layouter.calculateRenderBoundsForScrollingFrame(scrollingFrame, containerWidth, headerHeight)
	if not scrollingFrame then
		return 0, 0
	end

	-- TODO CLIDEVSRVS-1587: Tidy this up
	local assetsPerRow = Layouter.getAssetsPerRow(containerWidth)
	local assetHeight = Layouter.getAssetCellHeightWithPadding()

	-- Top and range of the window
	local scrollDist = scrollingFrame.CanvasPosition.Y - headerHeight
	local displayHeight = scrollingFrame.AbsoluteSize.Y

	-- Adjust for padding
	local padding = Constants.SCROLLING_FRAME_VIEW_PADDING
	scrollDist = scrollDist - padding
	displayHeight = displayHeight + (2 * padding)

	-- Convert top and range from pixels to row bounds
	local lowerRowNumber = math.max(math.floor(scrollDist / assetHeight), 0)
	local upperRowNumber = lowerRowNumber + math.ceil(displayHeight / assetHeight)

	-- Rows to indicies
	local lowerBound = (lowerRowNumber * assetsPerRow) + 1
	local upperBound = (upperRowNumber + 1) * assetsPerRow

	return lowerBound, upperBound
end

function Layouter.calculateMainViewHeaderHeight(categoryIndex, searchTerm, suggestions, containerWidth)
	local headerHeight = 0
	local headerToBodyPadding = 0

	local showSort = #searchTerm > 0
	local showSuggestions = searchTerm == ""

	-- Only the free assets have sort and suggestions
	if not Category.categoryIsFreeAsset(categoryIndex) then
		showSort = false
		showSuggestions = false
	end

	if showSort then
		headerToBodyPadding = Constants.MAIN_VIEW_VERTICAL_PADDING
		headerHeight = headerHeight + Constants.SORT_COMPONENT_HEIGHT
	end

	if showSuggestions then
		headerToBodyPadding = Constants.MAIN_VIEW_VERTICAL_PADDING
		local padding = showSort and Constants.MAIN_VIEW_VERTICAL_PADDING or 0
		local height = Layouter.calculateSuggestionsHeight(Constants.SUGGESTIONS_INTRO_TEXT, suggestions, containerWidth)
		headerHeight = headerHeight + padding + height
	end

	return headerHeight, headerToBodyPadding
end


function Layouter.calculateSuggestionsHeight(initialText, suggestions, maxWidth)
	local rowCount = 0
	local rowWidth = 0

	-- Starts at 0, not 1
	for index = 0, #suggestions, 1 do
		local text = (index == 0) and initialText or suggestions[index]
		local textWidth = Constants.getTextSize(text).x
		if (rowWidth + Constants.SUGGESTIONS_INNER_PADDING + textWidth > maxWidth) then
			rowCount = rowCount + 1
			rowWidth = textWidth
		else
			rowWidth = rowWidth + Constants.SUGGESTIONS_INNER_PADDING + textWidth
		end
	end

	if (rowWidth > 0) then
		rowCount = rowCount + 1
	end

	return (rowCount * Constants.SUGGESTIONS_ROW_HEIGHT)
		+ (2 * Constants.SUGGESTIONS_OUTER_PADDING)
end

local function insertRow(state)
	-- Can't check #row as its a dictionary so #state.row == 0
	if (state.rowWidth > 0) then
		state.row.UIListLayout = Roact.createElement("UIListLayout", {
			Padding = UDim.new(0, Constants.SUGGESTIONS_INNER_PADDING),
			FillDirection = Enum.FillDirection.Horizontal,
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
			SortOrder = Enum.SortOrder.LayoutOrder,
		})
		state.rows[("Row%d"):format(state.rowCount)] = Roact.createElement("Frame", {
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 0, Constants.SUGGESTIONS_ROW_HEIGHT),
			LayoutOrder = state.rowCount,
		}, state.row)

		state.rowCount = state.rowCount + 1
	end

	-- Reset variables for next row
	state.row = {}
	state.rowWidth = 0
end

local function addInitial(state, initialText)
	state.row[initialText] = Roact.createElement(SuggestionsLabel, {
		Text = initialText,
	})

	state.rowWidth = Constants.getTextSize(initialText).x
end

local function addButton(state, index, text, maxWidth, onSuggestionSelected)
	local textWidth = Constants.getTextSize(text).x

	-- If adding this text won't fit then add the row we have so far and start a new row
	if (state.rowWidth + Constants.SUGGESTIONS_INNER_PADDING + textWidth > maxWidth) then
		insertRow(state)
	end

	state.row[text] = Roact.createElement(SuggestionsButton, {
		Text = text,
		LayoutOrder = index,
		onClicked = onSuggestionSelected,
	})

	state.rowWidth = state.rowWidth + Constants.SUGGESTIONS_INNER_PADDING + textWidth
end

function Layouter.layoutSuggestions(initialText, suggestions, maxWidth, onSuggestionSelected)
	-- Keep track of the current layout that gets updated by helper functions
	local state = {
		rowCount = 0,
		rows = {},
		rowWidth = 0,
		row = {},
	}

	state.rows.UIPadding = Roact.createElement("UIPadding", {
		PaddingBottom = UDim.new(0, Constants.SUGGESTIONS_OUTER_PADDING),
		PaddingLeft = UDim.new(0, 0),
		PaddingRight = UDim.new(0, 0),
		PaddingTop = UDim.new(0, Constants.SUGGESTIONS_OUTER_PADDING),
	})

	state.rows.UIListLayout = Roact.createElement("UIListLayout", {
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
		VerticalAlignment = Enum.VerticalAlignment.Top,
		SortOrder = Enum.SortOrder.LayoutOrder,
	})

	addInitial(state, initialText)

	for index, _ in ipairs(suggestions) do
		addButton(state, index, suggestions[index], maxWidth, onSuggestionSelected)
	end

	insertRow(state)

	return state.rows
end

return Layouter
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB765F63AF2A648B0B9E2B98D078B08E2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ToolboxTheme</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Colors = require(Plugin.Core.Util.Colors)
local createSignal = require(Plugin.Core.Util.createSignal)
local Immutable = require(Plugin.Core.Util.Immutable)
local wrapStrictTable = require(Plugin.Core.Util.wrapStrictTable)

local ToolboxTheme = {}

function ToolboxTheme.enableLuaApisForTheme()
	return settings():GetFFlag("StudioEnableLuaAPIsForThemes")
end

function ToolboxTheme.createDummyThemeManager()
	if ToolboxTheme.enableLuaApisForTheme() then
		-- Fake the studio theme impl
		return ToolboxTheme.new({
			getTheme = {
				GetColor = function()
					return Color3.fromRGB(0, 0, 0)
				end,
			},
		})
	else
		return ToolboxTheme.new({
			getTheme = Enum.UITheme.Light,
		})
	end
end

function ToolboxTheme.new(options)
	local self = {
		_externalThemeGetter = options.getTheme or nil,
		_isDarkThemeGetter = options.isDarkerTheme or false,
		_externalThemeChangedSignal = options.themeChanged or nil,

		_externalThemeChangedConnection = nil,

		_values = {},

		_signal = createSignal(),
	}

	self.values = wrapStrictTable(self._values, "theme")

	setmetatable(self, {
		__index = ToolboxTheme
	})

	if self._externalThemeChangedSignal then
		self._externalThemeChangedConnection = self._externalThemeChangedSignal:Connect(function()
			self:_recalculateTheme()
		end)
	end
	self:_recalculateTheme()

	return self
end

function ToolboxTheme:subscribe(...)
	return self._signal:subscribe(...)
end

function ToolboxTheme:destroy()
	if self._externalThemeChangedConnection then
		self._externalThemeChangedConnection:Disconnect()
	end
end

function ToolboxTheme:_update(changedValues)
	self._values = Immutable.JoinDictionaries(self._values, changedValues)
	self.values = wrapStrictTable(self._values, "theme")
	self._signal:fire(self.values)
end

function ToolboxTheme:_getExternalTheme()
	local getter = self._externalThemeGetter

	if type(getter) == "function" then
		return getter()
	end

	return getter
end

function ToolboxTheme:_isDarkerTheme()
	local getter = self._isDarkThemeGetter

	if type(getter) == "function" then
		return getter()
	end

	return getter and true or false
end

function ToolboxTheme:_recalculateTheme()
	local externalTheme = self:_getExternalTheme()
	local isDark = self:_isDarkerTheme()

	if self.enableLuaApisForTheme() then
		-- Shorthands for getting a color
		local c = Enum.StudioStyleGuideColor
		local m = Enum.StudioStyleGuideModifier

		local function color(...)
			return externalTheme:GetColor(...)
		end

		self:_update({
			isDarkerTheme = isDark,

			toolbox = {
				backgroundColor = color(c.MainBackground),
			},

			header = {
				backgroundColor = color(c.Titlebar),
				borderColor = color(c.Border),
			},

			dropdownMenu = {
				currentSelection = {
					backgroundColor = color(c.Dropdown),
					backgroundSelectedColor = color(c.CurrentMarker),
					borderColor = color(c.Border),
					borderSelectedColor = color(c.CurrentMarker),
					textColor = color(c.MainText),
					textSelectedColor = color(c.MainText, m.Selected),

					-- TODO CLIDEVSRVS-1690: Icon colour
					iconColor = isDark and Color3.fromRGB(242, 242, 242) or Color3.fromRGB(25, 25, 25),
					iconSelectedColor = Color3.fromRGB(255, 255, 255),
				},

				item = {
					backgroundColor = color(c.Item),

					-- TODO CLIDEVSRVS-1690: Item background colour
					-- backgroundSelectedColor = isDark and Color3.fromRGB(11, 90, 175) or Color3.fromRGB(242, 242, 242),
					backgroundSelectedColor = isDark and color(c.Item, m.Selected) or color(c.Tab),

					selectedBarColor = color(c.CurrentMarker),
					textColor = color(c.MainText),
				},

				dropdownFrame = {
					borderColor = color(c.Border),
				},
			},

			searchBar = {
				backgroundColor = color(c.Dropdown),
				borderColor = color(c.Border),
				borderSelectedColor = color(c.CurrentMarker),
				textColor = color(c.MainText),
				placeholderTextColor = color(c.DimmedText),
				divideLineColor = color(c.Border),

				-- TODO CLIDEVSRVS-1690: Search bar button colours
				searchButton = {
					imageColor = Color3.fromRGB(184, 184, 184),
					imageSelectedColor = Color3.fromRGB(0, 162, 255),
				},

				clearButton = {
					imageColor = Color3.fromRGB(184, 184, 184),
					imageSelectedColor = Color3.fromRGB(0, 162, 255),
				},
			},

			asset = {
				outline = {
					backgroundColor = color(c.MainBackground),
					borderColor = color(c.Border),
				},

				icon = {
					-- TODO CLIDEVSRVS-1690: Don't show border in lighter theme. Put that into theme object, rather than asset icon?
					borderColor = color(c.Item, m.Hover),
				},

				assetName = {
					textColor = color(c.LinkText),
				},

				creatorName = {
					textColor = color(c.SubText),
				},

				voting = {
					textColor = color(c.SubText),

					upVotes = Color3.fromRGB(82, 168, 70),
					downVotes = Color3.fromRGB(206, 100, 91),

					-- TODO CLIDEVSRVS-1690: The buttons should use ImageColor3 instead of multiple images
				},
			},

			infoBanner = {
				backgroundColor = color(c.Titlebar),
				textColor = color(c.SubText),
			},

			loadingIndicator = {
				baseColor = isDark and Color3.fromRGB(56, 56, 56) or Color3.fromRGB(184, 184, 184),
				endColor = isDark and Color3.fromRGB(11, 90, 175) or Color3.fromRGB(0, 162, 255),
			},

			footer = {
				backgroundColor = color(c.Titlebar),
				borderColor = color(c.Border),
				labelTextColor = color(c.MainText),

				button = {
					textColor = color(c.MainText),
					textSelectedColor = color(c.MainText, m.Selected),
					backgroundColor = color(c.Dropdown),
					backgroundSelectedColor = color(c.CurrentMarker),
					borderColor = color(c.Border),
					borderSelectedColor = color(c.CurrentMarker),
				},
			},

			tooltip = {
				backgroundColor = color(c.MainBackground),
				borderColor = color(c.Border),
				textColor = color(c.MainText),
			},

			scrollingFrame = {
				-- TODO CLIDEVSRVS-1690: Scrollbar colour.
				-- Using semantic names means background too dark in light theme and bar invisible to see in dark theme.
				scrollbarBackgroundColor = isDark and Color3.fromRGB(41, 41, 41) or Color3.fromRGB(245, 245, 245),
				scrollbarImageColor = isDark and Color3.fromRGB(85, 85, 85) or Color3.fromRGB(245, 245, 245),
			},

			sortComponent = {
				labelTextColor = color(c.MainText),
			},

			suggestionsComponent = {
				labelTextColor = color(c.MainText),
				textColor = color(c.SubText),
				textHoveredColor = color(c.LinkText),
				underlineColor = color(c.LinkText),
			},
		})
	else
		self:_update({
			isDarkerTheme = isDark,

			toolbox = {
				backgroundColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.WHITE,
			},

			header = {
				backgroundColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.HEADER_BACKGROUND_COLOR,
				borderColor = isDark and Colors.DARK_BORDER_COLOR or Colors.HEADER_BORDER_COLOR,
			},

			dropdownMenu = {
				currentSelection = {
					backgroundColor = isDark and Colors.DARK_BACKGROUND_COLOR or Colors.WHITE,
					backgroundSelectedColor = isDark and Colors.DARK_BACKGROUND_COLOR or Colors.BLUE_PRIMARY,
					borderColor  = isDark and Colors.DARK_GREY_BUTTON_DEFAULT_COLOR  or Colors.GRAY_3,
					borderSelectedColor = isDark and Colors.DARK_GREY_BUTTON_DEFAULT_COLOR or Colors.BLUE_PRIMARY,
					textColor  = isDark and Colors.DARK_TITLE_COLOR or Colors.GRAY_1,
					textSelectedColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.WHITE,
					iconColor = isDark and Colors.GRAY_5 or Colors.GRAY_1,
					iconSelectedColor = isDark and Colors.WHITE or Colors.WHITE,
				},

				item = {
					backgroundColor = isDark and Colors.DARK_BORDER_COLOR or Colors.WHITE,
					backgroundSelectedColor = isDark and Colors.DARK_WIDGET_SELECTED_COLOR or Colors.GRAY_5,
					selectedBarColor = Colors.BLUE_PRIMARY,
					textColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.GRAY_1,
				},

				dropdownFrame = {
					borderColor = isDark and Colors.DARK_BORDER_COLOR or Colors.GRAY_3,
				},
			},

			searchBar = {
				backgroundColor = isDark and Colors.DARK_RIBBON_BAR_ICON_HOVER_COLOR or Colors.WHITE,
				borderColor = isDark and Colors.DARK_BORDER_COLOR or Colors.GRAY_3,
				borderSelectedColor = isDark and Colors.DARK_WIDGET_SELECTED_COLOR or Colors.BLUE_PRIMARY,
				textColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.GRAY_1,
				placeholderTextColor = isDark and Colors.DARK_DIMMER_TEXT_COLOR or Colors.GRAY_3,
				divideLineColor = isDark and Colors.DARK_BORDER_COLOR or Colors.GRAY_3,

				searchButton = {
					imageColor = Colors.GRAY_3,
					imageSelectedColor = Colors.BLUE_PRIMARY,
				},

				clearButton = {
					imageColor = Colors.GRAY_3,
					imageSelectedColor = Colors.BLUE_PRIMARY,
				},
			},

			asset = {
				outline = {
					backgroundColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.WHITE,
					borderColor = isDark and Colors.DARK_BORDER_COLOR or Colors.GRAY_3,
				},

				icon = {
					borderColor = isDark and Colors.DARK_WIDGET_HOVER_COLOR or Colors.WHITE,
				},

				creatorName = {
					textColor = isDark and Colors.DARK_TITLE_COLOR or Colors.GRAY_2,
				},

				assetName = {
					textColor = isDark and Colors.DARK_TITLE_COLOR or Colors.LIGHT_ASSETNAME_TEXT_COLOR,
				},

				voting = {
					textColor = isDark and Colors.DARK_DIMMER_TEXT_COLOR  or Colors.GRAY_2,

					upVotes = Colors.VOTING_GREEN,
					downVotes = Colors.VOTING_RED,
				},
			},

			infoBanner = {
				backgroundColor = isDark and Colors.DARK_SCROLL_BAR_COLOR or Colors.GRAY_3,
				textColor = isDark and Colors.DARK_TITLE_COLOR or Colors.GRAY_2,
			},

			loadingIndicator = {
				baseColor = isDark and Colors.DARK_SCROLL_BAR_COLOR or Colors.GRAY_3,
				endColor = isDark and Colors.DARK_WIDGET_SELECTED_COLOR or Colors.BLUE_PRIMARY,
			},

			footer = {
				backgroundColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.FOOTER_BACKGROUND_COLOR,
				borderColor = isDark and Colors.DARK_BORDER_COLOR or Colors.FOOTER_BORDER_COLOR,
				labelTextColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.GRAY_1,

				button = {
					textColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.GRAY_1,
					textSelectedColor = isDark and Colors.DARK_TITLE_COLOR or Colors.WHITE,
					backgroundColor = isDark and Colors.DARK_BACKGROUND_COLOR or Colors.WHITE,
					backgroundSelectedColor = isDark and Colors.DARK_BACKGROUND_COLOR or Colors.BLUE_PRIMARY,
					borderColor = isDark and Colors.DARK_GREY_BUTTON_DEFAULT_COLOR  or Colors.GRAY_3,
					borderSelectedColor = Colors.BLUE_PRIMARY,
				},
			},

			tooltip = {
				backgroundColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.WHITE,
				borderColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.GRAY_5,
				textColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.BLACK,
				shadow = {
					imageColor = isDark and Colors.DARK_BORDER_COLOR or Colors.WHITE,
					borderColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.DARK_MAIN_SECTION_COLOR,
					backgroundColor = isDark and Colors.DARK_MAIN_SECTION_COLOR or Colors.WHITE,
				},
			},

			scrollingFrame = {
				scrollbarBackgroundColor = isDark and Colors.DARK_SCROLL_BAR_BACKGROUND_COLOR or Colors.GRAY_6,
				scrollbarImageColor = isDark and Colors.DARK_DISABLED_TEXT_COLOR or Colors.GRAY_6,
			},

			sortComponent = {
				labelTextColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.GRAY_1,
			},

			suggestionsComponent = {
				labelTextColor = isDark and Colors.DARK_MAIN_TEXT_COLOR or Colors.GRAY_1,
				textColor = Colors.GRAY_2,
				textHoveredColor = Colors.BLUE_PRIMARY,
				underlineColor = Colors.BLUE_PRIMARY,
			},
		})
	end
end

return ToolboxTheme
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2E6574401F1F4A3CBA875F84CE544224">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.
		local signal = createSignal()
		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)
		signal:fire("something")
		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX19C90972395F482FA4728026AAB2EA4E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PageInfoHelper</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)

local PageInfoHelper = {}

function PageInfoHelper.getCategory(categories, index)
	local category = categories[index]

	if not category or not category.category then
		if DebugFlags.shouldDebugWarnings() then
			warn(("Lua toolbox: No category for category index %s"):format(tostring(index)))
		end
		return ""
	end

	return category.category
end

function PageInfoHelper.getCategoryForPageInfo(pageInfo)
	return PageInfoHelper.getCategory(pageInfo.categories, pageInfo.categoryIndex)
end

function PageInfoHelper.getSortType(sorts, index)
	local sort = sorts[index]

	if not sort or not sort.sort then
		if DebugFlags.shouldDebugWarnings() then
			warn(("Lua Toolbox: no sort for sort index %s"):format(tostring(index)))
		end
		return ""
	end

	return sort.sort
end

function PageInfoHelper.getSortTypeForPageInfo(pageInfo)
	return PageInfoHelper.getSortType(pageInfo.sorts, pageInfo.sortIndex)
end

function PageInfoHelper.getGroupId(groups, index)
	if index == 0 then
		return 0
	end

	if index < 1 or index > #groups or not groups[index].id then
		if DebugFlags.shouldDebugWarnings() then
			warn(("Lua Toolbox: no group for group index %s"):format(tostring(index)))
		end
		return 0
	end

	return groups[index].id
end

function PageInfoHelper.getGroupIdForPageInfo(pageInfo)
	return PageInfoHelper.getGroupId(pageInfo.groups, pageInfo.groupIndex)
end

return PageInfoHelper
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC2D3FBE6C5B149BE97599D784AEDE181">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InsertAsset</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Analytics = require(Plugin.Core.Util.Analytics.Analytics)
local AssetInsertionTracker = require(Plugin.Core.Util.AssetInsertionTracker)
local DebugFlags = require(Plugin.Core.Util.DebugFlags)
local Urls = require(Plugin.Core.Util.Urls)
local Category = require(Plugin.Core.Types.Category)

local ChangeHistoryService = game:GetService("ChangeHistoryService")
local Selection = game:GetService("Selection")
local InsertService = game:GetService("InsertService")
local Workspace = game:GetService("Workspace")

local function insertAudio(assetId, assetName)
	local url = Urls.constructAssetIdString(assetId)
	if DebugFlags.shouldDebugUrls() then
		print(("Inserting sound %s"):format(url))
	end

	local soundObj = Instance.new("Sound")
	soundObj.SoundId = url
	soundObj.Name = assetName
	soundObj.Parent = (Selection:Get() or {})[1] or Workspace
	Selection:Set({soundObj})

	return soundObj
end

local function insertAsset(assetId, assetName)
	local targetParent = Workspace

	local assetInstance = nil
	local success, errorMessage = pcall(function()
		local url = Urls.constructAssetIdString(assetId)
		if DebugFlags.shouldDebugUrls() then
			print(("Inserting asset %s"):format(url))
		end

		assetInstance = game:GetObjects(url)
	end)

	if success and assetInstance then
		-- Parent everything to the target and select it
		local newSelection = {}
		for _, o in ipairs(assetInstance) do
			o.Parent = targetParent
			newSelection[#newSelection + 1] = o
		end
		Selection:Set(newSelection)
		-- TODO CLIDEVSRVS-1585: Should we reposition what was inserted or move the camera etc?
		return newSelection
	else
		return nil, errorMessage
	end

	-- TODO CLIDEVSRVS-1585: Look at
	-- RbxWorkspace::insert(RBX::Instances& instances, const RBX::Serializer::Metadata& metadata, bool insertInto)
	-- See how it positions the asset:
	-- InsertObjectWidget::getInsertLocation(boost::shared_ptr<RBX::DataModel> pDataModel, QPoint* insertPosition,
	-- 	bool* isOnPart)
	-- And how it zooms the camera to it
end

local function insertDecal(plugin, assetId, assetName)
	local tbl = nil
	local success, errorMessage = pcall(function()
		local url = Urls.constructAssetIdString(assetId)
		if DebugFlags.shouldDebugUrls() then
			print(("Inserting decal %s"):format(url))
		end
		tbl = game:GetObjects(url)
	end)

	if success and tbl and tbl[1] then
		local decal = tbl[1]
		decal.Name = assetName

		local dragSuccess = pcall(function()
			plugin:StartDecalDrag(decal)
		end)
		if not dragSuccess then
			decal.Parent = (Selection:Get() or {})[1] or Workspace
			Selection:Set({decal})
		end

		return decal
	else
		return nil, errorMessage
	end
end

-- For now, inserting pacakages is very different from inserting other assets
local function insertPackage(assetId)
	local instanceTable = nil
	local success, errorMessage = pcall(function()
		local url = Urls.constructAssetIdString(assetId)
		if DebugFlags.shouldDebugUrls() then
			print(("Inserting package %s"):format(url))
		end
		instanceTable = InsertService:LoadPackageAsset(url)
	end)

	if success and instanceTable and instanceTable[1] then
		instanceTable[1].Parent = (Selection:Get() or {})[1] or Workspace
		Selection:set(instanceTable)
		return instanceTable[1]
	else
		return nil, errorMessage
	end
end


--TODO: CLIDEVSRVS-1691: Replacing category index with assetTypeId for package insertion in lua toolbox
local function dispatchInsertAsset(plugin, assetId, assetName, assetTypeId, categoryIndex)
	-- TODO CLIDEVSRVS-1585: Handle different types of assets
	-- e.g. tools can go in starterpack (old toolbox has a popup asking what user wants)
	if Category.categoryIsPackage(categoryIndex) then
		return insertPackage(assetId)
	elseif assetTypeId == Enum.AssetType.Audio.Value then
		return insertAudio(assetId, assetName)
	elseif assetTypeId == Enum.AssetType.Decal.Value and settings():GetFFlag("StudioPluginStartDecalDragApi") then
		return insertDecal(plugin, assetId, assetName)
	else
		return insertAsset(assetId, assetName)
	end
end

local function assetTypeIdToString(assetTypeId)
	if assetTypeId == Enum.AssetType.Model.Value then
		return "Model"
	elseif assetTypeId == Enum.AssetType.Decal.Value then
		return "Decal"
	elseif assetTypeId == Enum.AssetType.Audio.Value then
		return "Audio"
	elseif assetTypeId == Enum.AssetType.Mesh.Value then
		return "Mesh"
	else
		return "Unknown"
	end
end

local function sendInsertionAnalytics(assetId, assetTypeId, assetWasDragged)
	Analytics.trackEventAssetInsert(assetId)
	Analytics.incrementAssetInsertCollector()
	Analytics.incrementToolboxInsertCounter(assetTypeIdToString(assetTypeId))

	-- TODO CLIDEVSRVS-1689: Get search text and asset index for analytics
	local searchText = "[searchText]"
	local assetIndex = "[assetIndex]"

	if not assetWasDragged then
		Analytics.onAssetInserted(assetId, searchText, assetIndex)
	else
		Analytics.onAssetDragInserted(assetId, searchText, assetIndex)
	end

	if assetTypeId == Enum.AssetType.Audio.Value then
		Analytics.onSoundInserted()
	end

	Analytics.incrementWorkspaceInsertCounter()
end

local InsertAsset = {}

--TODO: CLIDEVSRVS-1691: Replacing category index with assetTypeId for package insertion in lua toolbox
function InsertAsset.insertAsset(plugin, assetId, assetName, assetTypeId, onSuccess, categoryIndex)
	if DebugFlags.shouldDebugWarnings() then
		print(("Inserting asset %s %s"):format(tostring(assetId), tostring(assetName)))
	end

	ChangeHistoryService:SetWaypoint(("Before insert asset %d"):format(assetId))

	local asset, errorMessage = dispatchInsertAsset(plugin, assetId, assetName, assetTypeId, categoryIndex)

	if asset then
		ChangeHistoryService:SetWaypoint(("After insert asset %d"):format(assetId))
		sendInsertionAnalytics(assetId, assetTypeId, false)

		AssetInsertionTracker.trackInsert(assetId, asset)

		onSuccess(assetId)
	else
		warn(("Toolbox failed to insert asset %d %s: %s"):format(assetId, assetName, errorMessage or ""))
	end

	return asset
end

function InsertAsset.dragInsertAsset(plugin, assetId, assetName, assetTypeId, onSuccess)
	if DebugFlags.shouldDebugWarnings() then
		print(("Inserting asset %s %s"):format(tostring(assetId), tostring(assetName)))
	end

	ChangeHistoryService:SetWaypoint(("Before insert asset %d"):format(assetId))

	local success, errorMessage = pcall(function()
		-- Mark the toolbox as using the C++ drag handler implementation
		-- That will insert the given asset and drag it in the 3d view
		plugin.UsesAssetInsertionDrag = true

		-- TODO CLIDEVSRVS-1246: This should use uri list or something
		local url = Urls.constructAssetGameAssetIdUrl(assetId, assetTypeId)
		if DebugFlags.shouldDebugUrls() then
			print(("Dragging asset url %s"):format(url))
		end
		local drag = PluginDrag.new("LuaToolbox", "text/plain", url)
		plugin:StartDrag(drag)
	end)

	if success then
		ChangeHistoryService:SetWaypoint(("After insert asset %d"):format(assetId))
		sendInsertionAnalytics(assetId, assetTypeId, true)

		-- TODO CLIDEVSRVS-1689: For AssetInsertionTracker.trackInsert with dragged
		-- asset, need to listen for dropped event on 3d view which
		-- depends on viewports api

		-- TODO CLIDEVSRVS-1246: If they cancel the drag, this probably shouldn't be called?
		onSuccess(assetId)
	else
		warn(("Toolbox failed to drag asset %d %s: %s"):format(assetId, assetName, errorMessage or ""))
	end

	return success
end

return InsertAsset
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0F46A359721D4CC18EFB4FC35B4B9991">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ModalStatus</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local createSignal = require(Plugin.Core.Util.createSignal)

local ModalStatus = {}

function ModalStatus.new()
	return setmetatable({
		_signal = createSignal(),

		-- TODO CLIDEVSRVS-1689: remove me if we have a fix for the tooltip problems.
		-- Only the objct match the newest id and type will show tooltip
		_currentTooltipAssetId = 0,

		-- Type id
		-- 1 AssetIcon
		-- 2 AssetName
		-- 3 CreatorName
		-- 4 HighQualityBadge
		_currentTooltipTypeId = 0,

		_isDropdownShown = false,
	}, {
		__index = ModalStatus,
	})
end

function ModalStatus:subscribe(...)
	return self._signal:subscribe(...)
end

function ModalStatus:isShowingModal()
	return self._isDropdownShown
end

function ModalStatus:onTooltipTriggered(assetId, typeId)
	self._currentTooltipAssetId = assetId
	self._currentTooltipTypeId = typeId

	self._signal:fire()
end

function ModalStatus:onDropdownToggled(shown)
	self._isDropdownShown = shown

	self._signal:fire()
end

function ModalStatus:isCurrentTooltip(assetId, typeId)
	return self._currentTooltipAssetId == assetId and self._currentTooltipTypeId == typeId
end

function ModalStatus:canShowCurrentTooltip(assetId, typeId)
	return not self._isDropdownShown and self:isCurrentTooltip(assetId, typeId)
end

return ModalStatus
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6D5AF2CA795F4BEA94780AC1B381FA01">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MouseManager</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Images = require(Plugin.Core.Util.Images)

-- TODO CLIDEVSRVS-1357: Make this better

local disableMouseIcons = true

local MouseManager = {
	_mouse = nil,
	_icons = {},
}

function MouseManager:setPlugin(plugin)
	self._mouse = plugin:GetMouse()
end

function MouseManager:pushIcon(icon)
	if disableMouseIcons then
		return
	end

	if self._icons == icon then
		return
	end

	self._mouse.Icon = icon
	self._icons[#self._icons + 1] = icon
end

function MouseManager:popIcon(icon)
	if disableMouseIcons then
		return
	end

	if #self._icons == 0 then
		return
	end

	local top = self._icons[#self._icons]
	if top == icon then
		self._icons[#self._icons] = nil
	end

	self._mouse.Icon = self._icons[#self._icons] or Images.CURSOR_DEFAULT
end

function MouseManager:clearIcons()
	if disableMouseIcons then
		return
	end

	self._icons = {}
	self._mouse.Icon = Images.CURSOR_DEFAULT
end

return MouseManager
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC4241CA1F73D4525BD367E533D8389D8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Layouter.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Layouter = require(Plugin.Core.Util.Layouter)

	describe("calculateAssetsHeight", function()
		it("should return the correct height", function()
			local assetCounts = {0, 2, 10, 100, 500, 1000}
			local maxWidths = {100, 200, 500, 1000}

			local heights = {
				{0, 0, 0, 0},
				{238, 111, 111, 111},
				{1254, 619, 238, 111},
				{12684, 6334, 2143, 1127},
				{63484, 31734, 10652, 5318},
				{126984, 63484, 21193, 10652}
			}

			for row, _ in ipairs(heights) do
				local assetCount = assetCounts[row]

				for column, height in ipairs(heights[row]) do
					local maxWidth = maxWidths[column]
					expect(height).to.equal(Layouter.calculateAssetsHeight(assetCount, maxWidth))
				end
			end
		end)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9F7E441B229547F682827EA4F8824BBD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Images</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local wrapStrictTable = require(Plugin.Core.Util.wrapStrictTable)

local Images = {}

Images.ROUNDED_BACKGROUND_IMAGE = "rbxasset://textures/StudioToolbox/RoundedBackground.png"
Images.ROUNDED_BORDER_IMAGE = "rbxasset://textures/StudioToolbox/RoundedBorder.png"

Images.ARROW_DOWN_ICON = "rbxasset://textures/StudioToolbox/ArrowDownIconWhite.png"

Images.SEARCH_ICON = "rbxasset://textures/StudioToolbox/Search.png"
Images.CLEAR_ICON_HOVER = "rbxasset://textures/StudioToolbox/ClearHover.png"
Images.CLEAR_ICON = "rbxasset://textures/StudioToolbox/Clear.png"

Images.SCROLLBAR_TOP_IMAGE = "rbxasset://textures/StudioToolbox/ScrollBarTop.png"
Images.SCROLLBAR_MIDDLE_IMAGE = "rbxasset://textures/StudioToolbox/ScrollBarMiddle.png"
Images.SCROLLBAR_BOTTOM_IMAGE = "rbxasset://textures/StudioToolbox/ScrollBarBottom.png"

Images.THUMB_UP_GREY = "rbxasset://textures/StudioToolbox/Voting/thumbup.png"
Images.THUMB_DOWN_GREY = "rbxasset://textures/StudioToolbox/Voting/thumb-down.png"
Images.THUMB_UP_GREEN = "rbxasset://textures/StudioToolbox/Voting/thumbs-up-filled.png"
Images.THUMB_DOWN_RED = "rbxasset://textures/StudioToolbox/Voting/thumbs-down-filled.png"

Images.PLAY_AUDIO = "rbxasset://textures/StudioToolbox/AudioPreview/play.png"
Images.PLAY_AUDIO_HOVERED = "rbxasset://textures/StudioToolbox/AudioPreview/play_hover.png"
Images.PAUSE_AUDIO = "rbxasset://textures/StudioToolbox/AudioPreview/pause.png"
Images.PAUSE_AUDIO_HOVERED = "rbxasset://textures/StudioToolbox/AudioPreview/pause_hover.png"
Images.LIGHT_PLAY_AUDIO = "rbxasset://textures/StudioToolbox/AudioPreview/light_play.png"
Images.LIGHT_PLAY_AUDIO_HOVERED = "rbxasset://textures/StudioToolbox/AudioPreview/light_play_hover.png"
Images.LIGHT_PAUSE_AUDIO = "rbxasset://textures/StudioToolbox/AudioPreview/light_pause.png"
Images.LIGHT_PAUSE_AUDIO_HOVERED = "rbxasset://textures/StudioToolbox/AudioPreview/light_pause_hover.png"

Images.DROP_SHADOW_IMAGE = "rbxasset://textures/StudioUIEditor/resizeHandleDropShadow.png"

Images.NO_BACKGROUND_ICON = "rbxasset://textures/StudioToolbox/NoBackgroundIcon.png"

Images.ENDORSED_BADGE_ICON = "rbxasset://textures/StudioToolbox/EndorsedBadge.png"

Images.TOOLBOX_ICON = "rbxasset://textures/StudioToolbox/ToolboxIcon.png"

Images.CURSOR_DEFAULT = "rbxasset://Textures/advCursor-default.png"
Images.CURSOR_POINTING_HAND = "rbxasset://SystemCursors/PointingHand"
Images.CURSOR_I_BEAM = "rbxasset://SystemCursors/IBeam"

return wrapStrictTable(Images)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE23FD4407FCE4127B8BB512FE2ADDE62">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">wrapStrictTable</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local enableStrict = true

local wrapStrictTable

local metatable = {
	__index = function(self, key)
		local value = self.__tbl[key]
		if value ~= nil then
			if type(value) == "table" then
				return wrapStrictTable(value, self.__name .. "." .. key)
			end
			return value
		end
		error(("%q is not a valid key in %s"):format(key, self.__name), 2)
	end,
}

wrapStrictTable = function(tbl, name)
	if not enableStrict then
		return tbl
	end

	name = name or ""

	return setmetatable({
		__name = name,
		__tbl = tbl,
	}, metatable)
end

return wrapStrictTable
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5C2AB8B986FF452FB404C20750BCAE7F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Colors</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent
local wrapStrictTable = require(Plugin.Core.Util.wrapStrictTable)

local Colors = {}

-- These color definitions match what are used on the Studio start page
-- Defined in qml/Colors.qml
Colors.BLUE_PRIMARY = Color3.fromRGB(  0, 162, 255)	-- 0    , 0.635, 1

Colors.GRAY_1 = Color3.fromRGB( 25,  25,  25)		-- 0.098, 0.098, 0.098
Colors.GRAY_2 = Color3.fromRGB(117, 117, 117)		-- 0.459, 0.459, 0.459
Colors.GRAY_3 = Color3.fromRGB(184, 184, 184)		-- 0.722, 0.722, 0.722
Colors.GRAY_5 = Color3.fromRGB(242, 242, 242)		-- 0.949, 0.949, 0.949
Colors.GRAY_6 = Color3.fromRGB(245, 245, 245)		-- 0.961, 0.961, 0.961

Colors.WHITE = Color3.fromRGB(255, 255, 255)		-- 1    , 1    , 1
Colors.BLACK = Color3.fromRGB(0, 0, 0)			-- 0    , 0    , 0

Colors.HEADER_BACKGROUND_COLOR = Color3.fromRGB(242, 242, 242)
Colors.HEADER_BORDER_COLOR = Color3.fromRGB(184, 184, 184)

Colors.FOOTER_BACKGROUND_COLOR = Color3.fromRGB(227, 227, 227)
Colors.FOOTER_BORDER_COLOR = Color3.fromRGB(184, 184, 184)

Colors.LIGHT_ASSETNAME_TEXT_COLOR = Color3.fromRGB(65, 105, 225)	-- 0.255, 0.412, 0.882

Colors.DARK_BORDER_COLOR = Color3.fromRGB(34, 34, 34)			-- 0.133, 0.133, 0.133
Colors.DARK_SCROLL_BAR_BACKGROUND_COLOR = Color3.fromRGB(41, 41, 41)

Colors.DARK_BACKGROUND_COLOR = Color3.fromRGB(53, 53, 53)
Colors.DARK_MAIN_SECTION_COLOR = Color3.fromRGB(46, 46, 46)
Colors.DARK_SCROLL_BAR_COLOR = Color3.fromRGB(56, 56, 56)

Colors.DARK_DISABLED_TEXT_COLOR = Color3.fromRGB(85, 85, 85)
Colors.DARK_DIMMER_TEXT_COLOR = Color3.fromRGB(102, 102, 102)
Colors.DARK_TITLE_COLOR = Color3.fromRGB(170, 170, 170)
Colors.DARK_MAIN_TEXT_COLOR = Color3.fromRGB(204, 204, 204)

Colors.DARK_RIBBON_BAR_ICON_HOVER_COLOR = Color3.fromRGB(37, 37, 37)

Colors.DARK_WIDGET_SELECTED_COLOR = Color3.fromRGB(11, 90, 175)
Colors.DARK_WIDGET_HOVER_COLOR = Color3.fromRGB(66, 66, 66)

Colors.DARK_GREY_BUTTON_DEFAULT_COLOR = Color3.fromRGB(58, 58, 58)

Colors.VOTING_GREEN = Color3.fromRGB(82, 168, 70)
Colors.VOTING_RED = Color3.fromRGB(206, 100, 91)

return wrapStrictTable(Colors, "Colors")
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX33D374B5EA8D408E8BFB5A9DED041027">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Immutable</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Provides functions for manipulating immutable data structures.
]]

local Immutable = {}

--[[
	Merges dictionary-like tables together.
]]
function Immutable.JoinDictionaries(...)
	local result = {}

	for i = 1, select("#", ...) do
		local dictionary = select(i, ...)
		for key, value in pairs(dictionary) do
			result[key] = value
		end
	end

	return result
end

--[[
	Joins any number of lists together into a new list
]]
function Immutable.JoinLists(...)
	local new = {}

	for listKey = 1, select("#", ...) do
		local list = select(listKey, ...)
		local len = #new

		for itemKey = 1, #list do
			new[len + itemKey] = list[itemKey]
		end
	end

	return new
end

--[[
	Creates a new copy of the dictionary and sets a value inside it.
]]
function Immutable.Set(dictionary, key, value)
	local new = {}

	for key, value in pairs(dictionary) do
		new[key] = value
	end

	new[key] = value

	return new
end

--[[
	Creates a new copy of the list with the given elements appended to it.
]]
function Immutable.Append(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

--[[
	Remove elements from a dictionary
]]
function Immutable.RemoveFromDictionary(dictionary, ...)
	local result = {}

	for key, value in pairs(dictionary) do
		local found = false
		for listKey = 1, select("#", ...) do
			if key == select(listKey, ...) then
				found = true
				break
			end
		end
		if not found then
			result[key] = value
		end
	end

	return result
end

--[[
	Remove the given key from the list.
]]
function Immutable.RemoveFromList(list, removeIndex)
	local new = {}

	for i = 1, #list do
		if i ~= removeIndex then
			table.insert(new, list[i])
		end
	end

	return new
end

--[[
	Remove the range from the list starting from the index.
]]
function Immutable.RemoveRangeFromList(list, index, count)
	local new = {}

	for i = 1, #list do
		if i < index or i >= index + count then
			table.insert(new, list[i])
		end
	end

	return new
end

--[[
	Creates a new list that has no occurrences of the given value.
]]
function Immutable.RemoveValueFromList(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

return Immutable
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5468F54A4D6749F5A2F39741F99963C1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Settings</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)

local Category = require(Plugin.Core.Types.Category)
local Sort = require(Plugin.Core.Types.Sort)

local Settings = {}

local SELECTED_BACKGROUND_INDEX_KEY = "SelectedBackgroundIndex"
local SELECTED_CATEGORY_INDEX_KEY = "SelectedCategoryIndex"
local SELECTED_SEARCH_TERM_KEY = "SelectedSearchTerm"
local SELECTED_SORT_INDEX_KEY = "SelectedSortIndex"

function Settings.new(plugin)
	local self = {
		_plugin = plugin,
	}

	setmetatable(self, {
		__index = Settings,
	})

	return self
end

function Settings:_getSetting(setting, default)
	if not self._plugin then
		return default
	end

	local value = self._plugin:GetSetting(setting)

	if DebugFlags.shouldLogSettings() then
		print(("Settings:_getSetting(setting=\"%s\", default=%s) got value = %s"):format(
			tostring(setting),
			type(default) == "string" and "\"" .. tostring(default) .. "\"" or tostring(default),
			type(value) == "string" and "\"" .. tostring(value) .. "\"" or tostring(value)))
	end

	if not value then
		value = default
	end
	return value
end

function Settings:_setSetting(setting, value)
	if not self._plugin then
		return
	end

	if DebugFlags.shouldLogSettings() then
		print(("Settings:_setSetting(setting=\"%s\", value=%s)"):format(
			tostring(setting),
			type(value) == "string" and "\"" .. tostring(value) .. "\"" or tostring(value)))
	end

	self._plugin:SetSetting(setting, value)
end

function Settings:getSelectedBackgroundIndex()
	return self:_getSetting(SELECTED_BACKGROUND_INDEX_KEY, 1)
end

function Settings:setSelectedBackgroundIndex(index)
	return self:_setSetting(SELECTED_BACKGROUND_INDEX_KEY, index)
end

function Settings:getSelectedCategoryIndex()
	return self:_getSetting(SELECTED_CATEGORY_INDEX_KEY, 1)
end

function Settings:setSelectedCategoryIndex(index)
	return self:_setSetting(SELECTED_CATEGORY_INDEX_KEY, index)
end

function Settings:getSelectedSearchTerm()
	return self:_getSetting(SELECTED_SEARCH_TERM_KEY, "")
end

function Settings:setSelectedSearchTerm(searchTerm)
	return self:_setSetting(SELECTED_SEARCH_TERM_KEY, searchTerm)
end

function Settings:getSelectedSortIndex()
	return self:_getSetting(SELECTED_SORT_INDEX_KEY, 1)
end

function Settings:setSelectedSortIndex(index)
	return self:_setSetting(SELECTED_SORT_INDEX_KEY, index)
end

function Settings:updateFromPageInfo(pageInfo)
	if DebugFlags.shouldLogSettings() then
		print("Settings:updateFromPageInfo()")
	end

	self:setSelectedCategoryIndex(pageInfo.categoryIndex)
	self:setSelectedSearchTerm(pageInfo.searchTerm)
	self:setSelectedSortIndex(pageInfo.sortIndex)
	self:setSelectedBackgroundIndex(pageInfo.selectedBackgroundIndex)
end

function Settings:loadInitialSettings()
	if DebugFlags.shouldLogSettings() then
		print("Settings:loadInitialSettings()")
	end

	local settings = {}

	settings.backgroundIndex = self:getSelectedBackgroundIndex()
	settings.categoryIndex = self:getSelectedCategoryIndex()
	settings.searchTerm = self:getSelectedSearchTerm()
	settings.sortIndex = self:getSelectedSortIndex()

	if Category.categoryIsGroupAsset(settings.categoryIndex) then
		settings.categoryIndex = 1
	end

	if game:FindFirstChild("DefaultToolboxSearch") then
		settings.searchTerm = game.DefaultToolboxSearch.Value
		-- Also set the initial category to free models and relevant sort
		settings.categoryIndex = 1
		settings.sortIndex = 1
	end

	if not Sort.canSort(settings.searchTerm, settings.categoryIndex) then
		settings.sortIndex = 1
	end

	return settings
end

return Settings
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXEB65BFA38E5A47249D62C3DADBE9AF23">
					<Properties>
						<string name="Name">Analytics</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX53703CA07705431294F980FC19564E48">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Logs</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local DebugFlags = require(Plugin.Core.Util.DebugFlags)

local Logs = { }

local function sendLog(logString)
	print(("[Toolbox Analytics] %s"):format(tostring(logString)))
end

function Logs.logAnalytics(method, target, context, name, args)
	if not DebugFlags.shouldLogAnalytics() then
		return
	end

	method = method or ""
	target = target or ""
	context = context or ""
	name = name or ""
	args = args or {}

	local argStrings = {}
	for k, v in pairs(args) do
		local key = type(k) == "string" and k or "[" .. tostring(v) .. "]"
		local value = type(v) == "string" and "\"" .. v .. "\"" or tostring(v)
		argStrings[#argStrings + 1] = key .. "=" .. value
	end

	local argsString = table.concat(argStrings, ", ")

	sendLog(("%s(target=\"%s\", eventContext=\"%s\", eventName=\"%s\", additionalArgs={%s})"):format(
		tostring(method), tostring(target), tostring(context), tostring(name), argsString))
end

function Logs.logEvent(method, category, action, label, value)
	if not DebugFlags.shouldLogAnalytics() then
		return
	end

	method = method or ""
	category = category or ""
	action = action or ""
	label = label or ""
	value = value or 0

	sendLog(("%s(category=\"%s\", action=\"%s\", label=\"%s\", value=%s)"):format(
		tostring(method), tostring(category), tostring(action), tostring(label), tostring(value)))
end

function Logs.logCounterEvent(method, counter, amount)
	if not DebugFlags.shouldLogAnalytics() then
		return
	end

	method = method or ""
	counter = counter or ""
	amount = amount or 1

	sendLog(("%s(counter=\"%s\", amount=%s)"):format(
		tostring(method), tostring(counter), tostring(amount)))
end

function Logs.logSendReports(userId)
	if not DebugFlags.shouldLogAnalytics() then
		return
	end

	sendLog(("sendReports(userId=%s)"):format(tostring(userId)))
end

function Logs.logReport(counter, amount, reportValue)
	if not DebugFlags.shouldLogAnalytics() then
		return
	end

	sendLog(("sendReports() counter \"%s\" = %s, reporting total %s"):format(
		tostring(counter), tostring(amount), tostring(reportValue)))
end

return Logs
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7B1C8313E4FD4A25A7EEDF9301B576D1">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Senders</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local AnalyticsLogs = require(Plugin.Core.Util.Analytics.Logs)

local AnalyticsService = game:GetService("AnalyticsService")

local function makeSettingName(counter)
	return "ToolboxAnalytics_" .. counter
end

local counters = {}

local Senders = {}

function Senders.sendEventImmediately(target, context, name, args)
	AnalyticsLogs.logAnalytics("sendEventImmediately", target, context, name, args)
	AnalyticsService:SendEventImmediately(target, context, name, args)
end

function Senders.trackEvent(category, action, label, value)
	AnalyticsLogs.logEvent("trackEvent", category, action, label, value)
	AnalyticsService:TrackEvent(category, action, label, value)
end

function Senders.reportCounter(counter, amount)
	amount = amount or 1
	AnalyticsLogs.logCounterEvent("reportCounter", counter, amount)
	AnalyticsService:ReportCounter(counter, amount)
end

function Senders.incrementCounter(counter, amount)
	amount = amount or 1
	AnalyticsLogs.logCounterEvent("incrementCounter", counter, amount)

	if counters[counter] then
		counters[counter] = counters[counter] + amount
	else
		counters[counter] = amount
	end
end

function Senders.sendReports(plugin)
	local userId = plugin:GetStudioUserId()
	AnalyticsLogs.logSendReports(userId)

	for counter, value in pairs(counters) do
		-- TODO CLIDEVSRVS-1689: In Studio, this gets it from the registry
		-- We can't do that in Lua so using plugin settings instead
		-- This is limited to just this plugin though
		local settingsValue = plugin:GetSetting(makeSettingName(counter)) or 0
		local reportValue = value + settingsValue
		plugin:SetSetting(makeSettingName(counter), reportValue)

		AnalyticsLogs.logReport(counter, value, reportValue)

		counters[counter] = 0

		Senders.trackEvent("UsageFeatures", counter, userId, reportValue)
	end
end

return Senders
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6B2B6A25D85544769F2C931A0CA4DE4E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Analytics</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent.Parent

local AnalyticsSenders = require(Plugin.Core.Util.Analytics.Senders)

local AnalyticsService = game:GetService("AnalyticsService")

-- TODO CLIDEVSRVS-1689: StudioSession + StudioID
local function getStudioSession()
	local sessionId = nil
	pcall(function()
		sessionId = AnalyticsService:GetSessionId()
	end)
	return sessionId
end

local function getStudioId()
	local clientId = nil
	pcall(function()
		clientId = AnalyticsService:GetClientId()
	end)
	return clientId
end

local Analytics = { }

function Analytics.sendReports(plugin)
	AnalyticsSenders.sendReports(plugin)
end

function Analytics.onTermSearched(categoryName, searchTerm)
	AnalyticsSenders.trackEvent("Studio", categoryName, searchTerm)
end

function Analytics.onCategorySelected(oldCategory, newCategory)
	AnalyticsSenders.sendEventImmediately("Studio", "click", "ToolboxCategorySelection", {
		OldCategory = oldCategory,
		NewCategory = newCategory,
		StudioSession = getStudioSession(),
		StudioID = getStudioId(),
	})
end

function Analytics.onAssetInserted(assetId, searchText, assetIndex)
	AnalyticsSenders.sendEventImmediately("Studio", "click", "ToolboxInsert", {
		AssetId = assetId,
		SearchText = searchText,
		AssetIndex = assetIndex,
		StudioSession = getStudioSession(),
		StudioID = getStudioId(),
	})
end

function Analytics.onAssetDragInserted(assetId, searchText, assetIndex)
	-- TODO CLIDEVSRVS-1689: Is "toolboxInsert" lowerCase or not?
	AnalyticsSenders.sendEventImmediately("Studio", "drag", "toolboxInsert", {
		AssetId = assetId,
		SearchText = searchText,
		AssetIndex = assetIndex,
		StudioSession = getStudioSession(),
		StudioID = getStudioId(),
	})
end

function Analytics.onAssetInsertRemains(contentId)
	AnalyticsSenders.trackEvent("Studio", "StudioInsertRemains", contentId)
end

function Analytics.onAssetInsertDeleted(contentId)
	AnalyticsSenders.trackEvent("Studio", "StudioInsertDeleted", contentId)
end

function Analytics.trackEventAssetInsert(assetId)
	AnalyticsSenders.trackEvent("Action", "Insert", assetId)
end

function Analytics.incrementAssetInsertCollector()
	AnalyticsSenders.incrementCounter("Inserts")
end

function Analytics.incrementToolboxInsertCounter(assetTypeId)
	AnalyticsSenders.reportCounter(("Studio.ToolboxInsert.%s"):format(tostring(assetTypeId)))
end

function Analytics.incrementWorkspaceInsertCounter()
	AnalyticsSenders.reportCounter("StudioWorkspaceInsertCounter")
end

function Analytics.onSoundInserted()
	AnalyticsSenders.trackEvent("Studio", "Toolbox", "Inserted sound")
end

function Analytics.onSoundPlayed()
	AnalyticsSenders.trackEvent("Studio", "Toolbox", "Played sound")
end

function Analytics.onSoundPaused()
	AnalyticsSenders.trackEvent("Studio", "Toolbox", "Paused sound")
end

function Analytics.onSoundPlayedCounter()
	AnalyticsSenders.reportCounter("Studio.ToolboxAudio.Played")
end

function Analytics.onSoundPausedCounter()
	AnalyticsSenders.reportCounter("Studio.ToolboxAudio.Paused")
end

return Analytics
]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX5949FAB2CE294191AB4EBE619E9A72B3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Urls</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Url = require(Plugin.Libs.Http.Url)

local wrapStrictTable = require(Plugin.Core.Util.wrapStrictTable)

local Urls = {}

local GET_ASSETS = Url.BASE_URL .. "IDE/Toolbox/Items?"
local POST_VOTE = Url.BASE_URL .. "voting/vote"
local INSERT_ASSET = Url.BASE_URL .. "IDE/Toolbox/InsertAsset?"
local GET_MANAGEABLE_GROUPS = Url.BASE_URL .. "groups/can-manage-games"

local ASSET_ID_STRING = "rbxassetid://%d"
local ASSET_ID_PATH = "asset/?"
local ASSET_ID = Url.BASE_URL .. ASSET_ID_PATH
local ASSET_GAME_ASSET_ID = Url.GAME_ASSET_URL .. ASSET_ID_PATH

local ASSET_THUMBNAIL = Url.GAME_ASSET_URL .. "asset-thumbnail/image?"

function Urls.constructGetAssetsUrl(category, searchTerm, pageSize, page, sortType, groupId)
	return GET_ASSETS .. Url.makeQueryString({
		category = category,
		keyword = searchTerm,
		num = pageSize,
		page = page,
		sort = sortType,
		groupId = groupId,
	})
end

function Urls.constructPostVoteUrl()
	return POST_VOTE
end

function Urls.constructInsertAssetUrl(assetId)
	return INSERT_ASSET .. Url.makeQueryString({
		assetId = assetId
	})
end

function Urls.constructGetManageableGroupsUrl()
	return GET_MANAGEABLE_GROUPS
end

function Urls.constructAssetIdString(assetId)
	return ASSET_ID_STRING:format(assetId)
end

function Urls.constructAssetIdUrl(assetId)
	return ASSET_ID .. Url.makeQueryString({
		id = assetId,
	})
end

function Urls.constructAssetGameAssetIdUrl(assetId, assetTypeId)
	return ASSET_GAME_ASSET_ID
		.. Url.makeQueryString({
			id = assetId,
		})
		.. "#"
		.. Url.makeQueryString({
			assetTypeId = assetTypeId,
		})
end

function Urls.constructAssetThumbnailUrl(assetId, width, height)
	-- The URL only accepts certain sizes for thumbnails. This includes 50, 75, 100, 150, 250, 420 etc.
	local DEFAULT_ASSET_SIZE = 100
	width = width or DEFAULT_ASSET_SIZE
	height = height or DEFAULT_ASSET_SIZE

	return ASSET_THUMBNAIL .. Url.makeQueryString({
		assetId = assetId,
		width = width,
		height = height,
	})
end

return wrapStrictTable(Urls)
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX214C0A847AFF46D0997F635FD6DF5C87">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Immutable.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Immutable = require(Plugin.Core.Util.Immutable)

	describe("JoinDictionaries", function()
		it("should preserve immutability", function()
			local a = {}
			local b = {}

			local c = Immutable.JoinDictionaries(a, b)

			expect(c).never.to.equal(a)
			expect(c).never.to.equal(b)
		end)

		it("should treat list-like values like dictionary values", function()
			local a = {
				[1] = 1,
				[2] = 2,
				[3] = 3
			}

			local b = {
				[1] = 11,
				[2] = 22
			}

			local c = Immutable.JoinDictionaries(a, b)

			expect(c[1]).to.equal(b[1])
			expect(c[2]).to.equal(b[2])
			expect(c[3]).to.equal(a[3])
		end)

		it("should merge dictionary values correctly", function()
			local a = {
				hello = "world",
				foo = "bar"
			}

			local b = {
				foo = "baz",
				tux = "penguin"
			}

			local c = Immutable.JoinDictionaries(a, b)

			expect(c.hello).to.equal(a.hello)
			expect(c.foo).to.equal(b.foo)
			expect(c.tux).to.equal(b.tux)
		end)

		it("should merge multiple dictionaries", function()
			local a = {
				foo = "yes"
			}

			local b = {
				bar = "yup"
			}

			local c = {
				baz = "sure"
			}

			local d = Immutable.JoinDictionaries(a, b, c)

			expect(d.foo).to.equal(a.foo)
			expect(d.bar).to.equal(b.bar)
			expect(d.baz).to.equal(c.baz)
		end)
	end)

	describe("JoinLists", function()
		it("should preserve immutability", function()
			local a = {}
			local b = {}

			local c = Immutable.JoinLists(a, b)

			expect(c).never.to.equal(a)
			expect(c).never.to.equal(b)
		end)

		it("should treat list-like values correctly", function()
			local a = {1, 2, 3}
			local b = {4, 5, 6}

			local c = Immutable.JoinLists(a, b)

			expect(#c).to.equal(6)

			for i = 1, #c do
				expect(c[i]).to.equal(i)
			end
		end)

		it("should merge multiple lists", function()
			local a = {1, 2}
			local b = {3, 4}
			local c = {5, 6}

			local d = Immutable.JoinLists(a, b, c)

			expect(#d).to.equal(6)

			for i = 1, #d do
				expect(d[i]).to.equal(i)
			end
		end)
	end)

	describe("Set", function()
		it("should preserve immutability", function()
			local a = {}

			local b = Immutable.Set(a, "foo", "bar")

			expect(b).never.to.equal(a)
		end)

		it("should treat numeric keys normally", function()
			local a = {1, 2, 3}

			local b = Immutable.Set(a, 2, 4)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(4)
			expect(b[3]).to.equal(3)
		end)

		it("should overwrite dictionary-like keys", function()
			local a = {
				foo = "bar",
				baz = "qux"
			}

			local b = Immutable.Set(a, "foo", "hello there")

			expect(b.foo).to.equal("hello there")
			expect(b.baz).to.equal(a.baz)
		end)
	end)

	describe("Append", function()
		it("should preserve immutability", function()
			local a = {}

			local b = Immutable.Append(a, "another happy landing")

			expect(b).never.to.equal(a)
		end)

		it("should append values", function()
			local a = {1, 2, 3}
			local b = Immutable.Append(a, 4, 5)

			expect(#b).to.equal(5)

			for i = 1, #b do
				expect(b[i]).to.equal(i)
			end
		end)
	end)

	describe("RemoveFromDictionary", function()
		it("should preserve immutability", function()
			local a = { foo = "bar" }

			local b = Immutable.RemoveFromDictionary(a, "foo")

			expect(b).to.never.equal(a)
		end)

		it("should remove fields from the dictionary", function()
			local a = {
				foo = "bar",
				baz = "qux",
				boof = "garply",
			}

			local b = Immutable.RemoveFromDictionary(a, "foo", "boof")

			expect(b.foo).to.never.be.ok()
			expect(b.baz).to.equal("qux")
			expect(b.boof).to.never.be.ok()
		end)
	end)

	describe("RemoveFromList", function()
		it("should preserve immutability", function()
			local a = {1, 2, 3}
			local b = Immutable.RemoveFromList(a, 2)

			expect(b).never.to.equal(a)
		end)

		it("should remove elements from the list", function()
			local a = {1, 2, 3}
			local b = Immutable.RemoveFromList(a, 2)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(3)
			expect(b[3]).never.to.be.ok()
		end)
	end)

	describe("RemoveRangeFromList", function()
		it("should preserve immutability", function()
			local a = {1, 2, 3}
			local b = Immutable.RemoveRangeFromList(a, 2, 1)

			expect(b).never.to.equal(a)
		end)

		it("should remove elements properly from the list", function()
			local a = {1, 2, 3}
			local b = Immutable.RemoveRangeFromList(a, 2, 1)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(3)
			expect(b[3]).never.to.be.ok()
		end)

		it("should remove elements properly from the list", function()
			local a = {1, 2, 3, 4, 5, 6}
			local b = Immutable.RemoveRangeFromList(a, 1, 4)

			expect(b[1]).to.equal(5)
			expect(b[2]).to.equal(6)
			expect(b[3]).never.to.be.ok()
		end)

		it("should remove elements properly from the list", function()
			local a = {1, 2, 3, 4, 5, 6}
			local b = Immutable.RemoveRangeFromList(a, 2, 4)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(6)
			expect(b[3]).never.to.be.ok()
		end)

		it("should remove elements properly from the list", function()
			local a = {1, 2, 3, 4, 5, 6, 7}
			local b = Immutable.RemoveRangeFromList(a, 4, 4)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(2)
			expect(b[3]).to.equal(3)
			expect(b[4]).never.to.be.ok()
		end)

		it("should not remove any elements when count is 0 or less", function()
			local a = {1, 2, 3}
			local b = Immutable.RemoveRangeFromList(a, 2, 0)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(2)
			expect(b[3]).to.equal(3)

			local c = Immutable.RemoveRangeFromList(a, 2, -1)
			expect(c[1]).to.equal(1)
			expect(c[2]).to.equal(2)
			expect(c[3]).to.equal(3)
		end)
	end)

	describe("RemoveValueFromList", function()
		it("should preserve immutability", function()
			local a = {1, 1, 1}
			local b = Immutable.RemoveValueFromList(a, 1)

			expect(b).never.to.equal(a)
		end)

		it("should remove all elements from the list", function()
			local a = {1, 2, 2, 3}
			local b = Immutable.RemoveValueFromList(a, 2)

			expect(b[1]).to.equal(1)
			expect(b[2]).to.equal(3)
			expect(b[3]).never.to.be.ok()
		end)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX171983C28BC04B3CBD687CF055011121">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DebugFlags</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Workspace = game:GetService("Workspace")

local function getDebugFlagValue(flagName)
	local val = Workspace:FindFirstChild(flagName)
	if val then
		return val.Value
	end
	return false
end

local DebugFlags = {}

function DebugFlags.shouldRunTests()
	return getDebugFlagValue("RunToolboxTests")
end

function DebugFlags.shouldDisableTooltips()
	return getDebugFlagValue("ToolboxDisableTooltips")
end

function DebugFlags.shouldDebugUrls()
	return getDebugFlagValue("ToolboxDebugUrls")
end

function DebugFlags.shouldDebugState()
	return getDebugFlagValue("ToolboxDebugState")
end

function DebugFlags.shouldLogAnalytics()
	return getDebugFlagValue("ToolboxLogAnalytics")
end

function DebugFlags.shouldDebugWarnings()
	return getDebugFlagValue("ToolboxDebugWarnings")
end

function DebugFlags.shouldLogSettings()
	return getDebugFlagValue("ToolboxLogSettings")
end

return DebugFlags
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF1CE0CAA9B7C46EDA9310F6D9418AF6C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MockWrapper</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local CorePackages = game:GetService("CorePackages")
local Roact = require(CorePackages.Roact)
local Rodux = require(CorePackages.Rodux)

local Settings = require(Plugin.Core.Util.Settings)
local ToolboxTheme = require(Plugin.Core.Util.ToolboxTheme)

local ToolboxReducerMock = require(Plugin.Core.Reducers.ToolboxReducerMock)
local NetworkInterfaceMock = require(Plugin.Core.Networking.NetworkInterfaceMock)

local ExternalServicesWrapper = require(Plugin.Core.Components.ExternalServicesWrapper)

local function MockWrapper(props)
	local store = props.store or Rodux.Store.new(ToolboxReducerMock, nil, {
		Rodux.thunkMiddleware
	})
	local plugin = props.plugin or nil
	local pluginGui = props.pluginGui or nil
	local settings = props.settings or Settings.new(plugin)
	local theme = props.theme or ToolboxTheme.createDummyThemeManager()
	local networkInterface = props.networkInterface or NetworkInterfaceMock.new()

	return Roact.createElement(ExternalServicesWrapper, {
		store = store,
		plugin = plugin,
		pluginGui = pluginGui,
		settings = settings,
		theme = theme,
		networkInterface = networkInterface,
	}, props[Roact.Children])
end

return MockWrapper
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX05EF9B775D1B404A982A5CC39139D109">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Constants</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local wrapStrictTable = require(Plugin.Core.Util.wrapStrictTable)

local TextService = game:GetService("TextService")

local Constants = {}

Constants.TOOLTIP_LINE_HEIGHT = 1.3
Constants.TOOLTIP_PADDING = 3
Constants.TOOLTIP_TEXT_SIZE = 12
Constants.TOOLTIP_SHOW_UP_DELAY = 0.3

Constants.FONT = Enum.Font.SourceSans
Constants.FONT_BOLD = Enum.Font.SourceSansBold
Constants.FONT_SIZE_SMALL = 14
Constants.FONT_SIZE_MEDIUM = 16
Constants.FONT_SIZE_LARGE = 18


function Constants.getTextSize(text, fontSize, font, frameSize)
	fontSize = fontSize or Constants.FONT_SIZE_MEDIUM
	font = font or Constants.FONT
	frameSize = frameSize or Vector2.new(0, 0)

	return TextService:GetTextSize(text, fontSize, font, frameSize)
end

Constants.ROUNDED_FRAME_SLICE = Rect.new(3, 3, 13, 13)


Constants.SCROLLBAR_THICKNESS = 8
Constants.SCROLLBAR_PADDING = 2
Constants.SCROLLBAR_BACKGROUND_THICKNESS = Constants.SCROLLBAR_THICKNESS + (2 * Constants.SCROLLBAR_PADDING)

Constants.THUMB_ICON_HEIGHT = 21
Constants.THUMB_ICON_WIDTH = 21

Constants.DROP_SHADOW_IMAGE_SIZE = 16
Constants.DROP_SHADOW_IMAGE_SLICE_0 = 8
Constants.DROP_SHADOW_IMAGE_SLICE_1 = Constants.DROP_SHADOW_IMAGE_SIZE - Constants.DROP_SHADOW_IMAGE_SLICE_0
Constants.DROP_SHADOW_SLICE_CENTER = Rect.new(
	Constants.DROP_SHADOW_IMAGE_SLICE_0,
	Constants.DROP_SHADOW_IMAGE_SLICE_0,
	Constants.DROP_SHADOW_IMAGE_SLICE_1,
	Constants.DROP_SHADOW_IMAGE_SLICE_1)
Constants.DROP_SHADOW_TRANSPARENCY = 0.8
Constants.DROP_SHADOW_SIZE = 8
Constants.DROP_SHADOW_COLOR = Color3.fromRGB(0, 0, 0)

Constants.DEFAULT_PADDING = 8

Constants.DROPDOWN_WIDTH = 120
Constants.DROPDOWN_HEIGHT = 25

Constants.DROPDOWN_SELECTED_BAR = 5
Constants.DROPDOWN_TEXT_INSET = 3
Constants.DROPDOWN_ICON_SIZE = 12
Constants.DROPDOWN_ICON_FROM_RIGHT = 4

Constants.HEADER_HEIGHT = 43

Constants.HEADER_OUTER_PADDING = (Constants.HEADER_HEIGHT - Constants.DROPDOWN_HEIGHT) / 2 -- 9
Constants.HEADER_INNER_PADDING = 7
Constants.HEADER_CATEGORY_DROPDOWN_WIDTH = Constants.DROPDOWN_WIDTH

Constants.FOOTER_HEIGHT = 35

Constants.BACKGROUND_ICON_SIZE = 10

Constants.MAIN_VIEW_PADDING = 8

Constants.SUGGESTIONS_INNER_PADDING = 6
Constants.SUGGESTIONS_OUTER_PADDING = 6
Constants.SUGGESTIONS_FONT_SIZE = Constants.FONT_SIZE_MEDIUM
Constants.SUGGESTIONS_ROW_HEIGHT = Constants.SUGGESTIONS_FONT_SIZE + 4
Constants.SUGGESTIONS_ROW_PADDING = 2
Constants.SUGGESTIONS_INTRO_TEXT = "Try searching for:"


Constants.SORT_COMPONENT_INNER_PADDING = 6
Constants.SORT_COMPONENT_OUTER_PADDING = 8
Constants.SORT_COMPONENT_CATEGORY_DROPDOWN_WIDTH = Constants.DROPDOWN_WIDTH
Constants.SORT_COMPONENT_HEIGHT = Constants.DROPDOWN_HEIGHT + 2 * Constants.SORT_COMPONENT_OUTER_PADDING

Constants.MAIN_VIEW_VERTICAL_PADDING = Constants.MAIN_VIEW_PADDING

Constants.TIME_BETWEEN_ASSET_INSERTION = 0.3

Constants.ASSET_WIDTH = 75
Constants.ASSET_INNER_PADDING = 4

Constants.ASSET_THUMBNAIL_SIZE = Constants.ASSET_WIDTH
Constants.ASSET_THUMBNAIL_REQUESTED_IMAGE_SIZE = 75 -- The endpoint only accepts certain sizes for thumbnails
Constants.ASSET_ENDORSED_BADGE_ICON_SIZE = 20

Constants.ASSET_PLAY_AUDIO_ICON_SIZE = 28

Constants.ASSET_NAME_FONT_SIZE = Constants.FONT_SIZE_MEDIUM
Constants.ASSET_NAME_HEIGHT = Constants.ASSET_NAME_FONT_SIZE * 2 -- The asset name is 2 rows tall

Constants.ASSET_CREATOR_NAME_FONT_SIZE = Constants.FONT_SIZE_SMALL
Constants.ASSET_CREATOR_NAME_HEIGHT = Constants.ASSET_CREATOR_NAME_FONT_SIZE

Constants.ASSET_VOTE_BAR_HEIGHT = 5
Constants.ASSET_VOTE_BAR_OUTER_HEIGHT = 13
Constants.ASSET_VOTE_COUNT_FONT_SIZE = Constants.FONT_SIZE_SMALL
Constants.ASSET_VOTE_COUNT_HEIGHT = Constants.ASSET_VOTE_COUNT_FONT_SIZE
Constants.ASSET_VOTING_HEIGHT = Constants.ASSET_VOTE_BAR_OUTER_HEIGHT + Constants.ASSET_VOTE_COUNT_HEIGHT

Constants.ASSET_HEIGHT = Constants.ASSET_THUMBNAIL_SIZE + Constants.ASSET_INNER_PADDING
	+ Constants.ASSET_NAME_HEIGHT

Constants.ASSET_OUTLINE_HOVERED_TRANSPARENCY = 0.08
Constants.ASSET_OUTLINE_PADDING = 8
Constants.ASSET_OUTLINE_EXTRA_HEIGHT = Constants.ASSET_CREATOR_NAME_HEIGHT
	+ Constants.ASSET_INNER_PADDING + (2 * Constants.ASSET_OUTLINE_PADDING)
Constants.ASSET_OUTLINE_EXTRA_HEIGHT_WITH_VOTING = Constants.ASSET_OUTLINE_EXTRA_HEIGHT + Constants.ASSET_VOTING_HEIGHT
	+ Constants.ASSET_INNER_PADDING

Constants.BETWEEN_ASSETS_HORIZONTAL_PADDING = 8
Constants.BETWEEN_ASSETS_VERTICAL_PADDING = 16

-- Calculate the exact width needed to display MIN_ASSETS_PER_ROW
Constants.MIN_ASSETS_PER_ROW = 3
Constants.MIN_WIDTH_EXTRA_PADDING = 4
Constants.TOOLBOX_MIN_WIDTH = (Constants.MAIN_VIEW_PADDING * 2)
	+ (Constants.MIN_ASSETS_PER_ROW * (Constants.ASSET_WIDTH + Constants.BETWEEN_ASSETS_HORIZONTAL_PADDING))
	- Constants.BETWEEN_ASSETS_HORIZONTAL_PADDING
	+ Constants.SCROLLBAR_BACKGROUND_THICKNESS + Constants.SCROLLBAR_PADDING
	+ (Constants.MIN_WIDTH_EXTRA_PADDING * 2)
Constants.TOOLBOX_MIN_HEIGHT = 200

Constants.DIST_FROM_BOTTOM_BEFORE_NEXT_PAGE = Constants.ASSET_HEIGHT * 1.2

Constants.DEFAULT_TOOLTIP_WIDTH = 100

Constants.SCROLLING_FRAME_VIEW_PADDING = 16

Constants.GET_ITEMS_PAGE_SIZE = 30

Constants.ENDORSED_BADGE_TOOLTIP_TEXT = "Marked as a high-quality item"

Constants.SEARCH_BAR_BUTTON_ICON_SIZE = 14
Constants.SEARCH_BAR_BUTTON_WIDTH = 28
Constants.SEARCH_BAR_BUTTON_INSET = 2

Constants.INFO_BANNER_PADDING = 12

Constants.TOOLTIP_TYPE = {
	ASSET_ICON = 1,
	ASSET_NAME = 2,
	CREATOR_NAME = 3,
	HIGH_QUALITY_BADGE = 4,
}

return wrapStrictTable(Constants, "Constants")
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC7260DAA0E9D4879B91A322E1D6526A7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AssetInsertionTracker</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Analytics = require(Plugin.Core.Util.Analytics.Analytics)

local function getAssetInsertDeletionCheckTime()
	return (settings():GetFVariable("StudioInsertDeletionCheckTimeMS") or 8000) / 1000
end

local AssetInsertionTracker = {}

function AssetInsertionTracker.trackInsert(assetId, asset)
	if type(asset) == "table" then
		for _, a in ipairs(asset) do
			AssetInsertionTracker.trackInsert(assetId, a)
		end
		return
	end

	delay(getAssetInsertDeletionCheckTime(), function()
		if not asset or not asset.Parent then
			Analytics.onAssetInsertDeleted(assetId)
		else
			Analytics.onAssetInsertRemains(assetId)
		end

	end)
end

return AssetInsertionTracker
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX1FDC1695F6D946A0AC703BA90D463489">
			<Properties>
				<string name="Name">Libs</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX26F4413F44A345C7A867A2D9AEBB3D51">
				<Properties>
					<string name="Name">Http</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX6AC63B478E324309810A4B173972D23F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Url.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()

	local ContentProvider = game:GetService("ContentProvider")
	local Url = require(script.Parent.Url)

	it("The base url has not been changed for debugging", function()
		local baseUrl = ContentProvider.BaseUrl

		expect(baseUrl).to.equal(Url.BASE_URL)
	end)

end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX57B772D83A474036B942E79E8AFC1F8F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Promise.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Promise = require(script.Parent.Promise)

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise._status).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise._status).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise._status).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise._status).to.equal(Promise.Status.Rejected)
			expect(promise._value[1]:find("hahah")).to.be.ok()
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Resolved)
			expect(promise._value[1]).to.equal(5)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Rejected)
			expect(promise._value[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Rejected)
			expect(promise._value[1]).to.equal(6)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Rejected)
			expect(promise._value[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise
				:andThen(function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end, function()
					badCallCount = badCallCount + 1
				end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Resolved)
			expect(promise._value[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained._status).to.equal(Promise.Status.Resolved)
			expect(#chained._value).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise
				:andThen(function(...)
					badCallCount = badCallCount + 1
				end, function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Rejected)
			expect(promise._value[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained._status).to.equal(Promise.Status.Resolved)
			expect(#chained._value).to.equal(0)
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise
				:andThen(function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end, function()
					badCallCount = badCallCount + 1
				end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Resolved)
			expect(promise._value[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained._status).to.equal(Promise.Status.Resolved)
			expect(#chained._value).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise
				:andThen(function()
					badCallCount = badCallCount + 1
				end, function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise._status).to.equal(Promise.Status.Rejected)
			expect(promise._value[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained._status).to.equal(Promise.Status.Resolved)
			expect(#chained._value).to.equal(0)
		end)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD2F23B7268C64B59A78816ADC168D821">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TableUtilities</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Provides functions for comparing and printing lua tables.
]]

local TableUtilities = {}
local defaultIgnore = {}

--[[
	Takes two tables A and B, returns if they have the same key-value pairs
	Except ignored keys
]]
function TableUtilities.ShallowEqual(A, B, ignore)
	if not A or not B then
		return false
	elseif A == B then
		return true
	end

	if not ignore then
		ignore = defaultIgnore
	end

	for key, value in pairs(A) do
		if B[key] ~= value and not ignore[key] then
			return false
		end
	end
	for key, value in pairs(B) do
		if A[key] ~= value and not ignore[key] then
			return false
		end
	end

	return true
end

--[[
	Takes two tables A, B and a key, returns if two tables have the same value at key
]]
function TableUtilities.EqualKey(A, B, key)
	if A and B and key and key ~= "" and A[key] and B[key] and A[key] == B[key] then
		return true
	end
	return false
end

--[[
	Takes two tables A and B, returns a new table with elements of A
	which are either not keys in B or have a different value in B
]]
function TableUtilities.TableDifference(A, B)
	local new = {}

	for key, value in pairs(A) do
		if B[key] ~= A[key] then
			new[key] = value
		end
	end

	return new
end


--[[
	Takes a list and returns a table whose
	keys are elements of the list and whose
	values are all true
]]
local function membershipTable(list)
	local result = {}
	for i = 1, #list do
		result[list[i]] = true
	end
	return result
end


--[[
	Takes a table and returns a list of keys in that table
]]
local function listOfKeys(t)
	local result = {}
	for key,_ in pairs(t) do
		table.insert(result, key)
	end
	return result
end


--[[
	Takes two lists A and B, returns a new list of elements of A
	which are not in B
]]
function TableUtilities.ListDifference(A, B)
	return listOfKeys(TableUtilities.TableDifference(membershipTable(A), membershipTable(B)))
end


--[[
	For debugging.  Returns false if the given table has any of the following:
		- a key that is neither a number or a string
		- a mix of number and string keys
		- number keys which are not exactly 1..#t
]]
function TableUtilities.CheckListConsistency(t)
	local containsNumberKey = false
	local containsStringKey = false
	local numberConsistency = true

	local index = 1
	for x, _ in pairs(t) do
		if type(x) == 'string' then
			containsStringKey = true
		elseif type(x) == 'number' then
			if index ~= x then
				numberConsistency = false
			end
			containsNumberKey = true
		else
			return false
		end

		if containsStringKey and containsNumberKey then
			return false
		end

		index = index + 1
	end

	if containsNumberKey then
		return numberConsistency
	end

	return true
end


--[[
	For debugging, serializes the given table to a reasonable string that might even interpret as lua.
]]
function TableUtilities.RecursiveToString(t, indent)
	indent = indent or ''

	if type(t) == 'table' then
		local result = ""
		if not TableUtilities.CheckListConsistency(t) then
			result = result .. "-- WARNING: this table fails the list consistency test\n"
		end
		result = result .. "{\n"
		for k,v in pairs(t) do
			if type(k) == 'string' then
				result = result
					.. "  "
					.. indent
					.. tostring(k)
					.. " = "
					.. TableUtilities.RecursiveToString(v, "  "..indent)
					..";\n"
			end
			if type(k) == 'number' then
				result = result .. "  " .. indent .. TableUtilities.RecursiveToString(v, "  "..indent)..",\n"
			end
		end
		result = result .. indent .. "}"
		return result
	else
		return tostring(t)
	end
end


return TableUtilities

]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX190A533B465A48C4A75B28DA5862CBD9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HttpResponse.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local HttpResponse = require(script.Parent.HttpResponse)
	local StatusCode = require(script.Parent.StatusCodes)

	describe(".new()", function()
		it("should construct without a problem", function()
			expect(function()
				local _ = HttpResponse.new("", 0, StatusCode.OK)
			end).never.to.throw()
		end)

		it("should just pass data through", function()
			local testBody = ""
			local testTime = 203
			local testCode = StatusCode.OK

			local response = HttpResponse.new(testBody, testTime, testCode)

			expect(response.responseBody).to.equal(testBody)
			expect(response.responseTimeMs).to.equal(testTime)
			expect(response.responseCode).to.equal(testCode)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX49837B7DE448426397BEBB57D18D70EA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Promise</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]
local TU = require(script.Parent.TableUtilities)

local PROMISE_DEBUG = true

-- If promise debugging is on, use a version of pcall that warns on failure.
-- This is useful for finding errors that happen within Promise itself.
local wpcall
if PROMISE_DEBUG then
	wpcall = function(f, ...)
		local result = { pcall(f, ...) }

		if not result[1] then
			warn(result[2])
		end

		return unpack(result)
	end
else
	wpcall = pcall
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local result = { wpcall(callback, ...) }
		local ok = table.remove(result, 1)

		if ok then
			resolve(unpack(result))
		else
			reject(unpack(result))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {}
Promise.__index = Promise

Promise.Status = {
	Started = "Started",
	Resolved = "Resolved",
	Rejected = "Rejected",
}

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	For example:

		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end

		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)
]]
function Promise.new(callback)
	local promise = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		_type = "Promise",

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_value = nil,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
	}

	setmetatable(promise, Promise)

	local function resolve(...)
		promise:_resolve(...)
	end

	local function reject(...)
		promise:_reject(...)
	end

	local ok, err = wpcall(callback, resolve, reject)

	if not ok and promise._status == Promise.Status.Started then
		reject(err)
	end

	return promise
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(...)
	local promises = {...}

	-- check if we've been given a list of promises, not just a variable number of promises
	if type(promises[1]) == "table" and promises[1]._type ~= "Promise" then
		-- we've been given a table of promises already
		promises = promises[1]
	end

	return Promise.new(function(resolve, reject)
		local isResolved = false
		local results = {}
		local totalCompleted = 0
		local function promiseCompleted(index, result)
			if isResolved then
				return
			end

			table.insert(results, index, result)
			totalCompleted = totalCompleted + 1

			if totalCompleted == #promises then
				resolve(results)
				isResolved = true
			end
		end

		for index, promise in ipairs(promises) do
			-- if a promise isn't resolved yet, add listeners for when it does
			if promise._status == Promise.Status.Started then
				promise:andThen(function(result)
					promiseCompleted(index, result)
				end):catch(function(reason)
					isResolved = true
					reject(reason)
				end)

			-- if a promise is already resolved, move on
			elseif promise._status == Promise.Status.Resolved then
				promiseCompleted(index, promise._value)

			-- if a promise is rejected, reject the whole chain
			else --if promise._status == Promise.Status.Rejected then
				isResolved = true
				reject(promise._value)
			end
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object._type == "Promise"
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise:andThen(successHandler, failureHandler)
	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._value))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._value))
		end
	end)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise:await()
	if self._status == Promise.Status.Started then
		local result
		local bindable = Instance.new("BindableEvent")

		self:andThen(function(...)
			result = {...}
			bindable:Fire(true)
		end, function(...)
			result = {...}
			bindable:Fire(false)
		end)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		if not ok then
			error(tostring(result[1]), 2)
		end

		return unpack(result)
	elseif self._status == Promise.Status.Resolved then
		return unpack(self._value)
	elseif self._status == Promise.Status.Rejected then
		error(tostring(self._value[1]), 2)
	end
end

function Promise:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = ("When returning a Promise from andThen, extra arguments are discarded! See:\n\n%s"):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(function(...)
			self:_resolve(...)
		end, function(...)
			self:_reject(...)
		end)

		return
	end

	self._status = Promise.Status.Resolved
	self._value = {...}

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end
end

function Promise:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._value = {...}

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
			TU.RecursiveToString((...)),
			self._source
		)
		warn(message)
	end
end

return Promise
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX088C49F7CD054C82AB9D911942FD3E5C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Networking</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Networking

	Provides a re-usable implementation for network requests and other utilities
]]--
local Promise = require(script.Parent.Promise)
local HttpResponse = require(script.Parent.HttpResponse)
local StatusCodes = require(script.Parent.StatusCodes)

local HttpService = game:GetService("HttpService")
local HttpRbxApiService = game:GetService("HttpRbxApiService")


-- helper functions
local function getHttpStatus(response)
	-- NOTE, this function expects to parse a response like this:
	-- HTTP 404 (HTTP/1.1 404 Not Found)

	for _, code in pairs(StatusCodes) do
		if code >= 100 and response:find(tostring(code)) then
			return code
		end
	end

	if response:find("2%d%d") then
		return StatusCodes.OK
	end

	if response:find("curl_easy_perform") and response:find("SSL") then
		return StatusCodes.BAD_TLS
	end

	return StatusCodes.UNKNOWN_ERROR
end


-- requestType : (string) "GET" or "POST"
-- httpAction : (function) a function that wraps the httpRequest
-- RETURNS : (HttpResponse) object containing information about the request
local function baseHttpHandler(requestType, url, httpAction)
	-- this function handles the actual network request and any and all additional
	-- business logic around the request.

	-- time how long the request takes to complete
	local startTime = tick()

	-- fetch the raw response from the server
	-- NOTE - this pcall will prevent the server from throwing errors on a 404 or other server problem
	local success, responseString = pcall(httpAction)
	local endTime = tick()

	-- package information about the response into a single object
	local responseTimeMs = (endTime - startTime) * 1000
	local statusCode = StatusCodes.OK
	if not success then
		statusCode = getHttpStatus(responseString)
	end

	return HttpResponse.new(responseString, responseTimeMs, statusCode, requestType, url)
end

-- httpImpl : (Service) an object that defines HttpGetAsync
-- url : (string)
local function httpGet(httpImpl, url)
	return baseHttpHandler("GET", url, function()
		return httpImpl:GetAsyncFullUrl(url)
	end)
end

-- httpImpl : (Service) an object that defines HttpPostAsync
-- url : (string)
-- payload : (string)
-- contentType : (string)
local function httpPost(httpImpl, url, payload, contentType)
	if not contentType then
		contentType = Enum.HttpContentType.ApplicationJson
	end

	return baseHttpHandler("POST", url, function()
		return httpImpl:PostAsyncFullUrl(url, payload, Enum.ThrottlingPriority.Default, contentType)
	end)
end

-- httpFunc : (function) one of the http functions defined above, like httpGet, or httpPost
-- ... : arguments to pass into the httpFunc
local function createHttpPromise(httpFunc, ...)
	-- make a promise to track the progress of a network request
	local args = {...}
	local httpPromise = Promise.new(function(resolve, reject)
		-- begin fetching the response from the server
		-- NOTE - the http function will yield the thread, so spawn a new one
		spawn(function()
			local httpResponse = httpFunc(unpack(args))

			if httpResponse.responseCode == StatusCodes.OK then
				resolve(httpResponse)
			else
				reject(httpResponse)
			end
		end)
	end)

	-- return the promise so people can patiently wait
	return httpPromise
end

-- TO DO:
-- add logic for RetryGet and RetryPost to automatically poll an endpoint for a proper response



-- public api
local Networking = {}
Networking.__index = Networking

function Networking.new()
	-- _httpImpl - (Service) something that implements HttpGetAsync, and HttpPostAsync
	local networkObj = {
		_httpImpl = HttpRbxApiService
	}
	setmetatable(networkObj, Networking)

	return networkObj
end

-- Response parsing utility functions
function Networking:jsonEncode(data)
	return HttpService:JSONEncode(data)
end

function Networking:jsonDecode(data)
	return HttpService:JSONDecode(data)
end


-- Http request functions

-- url : (string)
-- returns a Promise that resolves to an HttpResponse object
function Networking:httpGetJson(url)
	return createHttpPromise(httpGet, self._httpImpl, url):andThen(
		function(result)
			if result.responseCode == StatusCodes.OK then
				result.responseBody = self:jsonDecode(result.responseBody)
			end

			return result
		end)
end

-- url : (string)
-- payload : (string)
-- returns a Promise that resolves to an HttpResponse object
function Networking:httpPostJson(url, payload)
	return createHttpPromise(httpPost, self._httpImpl, url, payload):andThen(
		function(result)
			if result.responseCode == StatusCodes.OK then
				result.responseBody = self:jsonDecode(result.responseBody)
			end

			return result
		end)
end

-- url : (string)
-- payload : (string)
-- returns a Promise that resolves to an HttpResponse object
function Networking:httpPost(url, payload)
	return createHttpPromise(httpPost, self._httpImpl, url, payload)
end

return Networking
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX56E625131DE0459AB3B05815F0686293">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Url</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Url Constructor

	Provides a single location for base urls.
]]

local ContentProvider = game:GetService("ContentProvider")

-- helper functions
local function parseBaseUrlInformation()
	-- get the current base url from the current configuration
	local baseUrl = ContentProvider.BaseUrl

	-- keep a copy of the base url (https://www.roblox.com/)
	-- append a trailing slash if there isn't one
	if baseUrl:sub(#baseUrl) ~= "/" then
		baseUrl = baseUrl .. "/"
	end

	-- parse out scheme (http, https)
	local _, schemeEnd = baseUrl:find("://")

	-- parse out the prefix (www, kyle, ying, etc.)
	local prefixIndex, prefixEnd = baseUrl:find("%.", schemeEnd + 1)
	local basePrefix = baseUrl:sub(schemeEnd + 1, prefixIndex - 1)

	-- parse out the domain (roblox.com/, sitetest1.robloxlabs.com/, etc.)
	local baseDomain = baseUrl:sub(prefixEnd + 1)

	return baseUrl, basePrefix, baseDomain
end

-- url construction building blocks
local _baseUrl, _basePrefix, _baseDomain = parseBaseUrlInformation()

-- construct urls once
local _baseApiUrl = string.format("https://api.%s", _baseDomain)
local _baseAuthUrl = string.format("https://auth.%s", _baseDomain)
local _baseChatUrl = string.format("https://chat.%sv2", _baseDomain)
local _baseGameAssetUrl = string.format("https://assetgame.%s", _baseDomain)
local _baseGamesUrl = string.format("https://games.%s", _baseDomain)
local _baseNotificationUrl = string.format("https://notifications.%s", _baseDomain)
local _baseRealtimeUrl = string.format("https://realtime.%s", _baseDomain)
local _baseWebUrl = string.format("https://web.%s", _baseDomain)


-- public api
local Url = {
	DOMAIN = _baseDomain,
	PREFIX = _basePrefix,
	BASE_URL = _baseUrl,
	API_URL = _baseApiUrl,
	AUTH_URL = _baseAuthUrl,
	GAME_URL = _baseGamesUrl,
	GAME_ASSET_URL = _baseGameAssetUrl,
	CHAT_URL = _baseChatUrl,
	NOTIFICATION_URL = _baseNotificationUrl,
	REALTIME_URL = _baseRealtimeUrl,
	WEB_URL = _baseWebUrl
}

function Url:isVanitySite()
	return self.PREFIX ~= "www"
end

-- data - (table<string, string>) a table of key/value pairs to format
function Url.makeQueryString(data)
	--NOTE - This function can be used to create a query string of parameters
	-- at the end of url query, or create a application/form-url-encoded post body string
	local params = {}

	-- NOTE - Arrays are handled, but generally data is expected to be flat.
	for key, value in pairs(data) do
		if value ~= nil then --for optional params
			if type(value) == "table" then
				for i = 1, #value do
					table.insert(params, key .. "=" .. value[i])
				end
			else
				table.insert(params, key .. "=" .. tostring(value))
			end
		end
	end

	return table.concat(params, "&")
end

return Url
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA43C554801B54390A82312D4E1F67794">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HttpResponse</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	HttpResponse

	Encapsulates the response from an http request. Nothing fancy
]]

local HttpResponse = {}

function HttpResponse.new(response, responseTime, statusCode, requestType, url)
	return {
		responseTimeMs = responseTime,
		responseCode = statusCode,
		responseBody = response,
		requestType = requestType,
		url = url,
	}
end

return HttpResponse
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB1357448C98E4922B2B423771E2AEF7F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatusCodes</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[
return {
	PENDING = 0,
	UNKNOWN_ERROR = -1,
	NO_CONNECTIVITY = -2,
	INVALID_JSON = -3,
	BAD_TLS = -4,
	MODERATED = -5,

	OK = 200,
	BAD_REQUEST = 400,
	UNAUTHORIZED = 401,
	FORBIDDEN = 403,
	NOT_FOUND = 404,
	REQUEST_TIMEOUT = 408,
	INTERNAL_SERVER_ERROR = 500,
	NOT_IMPLEMENTED = 501,
	BAD_GATEWAY = 502,
	SERVICE_UNAVAILABLE = 503,
	GATEWAY_TIMEOUT = 504,
}]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7BFEB87D400049AC8D5BB66593E96B0E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TableUtilities.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local TableUtilities = require(script.Parent.TableUtilities)

	it("should return whether tables are equal to each other", function()
		local tableA = nil
		local tableB = nil
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)

		tableA = nil
		tableB = {}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)

		tableA = {}
		tableB = nil
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)

		tableA = {}
		tableB = {}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(true)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key1 = "value1",
		}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(true)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key1 = "value2",
		}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key2 = "value1",
		}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key2 = "value2",
		}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key1 = "value1",
			key2 = "value2",
		}
		expect(TableUtilities.ShallowEqual(tableA, tableB)).to.equal(false)
	end)

	it("should return whether tables are equal to each other at key", function()
		local tableA = nil
		local tableB = nil
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = nil
		tableB = {}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = {}
		tableB = nil
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = {}
		tableB = {}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key1 = "value1",
		}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(true)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key1 = "value2",
		}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key2 = "value1",
		}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key2 = "value2",
		}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(false)

		tableA = {
			key1 = "value1",
		}
		tableB = {
			key1 = "value1",
			key2 = "value2",
		}
		expect(TableUtilities.EqualKey(tableA, tableB)).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "")).to.equal(false)
		expect(TableUtilities.EqualKey(tableA, tableB, "key1")).to.equal(true)
		expect(TableUtilities.EqualKey(tableA, tableB, "key2")).to.equal(false)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>
