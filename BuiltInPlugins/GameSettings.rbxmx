<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXB32402C84E3A4185AF47E92CA1995ED7">
		<Properties>
			<string name="Name">GameSettings</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXA17D7E5A98904345B15DCBF9CE45B982">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RoactRodux</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local StoreProvider = require(script.StoreProvider)
local connect = require(script.connect)
local getStore = require(script.getStore)

return {
	StoreProvider = StoreProvider,
	connect = connect,
	UNSTABLE_getStore = getStore,
	UNSTABLE_connect2 = connect,
}]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXE2D552F139DF43E1A0AE8BCE3519195A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">join</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local function join(...)
	local result = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				result[key] = value
			end
		end
	end

	return result
end

return join]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE8CC4D9CD16C438EAC0C96B2FEE7FF63">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreProvider</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local storeKey = require(script.Parent.storeKey)

local StoreProvider = Roact.Component:extend("StoreProvider")

function StoreProvider:init(props)
	local store = props.store

	if store == nil then
		error("Error initializing StoreProvider. Expected a `store` prop to be a Rodux store.")
	end

	self._context[storeKey] = store
end

function StoreProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return StoreProvider]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC54AD2DB0E084198854D11547F36FF87">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">storeKey</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

return Symbol.named("RoduxStore")]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2AAE931AFDBF4AD0BC28FDEEC791A004">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getStore</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local storeKey = require(script.Parent.storeKey)

local function getStore(componentInstance)
	return componentInstance._context[storeKey]
end

return getStore]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9F64E18BC1FD4B00AA9C4386684F5A16">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type that can be used to signify unique
	statuses. Symbols have the type 'userdata', but when printed to the console,
	the name of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1FF5760558574F8881DB60009FE2AEB7">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">connect.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local connect = require(script.Parent.connect)

	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local function noop()
		return nil
	end

	local function NoopComponent()
		return nil
	end

	local function countReducer(state, action)
		state = state or 0

		if action.type == "increment" then
			return state + 1
		end

		return state
	end

	local reducer = Rodux.combineReducers({
		count = countReducer,
	})

	describe("Argument validation", function()
		it("should accept no arguments", function()
			connect()
		end)

		it("should accept one function", function()
			connect(noop)
		end)

		it("should accept two functions", function()
			connect(noop, noop)
		end)

		it("should accept only the second function", function()
			connect(nil, function() end)
		end)

		it("should throw if not passed a component", function()
			local selector = function(store)
				return {}
			end

			expect(function()
				connect(selector)(nil)
			end).to.throw()
		end)
	end)

	it("should throw if not mounted under a StoreProvider", function()
		local ConnectedSomeComponent = connect()(NoopComponent)

		expect(function()
			Roact.mount(Roact.createElement(ConnectedSomeComponent))
		end).to.throw()
	end)

	it("should accept a higher-order function mapStateToProps", function()
		local function mapStateToProps()
			return function(state)
				return {
					count = state.count,
				}
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		Roact.unmount(handle)
	end)

	it("should not accept a higher-order mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return function(state)
				return "nope"
			end
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should not accept a mapStateToProps that returns a non-table value", function()
		local function mapStateToProps()
			return "nah"
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(NoopComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		expect(function()
			Roact.mount(tree)
		end).to.throw()
	end)

	it("should abort renders when mapStateToProps returns the same data", function()
		local function mapStateToProps(state)
			return {
				count = state.count,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(mapStateToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(renderCount).to.equal(2)

		Roact.unmount(handle)
	end)

	it("should only call mapDispatchToProps once and never re-render if no mapStateToProps was passed", function()
		local dispatchCount = 0
		local mapDispatchToProps = function(dispatch)
			dispatchCount = dispatchCount + 1

			return {
				increment = function()
					return dispatch({ type = "increment" })
				end,
			}
		end

		local renderCount = 0
		local function SomeComponent(props)
			renderCount = renderCount + 1
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		local store = Rodux.Store.new(reducer)
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent),
		})

		local handle = Roact.mount(tree)

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "an unknown action" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		store:dispatch({ type = "increment" })
		store:flush()

		expect(dispatchCount).to.equal(1)
		expect(renderCount).to.equal(1)

		Roact.unmount(handle)
	end)

	it("should return result values from the dispatch passed to mapDispatchToProps", function()
		local function reducer()
			return 0
		end

		local function fiveThunk()
			return 5
		end

		local dispatch
		local function SomeComponent(props)
			dispatch = props.dispatch
		end

		local function mapDispatchToProps(dispatch)
			return {
				dispatch = dispatch
			}
		end

		local ConnectedSomeComponent = connect(nil, mapDispatchToProps)(SomeComponent)

		-- We'll use the thunk middleware, as it should always return its result
		local store = Rodux.Store.new(reducer, nil, { Rodux.thunkMiddleware })
		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			someComponent = Roact.createElement(ConnectedSomeComponent)
		})

		local handle = Roact.mount(tree)

		expect(dispatch).to.be.a("function")
		expect(dispatch(fiveThunk)).to.equal(5)

		Roact.unmount(handle)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXD9C50BA90A054ACEB4E3BA50A69CD6D9">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)

	describe("unnamed", function()
		it("should give an opaque object", function()
			local symbol = Symbol.unnamed()

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to some string", function()
			local symbol = Symbol.unnamed()

			expect(tostring(symbol)).to.be.a("string")
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.unnamed()
			local symbolB = Symbol.unnamed()

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE0204DE03C8341AA8EE6D3958F1D095E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StoreProvider.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local StoreProvider = require(script.Parent.StoreProvider)

	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	it("should be instantiable as a component", function()
		local store = Rodux.Store.new(function()
			return 0
		end)
		local element = Roact.createElement(StoreProvider, {
			store = store
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element, nil, "StoreProvider-test")

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should expect a 'store' prop", function()
		local element = Roact.createElement(StoreProvider)

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCFE50B1BE1DA425E8178DFAF7A79ED44">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">shallowEqual.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local shallowEqual = require(script.Parent.shallowEqual)

	it("should compare dictionaries", function()
		local a = {
			a = "a",
			b = {},
			c = 6,
		}

		local b = {
			b = a.b,
			c = a.c,
			a = a.a,
		}

		local c = {
			b = {},
			a = a.a,
			c = a.c,
		}

		local d = {
			a = a.a,
			b = a.b,
			c = a.c,
			d = "hello",
		}

		expect(shallowEqual(a, a)).to.equal(true)
		expect(shallowEqual(a, b)).to.equal(true)
		expect(shallowEqual(a, c)).to.equal(false)
		expect(shallowEqual(b, c)).to.equal(false)
		expect(shallowEqual(a, d)).to.equal(false)
		expect(shallowEqual(b, d)).to.equal(false)
	end)

	it("should handle nil for either argument", function()
		local a = {}

		expect(shallowEqual(nil, nil)).to.equal(true)
		expect(shallowEqual(a, nil)).to.equal(false)
		expect(shallowEqual(nil, a)).to.equal(false)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXDA9FA1C1E311423AA0F151A2C31F22A3">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">shallowEqual</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local function shallowEqual(a, b)
	if a == nil then
		return b == nil
	elseif b == nil then
		return a == nil
	end

	for key, value in pairs(a) do
		if value ~= b[key] then
			return false
		end
	end

	for key, value in pairs(b) do
		if value ~= a[key] then
			return false
		end
	end

	return true
end

return shallowEqual]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0094374B160441C3AE6098222B6BDB24">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getStore.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Roact = require(script.Parent.Parent.Roact)
	local Rodux = require(script.Parent.Parent.Rodux)

	local StoreProvider = require(script.Parent.StoreProvider)

	local getStore = require(script.Parent.getStore)

	it("should return the store when present", function()
		local function reducer()
			return 0
		end

		local store = Rodux.Store.new(reducer)
		local consumedStore = nil

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreProvider, {
			store = store,
		}, {
			Consumer = Roact.createElement(StoreConsumer),
		})

		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(store)

		Roact.unmount(handle)
		store:destruct()
	end)

	it("should return nil when the store is not present", function()
		-- Use a non-nil value to know for sure if StoreConsumer:init was called
		local consumedStore = 6

		local StoreConsumer = Roact.Component:extend("StoreConsumer")

		function StoreConsumer:init()
			consumedStore = getStore(self)
		end

		function StoreConsumer:render()
			return nil
		end

		local tree = Roact.createElement(StoreConsumer)
		local handle = Roact.mount(tree)

		expect(consumedStore).to.equal(nil)

		Roact.unmount(handle)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA5C57C238A46422992D5968118635F60">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">connect</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local getStore = require(script.Parent.getStore)
local shallowEqual = require(script.Parent.shallowEqual)
local join = require(script.Parent.join)

--[[
	Formats a multi-line message with printf-style placeholders.
]]
local function formatMessage(lines, parameters)
	return table.concat(lines, "\n"):format(unpack(parameters or {}))
end

local function noop()
	return nil
end

--[[
	The stateUpdater accepts props when they update and computes the
	complete set of props that should be passed to the wrapped component.

	Each connected component will have a stateUpdater created for it.

	stateUpdater is put into the component's state in order for
	getDerivedStateFromProps to be able to access it. It is not mutated.
]]
local function makeStateUpdater(store)
	return function(nextProps, prevState, mappedStoreState)
		-- The caller can optionally provide mappedStoreState if it needed that
		-- value beforehand. Doing so is purely an optimization.
		if mappedStoreState == nil then
			mappedStoreState = prevState.mapStateToProps(store:getState(), nextProps)
		end

		local propsForChild = join(nextProps, mappedStoreState, prevState.mappedStoreDispatch)

		return {
			mappedStoreState = mappedStoreState,
			propsForChild = propsForChild,
		}
	end
end

--[[
	mapStateToProps:
		(storeState, props) -> partialProps
		OR
		() -> (storeState, props) -> partialProps
	mapDispatchToProps: (dispatch) -> partialProps
]]
local function connect(mapStateToPropsOrThunk, mapDispatchToProps)
	local connectTrace = debug.traceback()

	if mapStateToPropsOrThunk ~= nil then
		assert(typeof(mapStateToPropsOrThunk) == "function", "mapStateToProps must be a function or nil!")
	else
		mapStateToPropsOrThunk = noop
	end

	if mapDispatchToProps ~= nil then
		assert(typeof(mapDispatchToProps) == "function", "mapDispatchToProps must be a function or nil!")
	else
		mapDispatchToProps = noop
	end

	return function(innerComponent)
		if innerComponent == nil then
			local message = formatMessage({
				"connect returns a function that must be passed a component.",
				"Check the connection at:",
				"%s",
			}, {
				connectTrace,
			})

			error(message, 2)
		end

		local componentName = ("RoduxConnection(%s)"):format(tostring(innerComponent))

		local Connection = Roact.Component:extend(componentName)

		function Connection.getDerivedStateFromProps(nextProps, prevState)
			return prevState.stateUpdater(nextProps, prevState)
		end

		function Connection:init()
			self.store = getStore(self)

			if self.store == nil then
				local message = formatMessage({
					"Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!",
					"Tried to wrap component %q",
					"Make sure there is a StoreProvider above this component in the tree.",
				}, {
					tostring(innerComponent),
				})

				error(message)
			end

			local storeState = self.store:getState()

			local mapStateToProps = mapStateToPropsOrThunk
			local mappedStoreState = mapStateToProps(storeState, self.props)

			-- mapStateToPropsOrThunk can return a function instead of a state
			-- value. In this variant, we keep that value as mapStateToProps
			-- instead of the original mapStateToProps. This matches react-redux
			-- and enables connectors to keep instance-level state.
			if typeof(mappedStoreState) == "function" then
				mapStateToProps = mappedStoreState
				mappedStoreState = mapStateToProps(storeState, self.props)
			end

			if mappedStoreState ~= nil and typeof(mappedStoreState) ~= "table" then
				local message = formatMessage({
					"mapStateToProps must either return a table, or return another function that returns a table.",
					"Instead, it returned %q, which is of type %s.",
				}, {
					tostring(mappedStoreState),
					typeof(mappedStoreState),
				})

				error(message)
			end

			local mappedStoreDispatch = mapDispatchToProps(function(...)
				return self.store:dispatch(...)
			end)

			local stateUpdater = makeStateUpdater(self.store)

			self.state = {
				-- Combines props, mappedStoreDispatch, and the result of
				-- mapStateToProps into propsForChild. Stored in state so that
				-- getDerivedStateFromProps can access it.
				stateUpdater = stateUpdater,

				-- Used by the store changed connection and stateUpdater to
				-- construct propsForChild.
				mapStateToProps = mapStateToProps,

				-- Used by stateUpdater to construct propsForChild.
				mappedStoreDispatch = mappedStoreDispatch,

				-- Passed directly into the component that Connection is
				-- wrapping.
				propsForChild = nil,
			}

			self.state.propsForChild = stateUpdater(self.props, self.state, mappedStoreState)
		end

		function Connection:didMount()
			self.storeChangedConnection = self.store.changed:connect(function(storeState)
				self:setState(function(prevState, props)
					local mappedStoreState = prevState.mapStateToProps(storeState, props)

					-- We run this check here so that we only check shallow
					-- equality with the result of mapStateToProps, and not the
					-- other props that could be passed through the connector.
					if shallowEqual(mappedStoreState, prevState.mappedStoreState) then
						return nil
					end

					return prevState.stateUpdater(props, prevState, mappedStoreState)
				end)
			end)
		end

		function Connection:willUnmount()
			self.storeChangedConnection:disconnect()
		end

		function Connection:render()
			return Roact.createElement(innerComponent, self.state.propsForChild)
		end

		return Connection
	end
end

return connect]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX9B9F15EDBDB541AB8146D8CD0D54FFD8">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Roact</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local Core = require(script.Core)
local GlobalConfig = require(script.GlobalConfig)
local Instrumentation = require(script.Instrumentation)
local Reconciler = require(script.Reconciler)
local ReconcilerCompat = require(script.ReconcilerCompat)

local Roact = {
	Change = require(script.Change),
	Component = require(script.Component),
	createElement = require(script.createElement),
	createRef = require(script.createRef),
	Event = require(script.Event),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),

	Children = Core.Children,
	Element = Core.Element,
	None = Core.None,
	Portal = Core.Portal,
	Ref = Core.Ref,

	mount = Reconciler.mount,
	unmount = Reconciler.unmount,
	reconcile = Reconciler.reconcile,

	reify = ReconcilerCompat.reify,
	teardown = ReconcilerCompat.teardown,

	setGlobalConfig = GlobalConfig.set,
	getGlobalConfigValue = GlobalConfig.getValue,

	-- APIs that may change in the future without warning
	UNSTABLE = {
		getCollectedStats = Instrumentation.getCollectedStats,
		clearCollectedStats = Instrumentation.clearCollectedStats,
	},
}

return Roact]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXA678F5AE49FB449BBDB016878968021E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Event</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Index into 'Event' to get a prop key for attaching to an event on a
	Roblox Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("Event(%s)"):format(self.name)
	end
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			type = Event,
			name = eventName
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end
})

return Event]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX22F96471462B47839484220552A3CAC2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GlobalConfig.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local GlobalConfig = require(script.Parent.GlobalConfig)

	it("should have the correct methods", function()
		expect(GlobalConfig).to.be.ok()
		expect(GlobalConfig.set).to.be.ok()
		expect(GlobalConfig.getValue).to.be.ok()
		expect(GlobalConfig.reset).to.be.ok()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX110A89307C3148E7BBC7DD36F5D7EB51">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Config</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables instrumentation of shouldUpdate and render methods for Roact components
	["componentInstrumentation"] = false,
	-- Enables warnings if an element changes type after being rendered.
	["warnOnTypeChange"] = true,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

--[[
	Merges two tables together into a new table.
]]
local function join(a, b)
	local new = {}

	for key, value in pairs(a) do
		new[key] = value
	end

	for key, value in pairs(b) do
		new[key] = value
	end

	return new
end

local Config = {}

function Config.new()
	local self = {}

	-- Once configuration has been set, we record a traceback.
	-- That way, if the user mistakenly calls `set` twice, we can point to the
	-- first place it was called.
	self._lastConfigTraceback = nil

	self._currentConfig = defaultConfig

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.getValue = function(...)
		return Config.getValue(self, ...)
	end

	self.reset = function(...)
		return Config.reset(self, ...)
	end

	return self
end

function Config.set(self, configValues)
	if self._lastConfigTraceback then
		local message = (
			"Global configuration can only be set once. Configuration was already set at:%s"
		):format(
			self._lastConfigTraceback
		)

		error(message, 3)
	end

	-- We use 3 as our traceback and error level because all of the methods are
	-- manually bound to 'self', which creates an additional stack frame we want
	-- to skip through.
	self._lastConfigTraceback = debug.traceback("", 3)

	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end
	end

	-- Assign all of the (validated) configuration values in one go.
	self._currentConfig = join(self._currentConfig, configValues)
end

function Config.getValue(self, key)
	if defaultConfig[key] == nil then
		local message = (
			"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
		):format(
			tostring(key),
			typeof(key),
			table.concat(defaultConfigKeys, ", ")
		)

		error(message, 3)
	end

	return self._currentConfig[key]
end

function Config.reset(self)
	self._lastConfigTraceback = nil
	self._currentConfig = defaultConfig
end

return Config]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF32941680E0743E1BD8DB14D1E7821ED">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Reconciler</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	The reconciler uses the virtual DOM generated by components to create a real
	tree of Roblox instances.

	The reonciler has three basic operations:
	* mount (previously reify)
	* reconcile
	* unmount (previously teardown)

	Mounting is the process of creating new components. This is first
	triggered when the user calls `Roact.mount` on an element. This is where the
	structure of the component tree is built, later used and modified by the
	reconciliation and unmounting steps.

	Reconciliation accepts an existing concrete instance tree (created by mount)
	along with a new element that describes the desired tree. The reconciler
	will do the minimum amount of work required to update tree's components to
	match the new element, sometimes invoking mount to create new branches.

	Unmounting destructs for the tree. It will crawl through the tree,
	destroying nodes from the bottom up.

	Much of the reconciler's work is done by Component, which is the base for
	all stateful components in Roact. Components can trigger reconciliation (and
	implicitly, unmounting) via state updates that come with their own caveats.
]]

local Core = require(script.Parent.Core)
local Event = require(script.Parent.Event)
local Change = require(script.Parent.Change)
local getDefaultPropertyValue = require(script.Parent.getDefaultPropertyValue)
local SingleEventManager = require(script.Parent.SingleEventManager)
local Symbol = require(script.Parent.Symbol)
local GlobalConfig = require(script.Parent.GlobalConfig)

local isInstanceHandle = Symbol.named("isInstanceHandle")

local DEFAULT_SOURCE = "\n\t<Use Roact.setGlobalConfig with the 'elementTracing' key to enable detailed tracebacks>\n"

local ElementKind = {
	None = Symbol.named("ElementKind.None"),
	Portal = Symbol.named("ElementKind.Portal"),
	Primitive = Symbol.named("ElementKind.Primitive"),
	Functional = Symbol.named("ElementKind.Functional"),
	Stateful = Symbol.named("ElementKind.Stateful"),
}

--[[
	Sets the value of a reference to a new rendered object.
	Correctly handles both function-style and object-style refs.
]]
local function applyRef(ref, newRbx)
	if ref == nil then
		return
	end

	if type(ref) == "table" then
		ref.current = newRbx
	else
		ref(newRbx)
	end
end

local componentTypesToKinds = {
	["string"] = ElementKind.Primitive,
	["function"] = ElementKind.Functional,
	["table"] = ElementKind.Stateful,
}
local function getElementKind(element)
	local elementType = typeof(element)

	-- We ignore boolean values, which enables using a shorter syntax for
	-- conditionally rendered elements.
	if elementType == "nil" or elementType == "boolean" then
		return ElementKind.None
	end

	if elementType ~= "table" then
		return nil
	end

	local component = element.component

	if component == Core.Portal then
		return ElementKind.Portal
	end

	local componentType = typeof(component)

	return componentTypesToKinds[componentType]
end

local Reconciler = {}

Reconciler._singleEventManager = SingleEventManager.new()

--[[
	Destroy the given Roact instance, all of its descendants, and associated
	Roblox instances owned by the components.
]]
function Reconciler.unmount(instanceHandle)
	local element = instanceHandle._element

	local elementKind = getElementKind(element)

	if elementKind == ElementKind.Primitive then
		-- We're destroying a Roblox Instance-based object

		-- Kill refs before we make changes, since any mutations past this point
		-- aren't relevant to components.
		applyRef(element.props[Core.Ref], nil)

		for _, child in pairs(instanceHandle._children) do
			Reconciler.unmount(child)
		end

		-- Necessary to make sure SingleEventManager doesn't leak references
		Reconciler._singleEventManager:disconnectAll(instanceHandle._rbx)

		instanceHandle._rbx:Destroy()
	elseif elementKind == ElementKind.Functional then
		-- Functional components can return nil
		if instanceHandle._child then
			Reconciler.unmount(instanceHandle._child)
		end
	elseif elementKind == ElementKind.Stateful then
		instanceHandle._instance:_unmount()
	elseif elementKind == ElementKind.Portal then
		for _, child in pairs(instanceHandle._children) do
			Reconciler.unmount(child)
		end
	else
		error(("Cannot unmount invalid Roact instance %q"):format(tostring(element)))
	end
end

--[[
	Public interface to reifier. Hides parameters used when recursing down the
	component tree.
]]
function Reconciler.mount(element, parent, key)
	return Reconciler._mountInternal(element, parent, key)
end

--[[
	Instantiates components to represent the given element.

	Parameters:
		- `element`: The element to mount.
		- `parent`: The Roblox object to contain the contained instances
		- `key`: The Name to give the Roblox instance that gets created
		- `context`: Used to pass Roact context values down the tree

	The structure created by this method is important to the functionality of
	the reconciliation methods; they depend on this structure being well-formed.
]]
function Reconciler._mountInternal(element, parent, key, context)
	local elementKind = getElementKind(element)

	if elementKind == nil then
		error(("Cannot mount invalid Roact element %q"):format(tostring(element)))
	end

	if elementKind == ElementKind.Primitive then
		-- Primitive elements are backed directly by Roblox Instances.

		local rbx = Instance.new(element.component)

		-- Update Roblox properties
		for key, value in pairs(element.props) do
			Reconciler._setRbxProp(rbx, key, value, element)
		end

		-- Create children!
		local children = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._mountInternal(childElement, rbx, key, context)

				children[key] = childInstance
			end
		end

		-- This name can be passed through multiple components.
		-- Elements with the same key will be treated as the same
		-- element between reconciles; the old element will be
		-- reconciled to the new element with the same key.
		if key then
			rbx.Name = key
		end

		rbx.Parent = parent

		-- Attach ref values, since the instance is initialized now.
		applyRef(element.props[Core.Ref], rbx)

		return {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_children = children,
			_rbx = rbx,
		}
	elseif elementKind == ElementKind.Functional then
		-- Functional elements contain 0 or 1 children.

		local instanceHandle = {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
		}

		local vdom = element.component(element.props)
		if vdom then
			instanceHandle._child = Reconciler._mountInternal(vdom, parent, key, context)
		end

		return instanceHandle
	elseif elementKind == ElementKind.Stateful then
		-- Stateful elements have 0 or 1 children, and also have a backing
		-- instance that can keep state.

		-- We separate the instance's implementation from our handle to it.
		local instanceHandle = {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_child = nil,
		}

		local instance = element.component._new(element.props, context)

		instanceHandle._instance = instance
		instance:_mount(instanceHandle)

		return instanceHandle
	elseif elementKind == ElementKind.Portal then
		-- Portal elements have one or more children.

		local target = element.props.target
		if not target then
			error(("Cannot mount Portal without specifying a target."):format(tostring(element)))
		elseif typeof(target) ~= "Instance" then
			error(("Cannot mount Portal with target of type %q."):format(typeof(target)))
		end

		-- Create children!
		local children = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._mountInternal(childElement, target, key, context)

				children[key] = childInstance
			end
		end

		return {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_children = children,
			_rbx = target,
		}
	elseif elementKind == ElementKind.None then
		return nil
	end

	error(("Unexpected element kind %s. This is a Roact bug."):format(tostring(elementKind)))
end

--[[
	A public interface around _reconcileInternal
]]
function Reconciler.reconcile(instanceHandle, newElement)
	if instanceHandle == nil or not instanceHandle[isInstanceHandle] then
		local message = (
			"Bad argument #1 to Reconciler.reconcile, expected component instance handle, found %s"
		):format(
			typeof(instanceHandle)
		)

		error(message, 2)
	end

	return Reconciler._reconcileInternal(instanceHandle, newElement)
end

--[[
	Applies the state given by newElement to an existing Roact instance.

	reconcile will return the instance that should be used. This instance can
	be different than the one that was passed in.
]]
function Reconciler._reconcileInternal(instanceHandle, newElement)
	local oldElement = instanceHandle._element

	local newElementKind = getElementKind(newElement)

	if newElementKind == nil then
		error(("Cannot reconcile to invalid Roact element %q"):format(tostring(newElement)))
	end

	if newElementKind == ElementKind.None then
		Reconciler.unmount(instanceHandle)

		return nil
	end

	-- If the element changes type, we assume its subtree will be substantially
	-- different. This lets us skip comparisons of a large swath of nodes.
	if oldElement.component ~= newElement.component then
		if GlobalConfig.getValue("warnOnTypeChange") then
			warn(("A Roact component is changing type from %s to %s during reconciliation!\n"
				.. "This can cause performance issues; see issue #88 for details."):format(
				tostring(oldElement.component),
				tostring(newElement.component)
			))

			print(("Old element source: %s\nNew element source: %s"):format(
				oldElement.source or DEFAULT_SOURCE,
				newElement.source or DEFAULT_SOURCE
			))
		end

		local parent = instanceHandle._parent
		local key = instanceHandle._key

		local context
		if getElementKind(oldElement) == ElementKind.Stateful then
			context = instanceHandle._instance._context
		else
			context = instanceHandle._context
		end

		Reconciler.unmount(instanceHandle)

		local newInstance = Reconciler._mountInternal(newElement, parent, key, context)

		return newInstance
	end

	if newElementKind == ElementKind.Primitive then
		local oldRef = oldElement.props[Core.Ref]
		local newRef = newElement.props[Core.Ref]

		-- Change the ref in one pass before applying any changes.
		-- Roact doesn't provide any guarantees with regards to the sequencing
		-- between refs and other changes in the commit phase.
		if newRef ~= oldRef then
			applyRef(oldRef, nil)
			applyRef(newRef, instanceHandle._rbx)
		end

		-- Update properties and children of the Roblox object.
		Reconciler._reconcilePrimitiveProps(oldElement, newElement, instanceHandle._rbx)
		Reconciler._reconcilePrimitiveChildren(instanceHandle, newElement)

		instanceHandle._element = newElement

		return instanceHandle
	elseif newElementKind == ElementKind.Functional then
		instanceHandle._element = newElement

		local rendered = newElement.component(newElement.props)
		local newChild

		if instanceHandle._child then
			-- Transition from tree to tree, even if 'rendered' is nil
			newChild = Reconciler._reconcileInternal(instanceHandle._child, rendered)
		elseif rendered then
			-- Transition from nil to new tree
			newChild = Reconciler._mountInternal(
				rendered,
				instanceHandle._parent,
				instanceHandle._key,
				instanceHandle._context
			)
		end

		instanceHandle._child = newChild

		return instanceHandle
	elseif newElementKind == ElementKind.Stateful then
		instanceHandle._element = newElement

		-- Stateful elements can take care of themselves.
		instanceHandle._instance:_update(newElement.props)

		return instanceHandle
	elseif newElementKind == ElementKind.Portal then
		if instanceHandle._rbx ~= newElement.props.target then
			local parent = instanceHandle._parent
			local key = instanceHandle._key
			local context = instanceHandle._context

			Reconciler.unmount(instanceHandle)

			local newInstance = Reconciler._mountInternal(newElement, parent, key, context)

			return newInstance
		end

		Reconciler._reconcilePrimitiveChildren(instanceHandle, newElement)

		instanceHandle._element = newElement

		return instanceHandle
	end

	error(("Unexpected element kind %s. This is a Roact bug."):format(tostring(newElementKind)))
end

--[[
	Reconciles the children of an existing Roact instance and the given element.
]]
function Reconciler._reconcilePrimitiveChildren(instance, newElement)
	local elementChildren = newElement.props[Core.Children]

	-- Reconcile existing children that were changed or removed
	for key, childInstance in pairs(instance._children) do
		local childElement = elementChildren and elementChildren[key]

		childInstance = Reconciler._reconcileInternal(childInstance, childElement)

		instance._children[key] = childInstance
	end

	-- Create children that were just added!
	if elementChildren then
		for key, childElement in pairs(elementChildren) do
			-- Update if we didn't hit the child in the previous loop
			if not instance._children[key] then
				local childInstance = Reconciler._mountInternal(childElement, instance._rbx, key, instance._context)
				instance._children[key] = childInstance
			end
		end
	end
end

--[[
	Reconciles the properties between two primitive Roact elements and applies
	the differences to the given Roblox object.
]]
function Reconciler._reconcilePrimitiveProps(fromElement, toElement, rbx)
	local seenProps = {}

	-- Set properties that were set with fromElement
	for key, oldValue in pairs(fromElement.props) do
		seenProps[key] = true

		local newValue = toElement.props[key]

		-- Assume any property that can be set to nil has a default value of nil
		if newValue == nil then
			local _, value = getDefaultPropertyValue(rbx.ClassName, key)

			-- We don't care if getDefaultPropertyValue fails, because
			-- _setRbxProp will catch the error below.
			newValue = value
		end

		-- Roblox does this check for normal values, but we have special
		-- properties like events that warrant this.
		if oldValue ~= newValue then
			Reconciler._setRbxProp(rbx, key, newValue, toElement)
		end
	end

	-- Set properties that are new in toElement
	for key, newValue in pairs(toElement.props) do
		if not seenProps[key] then
			seenProps[key] = true

			local oldValue = fromElement.props[key]

			if oldValue ~= newValue then
				Reconciler._setRbxProp(rbx, key, newValue, toElement)
			end
		end
	end
end

--[[
	Used in _setRbxProp to avoid creating a new closure for every property set.
]]
local function set(rbx, key, value)
	rbx[key] = value
end

--[[
	Sets a property on a Roblox object, following Roact's rules for special
	case properties.

	This function can throw a couple different errors. In the future, calls to
	_setRbxProp should be wrapped in a pcall to give better errors to the user.

	For that to be useful, we'll need to attach a 'source' property on every
	element, created using debug.traceback(), that points to where the element
	was created.
]]
function Reconciler._setRbxProp(rbx, key, value, element)
	if type(key) == "string" then
		-- Regular property

		local success, err = pcall(set, rbx, key, value)

		if not success then
			local source = element.source or DEFAULT_SOURCE

			local message = ("Failed to set property %s on primitive instance of class %s\n%s\n%s"):format(
				key,
				rbx.ClassName,
				err,
				source
			)

			error(message, 0)
		end
	elseif type(key) == "table" then
		-- Special property with extra data attached.

		if key.type == Event then
			Reconciler._singleEventManager:connect(rbx, key.name, value)
		elseif key.type == Change then
			Reconciler._singleEventManager:connectProperty(rbx, key.name, value)
		else
			local source = element.source or DEFAULT_SOURCE

			-- luacheck: ignore 6
			local message = ("Failed to set special property on primitive instance of class %s\nInvalid special property type %q\n%s"):format(
				rbx.ClassName,
				tostring(key.type),
				source
			)

			error(message, 0)
		end
	elseif type(key) ~= "userdata" then
		-- Userdata values are special markers, usually created by Symbol
		-- They have no data attached other than being unique keys

		local source = element.source or DEFAULT_SOURCE

		local message = ("Properties with a key type of %q are not supported\n%s"):format(
			type(key),
			source
		)

		error(message, 0)
	end
end

return Reconciler
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF0D6CAFDCF154A50B03B1F0F8084218D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Component</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	The base implementation of a stateful component in Roact.

	Stateful components handle most of their own mounting and reconciliation
	process. Many of the private methods here are invoked by the reconciler.

	Stateful components expose a handful of lifecycle events:
	- didMount
	- willUnmount
	- willUpdate
	- didUpdate
	- (static) getDerivedStateFromProps

	These lifecycle events line up with their semantics in React, and more
	information (and a diagram) is available in the Roact documentation.
]]

local Reconciler = require(script.Parent.Reconciler)
local Core = require(script.Parent.Core)
local GlobalConfig = require(script.Parent.GlobalConfig)
local Instrumentation = require(script.Parent.Instrumentation)

local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)

local Component = {}

-- Locally cache tick so we can minimize impact of calling it for instrumentation
local tick = tick

Component.__index = Component

--[[
	Merge any number of dictionaries into a new dictionary, overwriting keys.

	If a value of `Core.None` is encountered, the key will be removed instead.
	This is necessary because Lua doesn't differentiate between a key being
	missing and a key being set to nil.
]]
local function merge(...)
	local result = {}

	for i = 1, select("#", ...) do
		local entry = select(i, ...)

		for key, value in pairs(entry) do
			if value == Core.None then
				result[key] = nil
			else
				result[key] = value
			end
		end
	end

	return result
end

--[[
	Create a new stateful component.

	Not intended to be a general OO implementation, this function only intends
	to let users extend Component and PureComponent.

	Instead of using inheritance, use composition and props to extend
	components.
]]
function Component:extend(name)
	assert(type(name) == "string", "A name must be provided to create a Roact Component")

	local class = {}

	for key, value in pairs(self) do
		-- We don't want users using 'extend' to create component inheritance
		-- see https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class.__index = class

	setmetatable(class, {
		__tostring = function(self)
			return name
		end
	})

	function class._new(passedProps, context)
		local self = {}

		-- When set to a value, setState will fail, using the given reason to
		-- create a detailed error message.
		-- You can see a list of reasons in invalidSetStateMessages.
		self._setStateBlockedReason = nil

		-- When set to true, setState should not trigger an update, but should
		-- instead just update self.state. Lifecycle events like `willUpdate`
		-- can set this to change the behavior of setState slightly.
		self._setStateWithoutUpdate = false

		if class.defaultProps == nil then
			self.props = passedProps
		else
			self.props = merge(class.defaultProps, passedProps)
		end

		self._context = {}

		-- Shallow copy all context values from our parent element.
		if context then
			for key, value in pairs(context) do
				self._context[key] = value
			end
		end

		setmetatable(self, class)

		self.state = {}

		-- Call the user-provided initializer, where state and _props are set.
		if class.init then
			self._setStateWithoutUpdate = true
			class.init(self, self.props)
			self._setStateWithoutUpdate = false
		end

		if class.getDerivedStateFromProps then
			local partialState = class.getDerivedStateFromProps(self.props, self.state)

			if partialState then
				self.state = merge(self.state, partialState)
			end
		end

		return self
	end

	return class
end

--[[
	render is intended to describe what a UI should look like at the current
	point in time.

	The default implementation throws an error, since forgetting to define
	render is usually a mistake.

	The simplest implementation for render is:

		function MyComponent:render()
			return nil
		end

	You should explicitly return nil from functions in Lua to avoid edge cases
	related to none versus nil.
]]
function Component:render()
	local message = (
		"The component %q is missing the 'render' method.\n" ..
		"render must be defined when creating a Roact component!"
	):format(
		tostring(getmetatable(self))
	)

	error(message, 0)
end

--[[
	Used to tell Roact whether this component *might* need to be re-rendered
	given a new set of props and state.

	This method is an escape hatch for when the Roact element creation and
	reconciliation algorithms are not fast enough for specific cases. Poorly
	written shouldUpdate methods *will* cause hard-to-trace bugs.

	If you're thinking of writing a shouldUpdate function, consider using
	PureComponent instead, which provides a good implementation given that your
	data is immutable.

	This function must be faster than the render method in order to be a
	performance improvement.
]]
function Component:shouldUpdate(newProps, newState)
	return true
end

--[[
	Applies new state to the component.

	partialState may be one of two things:
	- A table, which will be merged onto the current state.
	- A function, returning a table to merge onto the current state.

	The table variant generally looks like:

		self:setState({
			foo = "bar",
		})

	The function variant generally looks like:

		self:setState(function(prevState, props)
			return {
				foo = prevState.count + 1,
			})
		end)

	The function variant may also return nil in the callback, which allows Roact
	to cancel updating state and abort the render.

	Future versions of Roact will potentially batch or delay state merging, so
	any state updates that depend on the current state should use the function
	variant.
]]
function Component:setState(partialState)
	-- If setState was disabled, we should check for a detailed message and
	-- display it.
	if self._setStateBlockedReason ~= nil then
		local messageSource = invalidSetStateMessages[self._setStateBlockedReason]

		if messageSource == nil then
			messageSource = invalidSetStateMessages["default"]
		end

		-- We assume that each message has a formatting placeholder for a component name.
		local formattedMessage = string.format(messageSource, tostring(getmetatable(self)))

		error(formattedMessage, 2)
	end

	-- If the partial state is a function, invoke it to get the actual partial state.
	if type(partialState) == "function" then
		partialState = partialState(self.state, self.props)

		-- If partialState is nil, abort the render.
		if partialState == nil then
			return
		end
	end

	local newState = merge(self.state, partialState)

	if self._setStateWithoutUpdate then
		self.state = newState
	else
		self:_update(nil, newState)
	end
end

--[[
	Returns the current stack trace for this component, or nil if the
	elementTracing configuration flag is set to false.
]]
function Component:getElementTraceback()
	return self._handle._element.source
end

--[[
	Notifies the component that new props and state are available. This function
	is invoked by the reconciler.

	If shouldUpdate returns true, this method will trigger a re-render and
	reconciliation step.
]]
function Component:_update(newProps, newState)
	self._setStateBlockedReason = "shouldUpdate"

	-- Compute new derived state.
	-- Get the class - getDerivedStateFromProps is static.
	local class = getmetatable(self)

	-- If newProps are passed, compute derived state and default props
	if newProps then
		if class.getDerivedStateFromProps then
			local derivedState = class.getDerivedStateFromProps(newProps, newState or self.state)

			-- getDerivedStateFromProps can return nil if no changes are necessary.
			if derivedState ~= nil then
				newState = merge(newState or self.state, derivedState)
			end
		end

		if class.defaultProps then
			-- We only allocate another prop table if there are props that are
			-- falling back to their default.
			local replacementProps

			for key in pairs(class.defaultProps) do
				if newProps[key] == nil then
					replacementProps = merge(class.defaultProps, newProps)
					break
				end
			end

			if replacementProps then
				newProps = replacementProps
			end
		end
	end

	local shouldUpdateStart = tick()
	local doUpdate = self:shouldUpdate(newProps or self.props, newState or self.state)
	local shouldUpdateElapsed = tick() - shouldUpdateStart

	if GlobalConfig.getValue("componentInstrumentation") then
		Instrumentation.logShouldUpdate(self._handle, doUpdate, shouldUpdateElapsed)
	end

	self._setStateBlockedReason = nil

	if doUpdate then
		self:_forceUpdate(newProps, newState)
	end
end

--[[
	Forces the component to re-render itself and its children.

	This is essentially the inner portion of _update.

	newProps and newState are optional.
]]
function Component:_forceUpdate(newProps, newState)
	if self.willUpdate then
		self._setStateWithoutUpdate = true
		self:willUpdate(newProps or self.props, newState or self.state)
		self._setStateWithoutUpdate = false
	end

	local oldProps = self.props
	local oldState = self.state

	if newProps then
		self.props = newProps
	end

	if newState then
		self.state = newState
	end

	self._setStateBlockedReason = "render"

	local renderStart = tick()
	local newChildElement = self:render()
	local renderElapsed = tick() - renderStart

	self._setStateBlockedReason = nil

	if GlobalConfig.getValue("componentInstrumentation") then
		Instrumentation.logRenderTime(self._handle, renderElapsed)
	end

	self._setStateBlockedReason = "reconcile"
	if self._handle._child ~= nil then
		-- We returned an element during our last render, update it.
		self._handle._child = Reconciler._reconcileInternal(
			self._handle._child,
			newChildElement
		)
	elseif newChildElement then
		-- We returned nil during our last render, construct a new child.
		self._handle._child = Reconciler._mountInternal(
			newChildElement,
			self._handle._parent,
			self._handle._key,
			self._context
		)
	end
	self._setStateBlockedReason = nil

	if self.didUpdate then
		self:didUpdate(oldProps, oldState)
	end
end

--[[
	Initializes the component instance and attaches it to the given
	instance handle, created by Reconciler._mount.
]]
function Component:_mount(handle)
	self._handle = handle

	self._setStateBlockedReason = "render"

	local renderStart = tick()
	local virtualTree = self:render()
	local renderElapsed = tick() - renderStart

	if GlobalConfig.getValue("componentInstrumentation") then
		Instrumentation.logRenderTime(self._handle, renderElapsed)
	end

	self._setStateBlockedReason = nil

	if virtualTree then
		self._setStateBlockedReason = "reconcile"
		handle._child = Reconciler._mountInternal(
			virtualTree,
			handle._parent,
			handle._key,
			self._context
		)
		self._setStateBlockedReason = nil
	end

	if self.didMount then
		self:didMount()
	end
end

--[[
	Destructs the component and invokes all necessary lifecycle methods.
]]
function Component:_unmount()
	local handle = self._handle

	if self.willUnmount then
		self._setStateBlockedReason = "willUnmount"
		self:willUnmount()
		self._setStateBlockedReason = nil
	end

	-- Stateful components can return nil from render()
	if handle._child then
		Reconciler.unmount(handle._child)
	end

	self._handle = nil
end

return Component
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX920CACD2A3B449A3B77BFEAC37C349E1">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">invalidSetStateMessages</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]

local invalidSetStateMessages = {}

invalidSetStateMessages["willUpdate"] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages["willUnmount"] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages["shouldUpdate"] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages["init"] = [[
setState cannot be used in the init method.
During init, the component hasn't initialized yet, and isn't ready to render.

Instead, set the `state` value directly:

	self.state = {
		value = "foo"
	}

Check the definition of init in the component %q.]]

invalidSetStateMessages["render"] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["reconcile"] = [[
setState cannot be called while a component is being reified or reconciled.
This is the step where Roact constructs Roblox instances, and starting another
render here would introduce bugs.

Check the component %q to see if setState is being called by:
* a child Ref
* a child Changed event
* a child's render method]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, but Roact couldn't find a
message to display.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX32D1605CB1864649AD47C1512B95A269">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createRef.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createRef = require(script.Parent.createRef)

	it("should create refs", function()
		expect(createRef()).to.be.ok()
	end)

	it("should support tostring on refs", function()
		local ref = createRef()
		expect(tostring(ref)).to.equal("RoactReference(nil)")

		ref.current = "foo"
		expect(tostring(ref)).to.equal("RoactReference(foo)")
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBD3C126E5DDB4B79933B654D4060F8F2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createElement.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)

	it("should create new primitive elements", function()
		local element = createElement("Frame")

		expect(element).to.be.ok()
	end)

	it("should create new functional elements", function()
		local element = createElement(function()
		end)

		expect(element).to.be.ok()
	end)

	it("should create new stateful components", function()
		local element = createElement({})

		expect(element).to.be.ok()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6EF63F8664764AC6B70886C6424DDA8D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">oneChild</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Utility to retrieve one child out the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child, but can be passed zero.
]]
local function oneChild(children)
	if not children then
		return
	end

	local key, child = next(children)

	if not child then
		return
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXFD8FDA1A6EBE4CB884D33600F1446C15">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">oneChild.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)

	local oneChild = require(script.Parent.oneChild)

	it("should get zero children from a table", function()
		local children = {}

		expect(oneChild(children)).to.equal(nil)
	end)

	it("should get exactly one child", function()
		local child = createElement("Frame")
		local children = {
			foo = child,
		}

		expect(oneChild(children)).to.equal(child)
	end)

	it("should error with more than one child", function()
		local children = {
			a = createElement("Frame"),
			b = createElement("Frame"),
		}

		expect(function()
			oneChild(children)
		end).to.throw()
	end)

	it("should handle being passed nil", function()
		expect(oneChild(nil)).to.equal(nil)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCAB288DEB1C343FA8C2F25A5343927C5">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Instrumentation</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	An optional instrumentation layer that the reconciler calls into to record
	various events.

	Tracks a number of stats, including:
		Recorded stats:
		- Render count by component
		- Update request count by component
		- Actual update count by component
		- shouldUpdate returned true count by component
		- Time taken to run shouldUpdate
		- Time taken to render by component
		Derivable stats (for profiling manually or with a future tool):
		- Average render time by component
		- Percent of total render time by component
		- Percent of time shouldUpdate returns true
		- Average shouldUpdate time by component
		- Percent of total shouldUpdate time by component
]]

local Instrumentation = {}

local componentStats = {}

--[[
	Determines name of component from the given instance handle and returns a
	stat object from the componentStats table, generating a new one if needed
]]
local function getStatEntry(handle)
	local name
	if handle and handle._element and handle._element.component then
		name = tostring(handle._element.component)
	else
		warn("Component name not valid for " .. tostring(handle._key))
		return nil
	end
	local entry = componentStats[name]
	if not entry then
		entry = {
			-- update requests
			updateReqCount = 0,
			-- actual updates
			didUpdateCount = 0,
			-- time spent in shouldUpdate
			shouldUpdateTime = 0,
			-- number of renders
			renderCount = 0,
			-- total render time spent
			renderTime = 0,
		}
		componentStats[name] = entry
	end

	return entry
end

--[[
	Logs the time taken and resulting value of a Component's shouldUpdate function
]]
function Instrumentation.logShouldUpdate(handle, updateNeeded, shouldUpdateTime)
	-- Grab or create associated entry in stats table
	local statEntry = getStatEntry(handle)
	if statEntry then
		-- Increment the total number of times update was invoked
		statEntry.updateReqCount = statEntry.updateReqCount + 1

		-- Increment (when applicable) total number of times shouldUpdate returned true
		statEntry.didUpdateCount = statEntry.didUpdateCount + (updateNeeded and 1 or 0)

		-- Add time spent checking if an update is needed (in millis) to total time
		statEntry.shouldUpdateTime = statEntry.shouldUpdateTime + shouldUpdateTime * 1000
	end
end

--[[
	Logs the time taken value of a Component's render function
]]
function Instrumentation.logRenderTime(handle, renderTime)
	-- Grab or create associated entry in stats table
	local statEntry = getStatEntry(handle)
	if statEntry then
		-- Increment total render count
		statEntry.renderCount = statEntry.renderCount + 1

		-- Add render time (in millis) to total rendering time
		statEntry.renderTime = statEntry.renderTime + renderTime * 1000
	end
end

--[[
	Clears all the stats collected thus far. Useful for testing and for profiling in the future
]]
function Instrumentation.clearCollectedStats()
	componentStats = {}
end

--[[
	Returns all the stats collected thus far. Useful for testing and for profiling in the future
]]
function Instrumentation.getCollectedStats()
	return componentStats
end

return Instrumentation]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9999B317E6F94AA6A4AF87436DCFD858">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Reconciler.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Core = require(script.Parent.Core)
	local createRef = require(script.Parent.createRef)
	local createElement = require(script.Parent.createElement)

	local Reconciler = require(script.Parent.Reconciler)

	it("should mount booleans as nil", function()
		local booleanReified = Reconciler.mount(false)
		expect(booleanReified).to.never.be.ok()
	end)

	it("should handle object references properly", function()
		local objectRef = createRef()
		local element = createElement("StringValue", {
			[Core.Ref] = objectRef,
		})

		local handle = Reconciler.mount(element)
		expect(objectRef.current).to.be.ok()
		Reconciler.unmount(handle)
		expect(objectRef.current).to.never.be.ok()
	end)

	it("should handle function references properly", function()
		local currentRbx

		local function ref(rbx)
			currentRbx = rbx
		end

		local element = createElement("StringValue", {
			[Core.Ref] = ref,
		})

		local handle = Reconciler.mount(element)
		expect(currentRbx).to.be.ok()
		Reconciler.unmount(handle)
		expect(currentRbx).to.never.be.ok()
	end)

	it("should handle changing function references", function()
		local aValue, bValue

		local function aRef(rbx)
			aValue = rbx
		end

		local function bRef(rbx)
			bValue = rbx
		end

		local element = createElement("StringValue", {
			[Core.Ref] = aRef,
		})

		local handle = Reconciler.mount(element, game, "Test123")
		expect(aValue).to.be.ok()
		expect(bValue).to.never.be.ok()
		handle = Reconciler.reconcile(handle, createElement("StringValue", {
			[Core.Ref] = bRef,
		}))
		expect(aValue).to.never.be.ok()
		expect(bValue).to.be.ok()
		Reconciler.unmount(handle)
		expect(bValue).to.never.be.ok()
	end)

	it("should handle changing object references", function()
		local aRef = createRef()
		local bRef = createRef()

		local element = createElement("StringValue", {
			[Core.Ref] = aRef,
		})

		local handle = Reconciler.mount(element, game, "Test123")
		expect(aRef.current).to.be.ok()
		expect(bRef.current).to.never.be.ok()
		handle = Reconciler.reconcile(handle, createElement("StringValue", {
			[Core.Ref] = bRef,
		}))
		expect(aRef.current).to.never.be.ok()
		expect(bRef.current).to.be.ok()
		Reconciler.unmount(handle)
		expect(bRef.current).to.never.be.ok()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8101ED295C3A46AAB477B200348A3F45">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getDefaultPropertyValue.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local getDefaultPropertyValue = require(script.Parent.getDefaultPropertyValue)

	it("should get default name string values", function()
		local _, defaultName = getDefaultPropertyValue("StringValue", "Name")

		expect(defaultName).to.equal("Value")
	end)

	it("should get default empty string values", function()
		local _, defaultValue = getDefaultPropertyValue("StringValue", "Value")

		expect(defaultValue).to.equal("")
	end)

	it("should get default number values", function()
		local _, defaultValue = getDefaultPropertyValue("IntValue", "Value")

		expect(defaultValue).to.equal(0)
	end)

	it("should get nil default values", function()
		local _, defaultValue = getDefaultPropertyValue("ObjectValue", "Value")

		expect(defaultValue).to.equal(nil)
	end)

	it("should get bool default values", function()
		local _, defaultValue = getDefaultPropertyValue("BoolValue", "Value")

		expect(defaultValue).to.equal(false)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX29078ED5A0424550958DF4505775A4FF">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBD869E2AE6BD4FD89EEBA3D9353484F2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createElement</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Core)
local GlobalConfig = require(script.Parent.GlobalConfig)

--[[
	Creates a new Roact element of the given type.

	Does not create any concrete objects.
]]
local function createElement(elementType, props, children)
	if elementType == nil then
		error(("Expected elementType as an argument to createElement!"), 2)
	end

	props = props or {}

	if children then
		if props[Core.Children] ~= nil then
			warn("props[Children] was defined but was overridden by third parameter to createElement!")
		end

		props[Core.Children] = children
	end

	local element = {
		type = Core.Element,
		component = elementType,
		props = props,
	}

	if GlobalConfig.getValue("elementTracing") then
		element.source = ("\n%s\n"):format(debug.traceback())
	end

	return element
end

return createElement]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB5DCA168C4E24B30AE202DE0A0431A6E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Change</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("ChangeListener(%s)"):format(self.name)
	end
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			type = Change,
			name = propertyName
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX324FF785046D4EB793C5460E55FDF8A6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createRef</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Provides an API for acquiring a reference to a reified object. This
	API is designed to mimic React 16.3's createRef API.

	See:
	* https://reactjs.org/docs/refs-and-the-dom.html
	* https://reactjs.org/blog/2018/03/29/react-v-16-3.html#createref-api
]]

local refMetatable = {
	__tostring = function(self)
		return ("RoactReference(%s)"):format(tostring(self.current))
	end,
}

return function()
	return setmetatable({
		current = nil,
	}, refMetatable)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX46855514630C45A7A63EEC1BCDE604B0">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PureComponent.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createElement = require(script.Parent.createElement)
	local Reconciler = require(script.Parent.Reconciler)

	local PureComponent = require(script.Parent.PureComponent)

	it("should be extendable", function()
		local MyComponent = PureComponent:extend("MyComponent")

		expect(MyComponent).to.be.ok()
	end)

	it("should skip updates for shallow-equal props", function()
		local updateCount = 0
		local setValue

		local PureChild = PureComponent:extend("PureChild")

		function PureChild:willUpdate(newProps, newState)
			updateCount = updateCount + 1
		end

		function PureChild:render()
		end

		local PureContainer = PureComponent:extend("PureContainer")

		function PureContainer:init()
			self.state = {
				value = 0,
			}
		end

		function PureContainer:didMount()
			setValue = function(value)
				self:setState({
					value = value,
				})
			end
		end

		function PureContainer:render()
			return createElement(PureChild, {
				value = self.state.value,
			})
		end

		local element = createElement(PureContainer)
		local instance = Reconciler.mount(element)

		expect(updateCount).to.equal(0)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(1)

		expect(updateCount).to.equal(1)

		setValue(2)

		expect(updateCount).to.equal(2)

		setValue(1)

		expect(updateCount).to.equal(3)

		Reconciler.unmount(instance)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9B417F752AE443CB9BB23C62416A3486">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SingleEventManager</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	An interface to have one event listener at a time on an event.

	One listener can be registered per SingleEventManager/Instance/Event triple.

	For example:

		myManager:connect(myPart, "Touched", touchedListener)
		myManager:connect(myPart, "Touched", otherTouchedListener)

	If myPart is touched, only `otherTouchedListener` will fire, because the
	first listener was disconnected during the second connect call.

	The hooks provided by SingleEventManager pass the associated Roblox object
	as the first parameter to the callback. This differs from normal
	Roblox events.

	SingleEventManager's public methods operate in terms of instances and string
	keys, differentiating between regular events and property changed signals
	by calling different methods.

	In the internal implementation, everything is handled via indexing by
	instances and event objects themselves. This allows the code to use the same
	structures for both kinds of instance event.
]]

local SingleEventManager = {}

SingleEventManager.__index = SingleEventManager

--[[
	Constructs a `Hook`, which is a bundle containing a method that can be
	updated, as well as the signal connection.
]]
local function createHook(instance, event, method)
	local hook = {
		method = method,
	}

	hook.connection = event:Connect(function(...)
		hook.method(instance, ...)
	end)

	return hook
end

function SingleEventManager.new()
	local self = {
		-- Map<Instance, Map<Event, Hook>>
		_hooks = {},
	}

	setmetatable(self, SingleEventManager)

	return self
end

function SingleEventManager:connect(instance, key, method)
	self:_connectInternal(instance, instance[key], key, method)
end

function SingleEventManager:connectProperty(instance, key, method)
	self:_connectInternal(instance, instance:GetPropertyChangedSignal(key), "Property:" .. key, method)
end

--[[
	Disconnects the hook attached to the event named `key` on the given
	`instance` if there is one, otherwise does nothing.

	Note that `key` must identify a valid property on `instance`, or this method
	will throw.
]]
function SingleEventManager:disconnect(instance, key)
	self:_disconnectInternal(instance, key)
end

--[[
	Disconnects the hook attached to the property changed signal on `instance`
	with the name `key` if there is one, otherwise does nothing.

	Note that `key` must identify a valid property on `instance`, or this method
	will throw.
]]
function SingleEventManager:disconnectProperty(instance, key)
	self:_disconnectInternal(instance, "Property:" .. key)
end

--[[
	Disconnects any hooks managed by SingleEventManager associated with
	`instance`.

	Calling disconnectAll with an untracked instance won't do anything.
]]
function SingleEventManager:disconnectAll(instance)
	local instanceHooks = self._hooks[instance]

	if instanceHooks == nil then
		return
	end

	for _, hook in pairs(instanceHooks) do
		hook.connection:Disconnect()
	end

	self._hooks[instance] = nil
end

--[[
	Creates a hook using the given event and method and associates it with the
	given instance.

	Generally, `event` should directly associated with `instance`, but that's
	unchecked in this code.
]]
function SingleEventManager:_connectInternal(instance, event, key, method)
	local instanceHooks = self._hooks[instance]

	if instanceHooks == nil then
		instanceHooks = {}
		self._hooks[instance] = instanceHooks
	end

	local existingHook = instanceHooks[key]

	if existingHook ~= nil then
		existingHook.method = method
	else
		instanceHooks[key] = createHook(instance, event, method)
	end
end

--[[
	Disconnects a hook associated with the given instance and event if it's
	present, otherwise does nothing.
]]
function SingleEventManager:_disconnectInternal(instance, key)
	local instanceHooks = self._hooks[instance]

	if instanceHooks == nil then
		return
	end

	local hook = instanceHooks[key]

	if hook == nil then
		return
	end

	hook.connection:Disconnect()
	instanceHooks[key] = nil

	-- If there are no hooks left for this instance, we don't need this record.
	if next(instanceHooks) == nil then
		self._hooks[instance] = nil
	end
end

return SingleEventManager
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF585240EF6D1419D95B8F40FA58CF28B">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Change.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Change = require(script.Parent.Change)

	it("should yield change listener objects when indexed", function()
		expect(Change.Text).to.be.ok()
		expect(Change.Selected).to.be.ok()
	end)

	it("should yield the same object when indexed again", function()
		local a = Change.Text
		local b = Change.Text

		expect(a).to.equal(b)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0B5F012EBF954939A884E9B56B863BE8">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">getDefaultPropertyValue</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultPropertyValue(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultPropertyValue]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAFF4945919D34A9AA626EA396C13D8D2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Event.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Event = require(script.Parent.Event)

	it("should yield event objects when indexed", function()
		expect(Event.MouseButton1Click).to.be.ok()
		expect(Event.Touched).to.be.ok()
	end)

	it("should yield the same object when indexed again", function()
		local a = Event.MouseButton1Click
		local b = Event.MouseButton1Click

		expect(a).to.equal(b)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8890287B2C9B4103A5AE026260DE1F67">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Instrumentation.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Component = require(script.Parent.PureComponent)
	local GlobalConfig = require(script.Parent.GlobalConfig)
	local Reconciler = require(script.Parent.Reconciler)
	local createElement = require(script.Parent.createElement)

	local Instrumentation = require(script.Parent.Instrumentation)

	it("should count and time renders when enabled", function()
		GlobalConfig.set({
			["componentInstrumentation"] = true,
		})
		local triggerUpdate

		local TestComponent = Component:extend("TestComponent")
		function TestComponent:init()
			self.state = {
				value = 0
			}
		end

		function TestComponent:render()
			return nil
		end

		function TestComponent:didMount()
			triggerUpdate = function()
				self:setState({
					value = self.state.value + 1
				})
			end
		end

		local instance = Reconciler.mount(createElement(TestComponent))

		local stats = Instrumentation.getCollectedStats()
		expect(stats.TestComponent).to.be.ok()
		expect(stats.TestComponent.renderCount).to.equal(1)

		triggerUpdate()
		expect(stats.TestComponent.renderCount).to.equal(2)

		Reconciler.unmount(instance)
		Instrumentation.clearCollectedStats()
		GlobalConfig.reset()
	end)

	it("should count and time shouldUpdate calls when enabled", function()
		GlobalConfig.set({
			["componentInstrumentation"] = true,
		})
		local triggerUpdate
		local willDoUpdate = false

		local TestComponent = Component:extend("TestComponent")

		function TestComponent:init()
			self.state = {
				value = 0,
			}
		end

		function TestComponent:shouldUpdate()
			return willDoUpdate
		end

		function TestComponent:didMount()
			triggerUpdate = function()
				self:setState({
					value = self.state.value + 1,
				})
			end
		end

		function TestComponent:render() end

		local instance = Reconciler.mount(createElement(TestComponent))

		local stats = Instrumentation.getCollectedStats()

		willDoUpdate = true
		triggerUpdate()

		expect(stats.TestComponent).to.be.ok()
		expect(stats.TestComponent.updateReqCount).to.equal(1)
		expect(stats.TestComponent.didUpdateCount).to.equal(1)

		willDoUpdate = false
		triggerUpdate()

		expect(stats.TestComponent.updateReqCount).to.equal(2)
		expect(stats.TestComponent.didUpdateCount).to.equal(1)

		Reconciler.unmount(instance)
		Instrumentation.clearCollectedStats()
		GlobalConfig.reset()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBC7D58315DB542B692EC1CCA8F2152D2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Core</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Provides a set of markers used for annotating data in Roact.
]]

local Symbol = require(script.Parent.Symbol)

local Core = {}

-- Marker used to specify children of a node.
Core.Children = Symbol.named("Children")

-- Marker used to specify a callback to receive the underlying Roblox object.
Core.Ref = Symbol.named("Ref")

-- Marker used to specify that a component is a Roact Portal.
Core.Portal = Symbol.named("Portal")

-- Marker used to specify that the value is nothing, because nil cannot be stored in tables.
Core.None = Symbol.named("None")

-- Marker used to specify that the table it is present within is a component.
Core.Element = Symbol.named("Element")

return Core]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4F0AA06F8CF949428EE22C7FEB517129">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Roact = require(script.Parent)

	it("should load with all public APIs", function()
		local publicApi = {
			createElement = "function",
			createRef = "function",
			mount = "function",
			unmount = "function",
			reconcile = "function",
			oneChild = "function",
			setGlobalConfig = "function",
			getGlobalConfigValue = "function",

			-- These functions are deprecated and will throw warnings soon!
			reify = "function",
			teardown = "function",

			Component = true,
			PureComponent = true,
			Portal = true,
			Children = true,
			Event = true,
			Change = true,
			Ref = true,
			None = true,
			Element = true,
			UNSTABLE = true,
		}

		expect(Roact).to.be.ok()

		for key, valueType in pairs(publicApi) do
			local success
			if typeof(valueType) == "string" then
				success = typeof(Roact[key]) == valueType
			else
				success = Roact[key] ~= nil
			end

			if not success then
				local existence = typeof(valueType) == "boolean" and "present" or "of type " .. valueType
				local message = (
					"Expected public API member %q to be %s, but instead it was of type %s"
				):format(tostring(key), existence, typeof(Roact[key]))

				error(message)
			end
		end

		for key in pairs(Roact) do
			if publicApi[key] == nil then
				local message = (
					"Found unknown public API key %q!"
				):format(tostring(key))

				error(message)
			end
		end
	end)

	describe("Props", function()
		it("should be passed to primitive components", function()
			local container = Instance.new("IntValue")

			local element = Roact.createElement("StringValue", {
				Value = "foo",
			})

			Roact.mount(element, container, "TestStringValue")

			local rbx = container:FindFirstChild("TestStringValue")

			expect(rbx).to.be.ok()
			expect(rbx.Value).to.equal("foo")
		end)

		it("should be passed to functional components", function()
			local testProp = {}

			local callCount = 0

			local function TestComponent(props)
				expect(props.testProp).to.equal(testProp)
				callCount = callCount + 1
			end

			local element = Roact.createElement(TestComponent, {
				testProp = testProp,
			})

			Roact.mount(element)

			-- The only guarantee is that the function will be invoked at least once
			expect(callCount > 0).to.equal(true)
		end)

		it("should be passed to stateful components", function()
			local testProp = {}

			local callCount = 0

			local TestComponent = Roact.Component:extend("TestComponent")

			function TestComponent:init(props)
				expect(props.testProp).to.equal(testProp)
				callCount = callCount + 1
			end

			function TestComponent:render()
			end

			local element = Roact.createElement(TestComponent, {
				testProp = testProp,
			})

			Roact.mount(element)

			expect(callCount).to.equal(1)
		end)
	end)

	describe("State", function()
		it("should trigger a re-render of child components", function()
			local renderCount = 0
			local listener = nil

			local TestChild = Roact.Component:extend("TestChild")

			function TestChild:render()
				renderCount = renderCount + 1
				return nil
			end

			local TestParent = Roact.Component:extend("TestParent")

			function TestParent:init(props)
				self.state = {
					value = 0,
				}
			end

			function TestParent:didMount()
				listener = function()
					self:setState({
						value = self.state.value + 1,
					})
				end
			end

			function TestParent:render()
				return Roact.createElement(TestChild, {
					value = self.state.value,
				})
			end

			local element = Roact.createElement(TestParent)
			Roact.mount(element)

			expect(renderCount >= 1).to.equal(true)
			expect(listener).to.be.a("function")

			listener()

			expect(renderCount >= 2).to.equal(true)
		end)
	end)

	describe("Context", function()
		it("should be passed to children through primitive and functional components", function()
			local testValue = {}

			local callCount = 0

			local ContextConsumer = Roact.Component:extend("ContextConsumer")

			function ContextConsumer:init(props)
				expect(self._context.testValue).to.equal(testValue)

				callCount = callCount + 1
			end

			function ContextConsumer:render()
				return
			end

			local function ContextBarrier(props)
				return Roact.createElement(ContextConsumer)
			end

			local ContextProvider = Roact.Component:extend("ContextProvider")

			function ContextProvider:init(props)
				self._context.testValue = props.testValue
			end

			function ContextProvider:render()
				return Roact.createElement("Frame", {}, {
					Child = Roact.createElement(ContextBarrier),
				})
			end

			local element = Roact.createElement(ContextProvider, {
				testValue = testValue,
			})

			Roact.mount(element)

			expect(callCount).to.equal(1)
		end)
	end)

	describe("Ref", function()
		it("should call back with a Roblox object after properties and children", function()
			local callCount = 0

			local function ref(rbx)
				expect(rbx).to.be.ok()
				expect(rbx.ClassName).to.equal("StringValue")
				expect(rbx.Value).to.equal("Hey!")
				expect(rbx.Name).to.equal("RefTest")
				expect(#rbx:GetChildren()).to.equal(1)

				callCount = callCount + 1
			end

			local element = Roact.createElement("StringValue", {
				Value = "Hey!",
				[Roact.Ref] = ref,
			}, {
				TestChild = Roact.createElement("StringValue"),
			})

			Roact.mount(element, nil, "RefTest")

			expect(callCount).to.equal(1)
		end)

		it("should pass nil to refs for tearing down", function()
			local callCount = 0
			local currentRef

			local function ref(rbx)
				currentRef = rbx
				callCount = callCount + 1
			end

			local element = Roact.createElement("StringValue", {
				[Roact.Ref] = ref,
			})

			local instance = Roact.mount(element, nil, "RefTest")

			expect(callCount).to.equal(1)
			expect(currentRef).to.be.ok()
			expect(currentRef.Name).to.equal("RefTest")

			Roact.unmount(instance)

			expect(callCount).to.equal(2)
			expect(currentRef).to.equal(nil)
		end)

		it("should tear down refs when switched out of the tree", function()
			local updateMethod
			local refCount = 0
			local currentRef

			local function ref(rbx)
				currentRef = rbx
				refCount = refCount + 1
			end

			local function RefWrapper()
				return Roact.createElement("StringValue", {
					Value = "ooba ooba",
					[Roact.Ref] = ref,
				})
			end

			local Root = Roact.Component:extend("RefTestRoot")

			function Root:init()
				updateMethod = function(show)
					self:setState({
						show = show,
					})
				end
			end

			function Root:render()
				if self.state.show then
					return Roact.createElement(RefWrapper)
				end
			end

			local element = Roact.createElement(Root)
			Roact.mount(element)

			expect(refCount).to.equal(0)
			expect(currentRef).to.equal(nil)

			updateMethod(true)

			expect(refCount).to.equal(1)
			expect(currentRef.Value).to.equal("ooba ooba")

			updateMethod(false)

			expect(refCount).to.equal(2)
			expect(currentRef).to.equal(nil)
		end)
	end)

	describe("Portal", function()
		it("should place all children as children of the target Roblox instance", function()
			local target = Instance.new("Folder")

			local function FunctionalComponent(props)
				local intValue = props.value

				return Roact.createElement("IntValue", {
					Value = intValue,
				})
			end

			local portal = Roact.createElement(Roact.Portal, {
				target = target
			}, {
				folderOne = Roact.createElement("Folder"),
				folderTwo = Roact.createElement("Folder"),
				intValueOne = Roact.createElement(FunctionalComponent, {
					value = 42,
				}),
			})
			Roact.mount(portal)

			expect(target:FindFirstChild("folderOne")).to.be.ok()
			expect(target:FindFirstChild("folderTwo")).to.be.ok()
			expect(target:FindFirstChild("intValueOne")).to.be.ok()
			expect(target:FindFirstChild("intValueOne").Value).to.equal(42)
		end)

		it("should error if the target is nil", function()
			local portal = Roact.createElement(Roact.Portal, {}, {
				folderOne = Roact.createElement("Folder"),
				folderTwo = Roact.createElement("Folder"),
			})

			expect(function()
				Roact.mount(portal)
			end).to.throw()
		end)

		it("should error if the target is not a Roblox instance", function()
			local portal = Roact.createElement(Roact.Portal, {
					target = "NotARobloxInstance",
				}, {
				folderOne = Roact.createElement("Folder"),
				folderTwo = Roact.createElement("Folder"),
			})

			expect(function()
				Roact.mount(portal)
			end).to.throw()
		end)

		it("should update if parent changes the target", function()
			local targetOne = Instance.new("Folder")
			local targetTwo = Instance.new("Folder")
			local countWillUnmount = 0
			local changeState

			local TestUnmountComponent = Roact.Component:extend("TestUnmountComponent")

			function TestUnmountComponent:render()
				return nil
			end

			function TestUnmountComponent:willUnmount()
				countWillUnmount = countWillUnmount + 1
			end

			local PortalContainer = Roact.Component:extend("PortalContainer")

			function PortalContainer:init()
				self.state = {
					target = targetOne,
				}
			end

			function PortalContainer:render()
				return Roact.createElement(Roact.Portal, {
					target = self.state.target,
				}, {
					folderOne = Roact.createElement("Folder"),
					folderTwo = Roact.createElement("Folder"),
					testUnmount = Roact.createElement(TestUnmountComponent),
				})
			end

			function PortalContainer:didMount()
				expect(self.state.target:FindFirstChild("folderOne")).to.be.ok()
				expect(self.state.target:FindFirstChild("folderTwo")).to.be.ok()

				changeState = function(newState)
					self:setState(newState)
				end
			end

			Roact.mount(Roact.createElement(PortalContainer))

			expect(targetOne:FindFirstChild("folderOne")).to.be.ok()
			expect(targetOne:FindFirstChild("folderTwo")).to.be.ok()

			changeState({
				target = targetTwo,
			})

			expect(countWillUnmount).to.equal(1)

			expect(targetOne:FindFirstChild("folderOne")).never.to.be.ok()
			expect(targetOne:FindFirstChild("folderTwo")).never.to.be.ok()
			expect(targetTwo:FindFirstChild("folderOne")).to.be.ok()
			expect(targetTwo:FindFirstChild("folderTwo")).to.be.ok()
		end)

		it("should update Roblox instance properties when relevant parent props are changed", function()
			local target = Instance.new("Folder")
			local changeState

			local PortalContainer = Roact.Component:extend("PortalContainer")

			function PortalContainer:init()
				self.state = {
					value = "initialStringValue",
				}
			end

			function PortalContainer:render()
				return Roact.createElement(Roact.Portal, {
					target = target,
				}, {
					TestStringValue = Roact.createElement("StringValue", {
						Value = self.state.value,
					})
				})
			end

			function PortalContainer:didMount()
				changeState = function(newState)
					self:setState(newState)
				end
			end

			Roact.mount(Roact.createElement(PortalContainer))

			expect(target:FindFirstChild("TestStringValue")).to.be.ok()
			expect(target:FindFirstChild("TestStringValue").Value).to.equal("initialStringValue")

			changeState({
				value = "newStringValue",
			})

			expect(target:FindFirstChild("TestStringValue")).to.be.ok()
			expect(target:FindFirstChild("TestStringValue").Value).to.equal("newStringValue")
		end)

		it("should properly teardown the Portal", function()
			local target = Instance.new("Folder")

			local portal = Roact.createElement(Roact.Portal, {
				target = target
			}, {
				folderOne = Roact.createElement("Folder"),
				folderTwo = Roact.createElement("Folder"),
			})
			local instance = Roact.mount(portal)

			local folderThree = Instance.new("Folder")
			folderThree.Name = "folderThree"
			folderThree.Parent = target

			expect(target:FindFirstChild("folderOne")).to.be.ok()
			expect(target:FindFirstChild("folderTwo")).to.be.ok()
			expect(target:FindFirstChild("folderThree")).to.be.ok()

			Roact.unmount(instance)

			expect(target:FindFirstChild("folderOne")).never.to.be.ok()
			expect(target:FindFirstChild("folderTwo")).never.to.be.ok()
			expect(target:FindFirstChild("folderThree")).to.be.ok()
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF035E791655449B4BE1A0CCCB1A366D2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PureComponent</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX69120BCFEF8B49A1A226554A02AB5EEA">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SingleEventManager.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local SingleEventManager = require(script.Parent.SingleEventManager)

	describe("new", function()
		it("should create a SingleEventManager", function()
			local manager = SingleEventManager.new()

			expect(manager).to.be.ok()
		end)
	end)

	describe("connect", function()
		it("should connect to events on an object", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local callCount = 0

			manager:connect(target, "Event", function(rbx, arg)
				expect(rbx).to.equal(target)
				expect(arg).to.equal("foo")
				callCount = callCount + 1
			end)

			target:Fire("foo")

			expect(callCount).to.equal(1)

			target:Fire("foo")

			expect(callCount).to.equal(2)
		end)

		it("should only connect one handler at a time", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local callCountA = 0
			local callCountB = 0

			manager:connect(target, "Event", function(rbx)
				expect(rbx).to.equal(target)
				callCountA = callCountA + 1
			end)

			manager:connect(target, "Event", function(rbx)
				expect(rbx).to.equal(target)
				callCountB = callCountB + 1
			end)

			target:Fire("foo")

			expect(callCountA).to.equal(0)
			expect(callCountB).to.equal(1)
		end)

		it("shouldn't conflate different event handlers", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local callCountEvent = 0
			local callCountChanged = 0

			manager:connect(target, "Event", function(rbx)
				expect(rbx).to.equal(target)
				callCountEvent = callCountEvent + 1
			end)

			manager:connect(target, "Changed", function(rbx)
				expect(rbx).to.equal(target)
				callCountChanged = callCountChanged + 1
			end)

			target:Fire()

			expect(callCountEvent).to.equal(1)
			expect(callCountChanged).to.equal(0)

			target.Name = "unlimited power!"

			expect(callCountEvent).to.equal(1)
			expect(callCountChanged).to.equal(1)
		end)
	end)

	describe("connectProperty", function()
		it("should connect to property changes", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local changeCount = 0

			manager:connectProperty(target, "Name", function(rbx)
				changeCount = changeCount + 1
			end)

			target.Name = "hi"
			expect(changeCount).to.equal(1)
		end)

		it("should disconnect the existing connection if present", function()
			local target = Instance.new("IntValue")
			local manager = SingleEventManager.new()

			local changeCountA = 0
			local changeCountB = 0

			manager:connectProperty(target, "Name", function(rbx)
				changeCountA = changeCountA + 1
			end)

			manager:connectProperty(target, "Name", function(rbx)
				changeCountB = changeCountB + 1
			end)

			target.Name = "hi"
			expect(changeCountA).to.equal(0)
			expect(changeCountB).to.equal(1)
		end)

		it("should only connect to the property specified", function()
			local target = Instance.new("IntValue")
			local manager = SingleEventManager.new()

			local changeCount = 0

			manager:connectProperty(target, "Name", function(rbx)
				changeCount = changeCount + 1
			end)

			target.Name = "hi"
			target.Value = 0
			expect(changeCount).to.equal(1)
		end)
	end)

	describe("disconnect", function()
		it("should disconnect handlers on an object", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local callCount = 0

			manager:connect(target, "Event", function(rbx)
				expect(rbx).to.equal(target)
				callCount = callCount + 1
			end)

			target:Fire()

			expect(callCount).to.equal(1)

			manager:disconnect(target, "Event")

			target:Fire()

			expect(callCount).to.equal(1)
		end)

		it("should not disconnect unrelated connections", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local callCountEvent = 0
			local callCountChanged = 0

			manager:connect(target, "Event", function(rbx)
				expect(rbx).to.equal(target)
				callCountEvent = callCountEvent + 1
			end)

			manager:connect(target, "Changed", function(rbx)
				expect(rbx).to.equal(target)
				callCountChanged = callCountChanged + 1
			end)

			target:Fire()
			target.Name = "bar"

			expect(callCountEvent).to.equal(1)
			expect(callCountChanged).to.equal(1)

			manager:disconnect(target, "Event")

			target:Fire()
			target.Name = "foo"

			expect(callCountEvent).to.equal(1)
			expect(callCountChanged).to.equal(2)
		end)

		it("should succeed with no events attached", function()
			local manager = SingleEventManager.new()
			local target = Instance.new("BindableEvent")

			manager:disconnect(target, "Event")
		end)
	end)

	describe("disconnectProperty", function()
		it("should disconnect property change handlers on an object", function()
			local target = Instance.new("IntValue")
			local manager = SingleEventManager.new()

			local changeCount = 0

			manager:connectProperty(target, "Name", function(rbx)
				changeCount = changeCount + 1
			end)

			target.Name = "hi"
			expect(changeCount).to.equal(1)

			manager:disconnectProperty(target, "Name")
			target.Name = "test"
			expect(changeCount).to.equal(1)
		end)

		it("should succeed even if no handler is attached", function()
			local target = Instance.new("IntValue")
			local manager = SingleEventManager.new()

			manager:disconnectProperty(target, "Name")
		end)
	end)

	describe("disconnectAll", function()
		it("should disconnect all listeners on an object", function()
			local target = Instance.new("BindableEvent")
			local manager = SingleEventManager.new()

			local callCountEvent = 0
			local callCountChanged = 0
			local changeCount = 0

			manager:connect(target, "Event", function(rbx)
				expect(rbx).to.equal(target)
				callCountEvent = callCountEvent + 1
			end)

			manager:connect(target, "Changed", function(rbx)
				expect(rbx).to.equal(target)
				callCountChanged = callCountChanged + 1
			end)

			manager:connectProperty(target, "Name", function(rbx)
				expect(rbx).to.equal(target)
				changeCount = changeCount + 1
			end)

			target:Fire()
			target.Name = "bar"

			expect(callCountEvent).to.equal(1)
			expect(callCountChanged).to.equal(1)
			expect(changeCount).to.equal(1)

			manager:disconnectAll(target)

			target:Fire()
			target.Name = "foo"

			expect(callCountEvent).to.equal(1)
			expect(callCountChanged).to.equal(1)
			expect(changeCount).to.equal(1)
		end)

		it("should succeed with no events attached", function()
			local target = Instance.new("StringValue")
			local manager = SingleEventManager.new()

			manager:disconnectAll(target)
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6B77F5C874204E0F8F3A789C637E1617">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ReconcilerCompat.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local ReconcilerCompat = require(script.Parent.ReconcilerCompat)
	local Reconciler = require(script.Parent.Reconciler)
	local createElement = require(script.Parent.createElement)

	it("reify should only warn once per call site", function()
		local callCount = 0
		local lastMessage
		ReconcilerCompat._warn = function(message)
			callCount = callCount + 1
			lastMessage = message
		end

		-- We're using a loop so that we get the same stack trace and only one
		-- warning hopefully.
		for _ = 1, 2 do
			local handle = ReconcilerCompat.reify(createElement("StringValue"))
			Reconciler.unmount(handle)
		end

		expect(callCount).to.equal(1)
		expect(lastMessage:find("ReconcilerCompat.spec")).to.be.ok()

		-- This is a different call site, which should trigger another warning.
		local handle = ReconcilerCompat.reify(createElement("StringValue"))
		Reconciler.unmount(handle)

		expect(callCount).to.equal(2)
		expect(lastMessage:find("ReconcilerCompat.spec")).to.be.ok()

		ReconcilerCompat._warn = warn
	end)

	it("teardown should only warn once per call site", function()
		local callCount = 0
		local lastMessage
		ReconcilerCompat._warn = function(message)
			callCount = callCount + 1
			lastMessage = message
		end

		-- We're using a loop so that we get the same stack trace and only one
		-- warning hopefully.
		for _ = 1, 2 do
			local handle = Reconciler.mount(createElement("StringValue"))
			ReconcilerCompat.teardown(handle)
		end

		expect(callCount).to.equal(1)
		expect(lastMessage:find("ReconcilerCompat.spec")).to.be.ok()

		-- This is a different call site, which should trigger another warning.
		local handle = Reconciler.mount(createElement("StringValue"))
		ReconcilerCompat.teardown(handle)

		expect(callCount).to.equal(2)
		expect(lastMessage:find("ReconcilerCompat.spec")).to.be.ok()

		ReconcilerCompat._warn = warn
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX64B9110986424495A0B63E297032E996">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Component.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Core = require(script.Parent.Core)
	local createElement = require(script.Parent.createElement)
	local Reconciler = require(script.Parent.Reconciler)
	local GlobalConfig = require(script.Parent.GlobalConfig)

	local Component = require(script.Parent.Component)

	it("should be extendable", function()
		local MyComponent = Component:extend("The Senate")

		expect(MyComponent).to.be.ok()
		expect(MyComponent._new).to.be.ok()
	end)

	it("should prevent extending a user component", function()
		local MyComponent = Component:extend("Sheev")

		expect(function()
			MyComponent:extend("Frank")
		end).to.throw()
	end)

	it("should use a given name", function()
		local MyComponent = Component:extend("FooBar")

		local name = tostring(MyComponent)

		expect(name).to.be.a("string")
		expect(name:find("FooBar")).to.be.ok()
	end)

	it("should throw on render with a useful message by default", function()
		local MyComponent = Component:extend("Foo")

		local instance = MyComponent._new({})

		expect(instance).to.be.ok()

		local ok, err = pcall(function()
			instance:render()
		end)

		expect(ok).to.equal(false)
		expect(err:find("Foo")).to.be.ok()
	end)

	it("should pass props to the initializer", function()
		local MyComponent = Component:extend("Wazo")

		local callCount = 0
		local testProps = {}

		function MyComponent:init(props)
			expect(props).to.equal(testProps)
			callCount = callCount + 1
		end

		MyComponent._new(testProps)

		expect(callCount).to.equal(1)
	end)

	it("should fire didMount and willUnmount when reified", function()
		local MyComponent = Component:extend("MyComponent")
		local mounts = 0
		local unmounts = 0

		function MyComponent:render()
			return nil
		end

		function MyComponent:didMount()
			mounts = mounts + 1
		end

		function MyComponent:willUnmount()
			unmounts = unmounts + 1
		end

		expect(mounts).to.equal(0)
		expect(unmounts).to.equal(0)

		local instance = Reconciler.mount(createElement(MyComponent))

		expect(mounts).to.equal(1)
		expect(unmounts).to.equal(0)

		Reconciler.unmount(instance)

		expect(mounts).to.equal(1)
		expect(unmounts).to.equal(1)
	end)

	it("should provide the proper arguments to willUpdate and didUpdate", function()
		local willUpdateCount = 0
		local didUpdateCount = 0
		local prevProps
		local prevState
		local nextProps
		local nextState
		local setValue

		local Child = Component:extend("PureChild")

		function Child:willUpdate(newProps, newState)
			nextProps = assert(newProps)
			nextState = assert(newState)
			prevProps = assert(self.props)
			prevState = assert(self.state)
			willUpdateCount = willUpdateCount + 1
		end

		function Child:didUpdate(oldProps, oldState)
			assert(oldProps)
			assert(oldState)
			expect(prevProps.value).to.equal(oldProps.value)
			expect(prevState.value).to.equal(oldState.value)
			expect(nextProps.value).to.equal(self.props.value)
			expect(nextState.value).to.equal(self.state.value)
			didUpdateCount = didUpdateCount + 1
		end

		function Child:render()
			return nil
		end

		local Container = Component:extend("Container")

		function Container:init()
			self.state = {
				value = 0,
			}
		end

		function Container:didMount()
			setValue = function(value)
				self:setState({
					value = value,
				})
			end
		end

		function Container:willUnmount()
			setValue = nil
		end

		function Container:render()
			return createElement(Child, {
				value = self.state.value,
			})
		end

		local element = createElement(Container)
		local instance = Reconciler.mount(element)

		expect(willUpdateCount).to.equal(0)
		expect(didUpdateCount).to.equal(0)

		setValue(1)

		expect(willUpdateCount).to.equal(1)
		expect(didUpdateCount).to.equal(1)

		setValue(1)

		expect(willUpdateCount).to.equal(2)
		expect(didUpdateCount).to.equal(2)

		setValue(2)

		expect(willUpdateCount).to.equal(3)
		expect(didUpdateCount).to.equal(3)

		setValue(1)

		expect(willUpdateCount).to.equal(4)
		expect(didUpdateCount).to.equal(4)

		Reconciler.unmount(instance)
	end)

	it("should call getDerivedStateFromProps appropriately", function()
		local TestComponent = Component:extend("TestComponent")
		local getStateCallback

		function TestComponent.getDerivedStateFromProps(newProps, oldState)
			return {
				visible = newProps.visible
			}
		end

		function TestComponent:init(props)
			self.state = {
				visible = false
			}

			getStateCallback = function()
				return self.state
			end
		end

		function TestComponent:render() end

		local handle = Reconciler.mount(createElement(TestComponent, {
			visible = true
		}))

		local state = getStateCallback()
		expect(state.visible).to.equal(true)

		handle = Reconciler.reconcile(handle, createElement(TestComponent, {
			visible = 123
		}))

		state = getStateCallback()
		expect(state.visible).to.equal(123)

		Reconciler.unmount(handle)
	end)

	it("should pull values from defaultProps where appropriate", function()
		local lastProps
		local TestComponent = Component:extend("TestComponent")

		TestComponent.defaultProps = {
			foo = "hello",
			bar = "world",
		}

		function TestComponent:render()
			lastProps = self.props
			return nil
		end

		local handle = Reconciler.mount(createElement(TestComponent))

		expect(lastProps).to.be.a("table")
		expect(lastProps.foo).to.equal("hello")
		expect(lastProps.bar).to.equal("world")

		Reconciler.unmount(handle)

		lastProps = nil
		handle = Reconciler.mount(createElement(TestComponent, {
			foo = 5,
		}))

		expect(lastProps).to.be.a("table")
		expect(lastProps.foo).to.equal(5)
		expect(lastProps.bar).to.equal("world")

		Reconciler.unmount(handle)

		lastProps = nil
		handle = Reconciler.mount(createElement(TestComponent, {
			bar = false,
		}))

		expect(lastProps).to.be.a("table")
		expect(lastProps.foo).to.equal("hello")
		expect(lastProps.bar).to.equal(false)

		Reconciler.unmount(handle)
	end)

	it("should include defaultProps in props passed to shouldUpdate", function()
		local lastProps
		local TestComponent = Component:extend("TestComponent")

		TestComponent.defaultProps = {
			foo = "hello",
			bar = "world",
		}

		function TestComponent:shouldUpdate(newProps)
			lastProps = newProps
			return true
		end

		function TestComponent:render()
			return nil
		end

		local handle = Reconciler.mount(createElement(TestComponent, {}))
		Reconciler.reconcile(handle, createElement(TestComponent, {
			baz = "!",
		}))

		expect(lastProps).to.be.a("table")
		expect(lastProps.foo).to.equal("hello")
		expect(lastProps.bar).to.equal("world")
		expect(lastProps.baz).to.equal("!")

		Reconciler.unmount(handle)
	end)

	it("should fall back to defaultProps correctly after an update", function()
		local lastProps
		local TestComponent = Component:extend("TestComponent")

		TestComponent.defaultProps = {
			foo = "hello",
			bar = "world",
		}

		function TestComponent:render()
			lastProps = self.props
			return nil
		end

		local handle = Reconciler.mount(createElement(TestComponent, {
			foo = "hey"
		}))

		expect(lastProps).to.be.a("table")
		expect(lastProps.foo).to.equal("hey")
		expect(lastProps.bar).to.equal("world")

		handle = Reconciler.reconcile(handle, createElement(TestComponent))

		expect(lastProps).to.be.a("table")
		expect(lastProps.foo).to.equal("hello")
		expect(lastProps.bar).to.equal("world")

		Reconciler.unmount(handle)
	end)

	it("should pass defaultProps in init and first getDerivedStateFromProps", function()
		local derivedProps = nil
		local initProps = nil
		local initSelfProps = nil

		local TestComponent = Component:extend("TestComponent")

		TestComponent.defaultProps = {
			heyNow = "get your game on",
		}

		function TestComponent:init(props)
			initProps = props
			initSelfProps = self.props
		end

		function TestComponent:render()
			return nil
		end

		function TestComponent.getDerivedStateFromProps(nextProps, lastState)
			derivedProps = nextProps
		end

		local tree = createElement(TestComponent)
		local handle = Reconciler.mount(tree)

		expect(derivedProps).to.be.ok()
		expect(initProps).to.be.ok()
		expect(initSelfProps).to.be.ok()

		expect(derivedProps.heyNow).to.equal(TestComponent.defaultProps.heyNow)
		expect(initProps.heyNow).to.equal(TestComponent.defaultProps.heyNow)

		expect(initProps).to.equal(initSelfProps)

		Reconciler.unmount(handle)
	end)

	describe("setState", function()
		it("should throw when called in render", function()
			local RenderComponent = Component:extend("RenderComponent")

			function RenderComponent:render()
				self:setState({
					a = 1
				})
			end

			local renderElement = createElement(RenderComponent)

			expect(function()
				Reconciler.mount(renderElement)
			end).to.throw()
		end)

		it("should throw when called in shouldUpdate", function()
			local TestComponent = Component:extend("TestComponent")

			local triggerTest

			function TestComponent:init()
				triggerTest = function()
					self:setState({
						a = 1
					})
				end
			end

			function TestComponent:render()
				return nil
			end

			function TestComponent:shouldUpdate()
				self:setState({
					a = 1
				})
			end

			local testElement = createElement(TestComponent)

			expect(function()
				Reconciler.mount(testElement)
				triggerTest()
			end).to.throw()
		end)

		it("should throw when called in willUnmount", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:render()
				return nil
			end

			function TestComponent:willUnmount()
				self:setState({
					a = 1
				})
			end

			local element = createElement(TestComponent)
			local instance = Reconciler.mount(element)

			expect(function()
				Reconciler.unmount(instance)
			end).to.throw()
		end)

		it("should only render once when called in willUpdate", function()
			local TestComponent = Component:extend("TestComponent")
			local forceUpdate

			function TestComponent:init()
				forceUpdate = function()
					self:_forceUpdate()
				end
			end

			local renderCount = 0
			function TestComponent:render()
				renderCount = renderCount + 1
				return nil
			end

			function TestComponent:willUpdate()
				self:setState({
					a = 1
				})
			end

			local testElement = createElement(TestComponent)

			local handle = Reconciler.mount(testElement)

			expect(renderCount).to.equal(1)

			forceUpdate()

			expect(renderCount).to.equal(2)

			Reconciler.unmount(handle)
		end)

		it("should only render once when called in init", function()
			local TestComponent = Component:extend("TestComponent")

			function TestComponent:init()
				self:setState({
					a = 7,
				})
			end

			local renderCount = 0
			function TestComponent:render()
				renderCount = renderCount + 1
				return nil
			end

			local testElement = createElement(TestComponent)

			local handle = Reconciler.mount(testElement)

			expect(renderCount).to.equal(1)

			Reconciler.unmount(handle)
		end)

		it("should remove values from state when the value is Core.None", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				self.state = {
					value = 0
				}
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = Reconciler.mount(element)

			expect(getStateCallback().value).to.equal(0)

			setStateCallback({
				value = Core.None
			})

			expect(getStateCallback().value).to.equal(nil)

			Reconciler.unmount(instance)
		end)

		it("should invoke functions to compute a partial state", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback, getStateCallback, getPropsCallback

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				getStateCallback = function()
					return self.state
				end

				getPropsCallback = function()
					return self.props
				end

				self.state = {
					value = 0
				}
			end

			function TestComponent:render()
				return nil
			end

			local element = createElement(TestComponent)
			local instance = Reconciler.mount(element)

			expect(getStateCallback().value).to.equal(0)

			setStateCallback(function(state, props)
				expect(state).to.equal(getStateCallback())
				expect(props).to.equal(getPropsCallback())

				return {
					value = state.value + 1
				}
			end)

			expect(getStateCallback().value).to.equal(1)

			Reconciler.unmount(instance)
		end)

		it("should cancel rendering if the function returns nil", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback
			local renderCount = 0

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				self.state = {
					value = 0
				}
			end

			function TestComponent:render()
				renderCount = renderCount + 1
				return nil
			end

			local element = createElement(TestComponent)
			local instance = Reconciler.mount(element)
			expect(renderCount).to.equal(1)

			setStateCallback(function(state, props)
				return nil
			end)

			expect(renderCount).to.equal(1)

			Reconciler.unmount(instance)
		end)

		it("should not call getDerivedStateFromProps on setState", function()
			local TestComponent = Component:extend("TestComponent")
			local setStateCallback
			local getDerivedStateFromPropsCount = 0

			function TestComponent:init()
				setStateCallback = function(newState)
					self:setState(newState)
				end

				self.state = {
					value = 0
				}
			end

			function TestComponent:render()
				return nil
			end

			function TestComponent.getDerivedStateFromProps(nextProps, lastState)
				getDerivedStateFromPropsCount = getDerivedStateFromPropsCount + 1
			end

			local element = createElement(TestComponent, {
				someProp = 1,
			})

			local instance = Reconciler.mount(element)
			expect(getDerivedStateFromPropsCount).to.equal(1)

			setStateCallback({
				value = 1,
			})
			expect(getDerivedStateFromPropsCount).to.equal(1)


			Reconciler.unmount(instance)
		end)
	end)

	describe("getElementTraceback", function()
		it("should return stack traces", function()
			local stackTraceCallback = nil

			GlobalConfig.set({
				elementTracing = true
			})

			local TestComponent = Component:extend("TestComponent")

			function TestComponent:init()
				stackTraceCallback = function()
					return self:getElementTraceback()
				end
			end

			function TestComponent:render()
				return createElement("StringValue")
			end

			local handle = Reconciler.mount(createElement(TestComponent))
			expect(stackTraceCallback()).to.be.ok()
			Reconciler.unmount(handle)
			GlobalConfig.reset()
		end)

		it("should return nil when elementTracing is off", function()
			local stackTraceCallback = nil

			local TestComponent = Component:extend("TestComponent")

			function TestComponent:init()
				stackTraceCallback = function()
					return self:getElementTraceback()
				end
			end

			function TestComponent:render()
				return createElement("StringValue")
			end

			local handle = Reconciler.mount(createElement(TestComponent))
			expect(stackTraceCallback()).to.never.be.ok()
			Reconciler.unmount(handle)
		end)
	end)
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX56DDC92D04C8400196EBD01081799E75">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Config.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Config = require(script.Parent.Config)

	it("should accept valid configuration", function()
		local config = Config.new()

		expect(config.getValue("elementTracing")).to.equal(false)

		config.set({
			elementTracing = true,
		})

		expect(config.getValue("elementTracing")).to.equal(true)
	end)

	it("should reject invalid configuration keys", function()
		local config = Config.new()

		local badKey = "garblegoop"

		local ok, err = pcall(function()
			config.set({
				[badKey] = true,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention our bad key somewhere.
		expect(err:find(badKey)).to.be.ok()
	end)

	it("should reject invalid configuration values", function()
		local config = Config.new()

		local goodKey = "elementTracing"
		local badValue = "Hello there!"

		local ok, err = pcall(function()
			config.set({
				[goodKey] = badValue,
			})
		end)

		expect(ok).to.equal(false)

		-- The error should mention both our key and value
		expect(err:find(goodKey)).to.be.ok()
		expect(err:find(badValue)).to.be.ok()
	end)

	it("should prevent setting configuration more than once", function()
		local config = Config.new()

		-- We're going to use the name of this function to see if the traceback
		-- was correct.
		local function setEmptyConfig()
			config.set({})
		end

		setEmptyConfig()

		local ok, err = pcall(setEmptyConfig)

		expect(ok).to.equal(false)

		-- The error should mention the stack trace with the original set call.
		expect(err:find("setEmptyConfig")).to.be.ok()
	end)

	it("should reset to default values after invoking reset()", function()
		local config = Config.new()

		expect(config.getValue("elementTracing")).to.equal(false)

		config.set({
			elementTracing = true,
		})

		expect(config.getValue("elementTracing")).to.equal(true)

		config.reset()

		expect(config.getValue("elementTracing")).to.equal(false)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0CDEBBCD7FD343BE96065A4CD3A4221C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GlobalConfig</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8E6D485FC32A4AA5917EF225C4F7796C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ReconcilerCompat</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Reconciler = require(script.Parent.Reconciler)

local warnedLocations = {}

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local ReconcilerCompat = {}

--[[
	Exposed as a method so that test cases can override `warn`.
]]
ReconcilerCompat._warn = warn

local function warnOnce(message)
	local trace = debug.traceback(message, 3)
	if warnedLocations[trace] then
		return
	end

	warnedLocations[trace] = true

	ReconcilerCompat._warn(trace)
end

function ReconcilerCompat.reify(...)
	warnOnce(reifyMessage)

	return Reconciler.mount(...)
end

function ReconcilerCompat.teardown(...)
	warnOnce(teardownMessage)

	return Reconciler.unmount(...)
end

return ReconcilerCompat]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8D06F7D8A8F446E1A81E050528AFC28C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Symbol.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Symbol = require(script.Parent.Symbol)

	describe("named", function()
		it("should give an opaque object", function()
			local symbol = Symbol.named("foo")

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to the given name", function()
			local symbol = Symbol.named("foo")

			expect(tostring(symbol):find("foo")).to.be.ok()
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.named("abc")
			local symbolB = Symbol.named("abc")

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)

	describe("unnamed", function()
		it("should give an opaque object", function()
			local symbol = Symbol.unnamed()

			expect(symbol).to.be.a("userdata")
		end)

		it("should coerce to some string", function()
			local symbol = Symbol.unnamed()

			expect(tostring(symbol)).to.be.a("string")
		end)

		it("should be unique when constructed", function()
			local symbolA = Symbol.unnamed()
			local symbolB = Symbol.unnamed()

			expect(symbolA).never.to.equal(symbolB)
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXF6B840D113624467A0646844FA8A5D64">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Promise</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local PROMISE_DEBUG = false

--[[
	Packs a number of arguments into a table and returns its length.
	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)

	return len, { ... }
end

--[[
	wpcallPacked is a version of xpcall that:
	* Returns the length of the result first
	* Returns the result packed into a table
	* Passes extra arguments through to the passed function; xpcall doesn't
	* Issues a warning if PROMISE_DEBUG is enabled
]]
local function wpcallPacked(f, ...)
	local argsLength, args = pack(...)

	local body = function()
		return f(unpack(args, 1, argsLength))
	end

	local resultLength, result = pack(xpcall(body, debug.traceback))

	-- If promise debugging is on, warn whenever a pcall fails.
	-- This is useful for debugging issues within the Promise implementation
	-- itself.
	if PROMISE_DEBUG and not result[1] then
		warn(result[2])
	end

	return resultLength, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local resultLength, result = wpcallPacked(callback, ...)
		local ok = result[1]

		if ok then
			resolve(unpack(result, 2, resultLength))
		else
			reject(unpack(result, 2, resultLength))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local function createSymbol(name)
	assert(type(name) == "string", "createSymbol requires `name` to be a string.")

	local symbol = newproxy(true)

	getmetatable(symbol).__tostring = function()
		return ("Symbol(%s)"):format(name)
	end

	return symbol
end

local PromiseMarker = createSymbol("PromiseMarker")

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = {
	Started = createSymbol("Started"),
	Resolved = createSymbol("Resolved"),
	Rejected = createSymbol("Rejected"),
}

--[[
	Constructs a new Promise with the given initializing callback.
	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.
	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.
	For example:
		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end
		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)
]]
function Promise.new(callback)
	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		[PromiseMarker] = true,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- If an error occurs with no observers, this will be set.
		_unhandledRejection = false,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
	}

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local _, result = wpcallPacked(callback, resolve, reject)
	local ok = result[1]
	local err = result[2]

	if not ok and self._status == Promise.Status.Started then
		reject(err)
	end

	return self
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(promises)
	if type(promises) ~= "table" then
		error("Please pass a list of promises to Promise.all", 2)
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i = 1, #promises do
		if not Promise.is(promises[i]) then
			error(("Non-promise value passed into Promise.all at index #%d"):format(i), 2)
		end
	end

	return Promise.new(function(resolve, reject)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			resolvedValues[i] = ...
			resolvedCount = resolvedCount + 1

			if resolvedCount == #promises then
				resolve(resolvedValues)
			end
		end

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			promises[i]:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					reject(...)
				end
			)
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object[PromiseMarker] == true
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.
	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:andThen(successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Yield until the promise is completed.
	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:await()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local result
		local resultLength
		local bindable = Instance.new("BindableEvent")

		self:andThen(
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(true)
			end,
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(false)
			end
		)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		return ok, unpack(result, 1, resultLength)
	elseif self._status == Promise.Status.Resolved then
		return true, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return false, unpack(self._values, 1, self._valuesLength)
	end
end

--[[
	Intended for use in tests.
	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				self:_reject(...)
			end
		)

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		self._unhandledRejection = true
		local err = tostring((...))

		spawn(function()
			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
				err,
				self._source
			)
			warn(message)
		end)
	end
end

return Promise]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXACF2B5FCC1F34807AC59DBAECBE7C30B">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Promise = require(script.Parent)

	local function pack(...)
		local len = select("#", ...)

		return len, { ... }
	end

	describe("Promise.new", function()
		it("should instantiate with a callback", function()
			local promise = Promise.new(function() end)

			expect(promise).to.be.ok()
		end)

		it("should invoke the given callback with resolve and reject", function()
			local callCount = 0
			local resolveArg
			local rejectArg

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				resolveArg = resolve
				rejectArg = reject
			end)

			expect(promise).to.be.ok()

			expect(callCount).to.equal(1)
			expect(resolveArg).to.be.a("function")
			expect(rejectArg).to.be.a("function")
			expect(promise:getStatus()).to.equal(Promise.Status.Started)
		end)

		it("should resolve promises on resolve()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve)
				callCount = callCount + 1
				resolve()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
		end)

		it("should reject promises on reject()", function()
			local callCount = 0

			local promise = Promise.new(function(resolve, reject)
				callCount = callCount + 1
				reject()
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
		end)

		it("should reject on error in callback", function()
			local callCount = 0

			local promise = Promise.new(function()
				callCount = callCount + 1
				error("hahah")
			end)

			expect(promise).to.be.ok()
			expect(callCount).to.equal(1)
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]:find("hahah")).to.be.ok()

			-- Loosely check for the pieces of the stack trace we expect
			expect(promise._values[1]:find("init.spec")).to.be.ok()
			expect(promise._values[1]:find("new")).to.be.ok()
			expect(promise._values[1]:find("error")).to.be.ok()
		end)
	end)

	describe("Promise.resolve", function()
		it("should immediately resolve with a value", function()
			local promise = Promise.resolve(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)
		end)

		it("should chain onto passed promises", function()
			local promise = Promise.resolve(Promise.new(function(_, reject)
				reject(7)
			end))

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(7)
		end)
	end)

	describe("Promise.reject", function()
		it("should immediately reject with a value", function()
			local promise = Promise.reject(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)
		end)

		it("should pass a promise as-is as an error", function()
			local innerPromise = Promise.new(function(resolve)
				resolve(6)
			end)

			local promise = Promise.reject(innerPromise)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(innerPromise)
		end)
	end)

	describe("Promise:andThen", function()
		it("should chain onto resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.resolve(5)

			local chained = promise:andThen(
				function(...)
					argsLength, args = pack(...)
					callCount = callCount + 1
				end,
				function()
					badCallCount = badCallCount + 1
				end
			)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local promise = Promise.reject(5)

			local chained = promise:andThen(
				function(...)
					badCallCount = badCallCount + 1
				end,
				function(...)
					argsLength, args = pack(...)
					callCount = callCount + 1
				end
			)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(5)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(5)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously resolved promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(resolve)
				startResolution = resolve
			end)

			local chained = promise:andThen(
				function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end,
				function()
					badCallCount = badCallCount + 1
				end
			)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)

		it("should chain onto asynchronously rejected promises", function()
			local args
			local argsLength
			local callCount = 0
			local badCallCount = 0

			local startResolution
			local promise = Promise.new(function(_, reject)
				startResolution = reject
			end)

			local chained = promise:andThen(
				function()
					badCallCount = badCallCount + 1
				end,
				function(...)
					args = {...}
					argsLength = select("#", ...)
					callCount = callCount + 1
				end
			)

			expect(callCount).to.equal(0)
			expect(badCallCount).to.equal(0)

			startResolution(6)

			expect(badCallCount).to.equal(0)

			expect(callCount).to.equal(1)
			expect(argsLength).to.equal(1)
			expect(args[1]).to.equal(6)

			expect(promise).to.be.ok()
			expect(promise:getStatus()).to.equal(Promise.Status.Rejected)
			expect(promise._values[1]).to.equal(6)

			expect(chained).to.be.ok()
			expect(chained).never.to.equal(promise)
			expect(chained:getStatus()).to.equal(Promise.Status.Resolved)
			expect(#chained._values).to.equal(0)
		end)
	end)

	describe("Promise.all", function()
		it("should error if given something other than a table", function()
			expect(function()
				Promise.all(1)
			end).to.throw()
		end)

		it("should resolve instantly with an empty table if given no promises", function()
			local promise = Promise.all({})
			local success, value = promise:_unwrap()

			expect(success).to.equal(true)
			expect(promise:getStatus()).to.equal(Promise.Status.Resolved)
			expect(value).to.be.a("table")
			expect(next(value)).to.equal(nil)
		end)

		it("should error if given non-promise values", function()
			expect(function()
				Promise.all({{}, {}, {}})
			end).to.throw()
		end)

		it("should wait for all promises to be resolved and return their values", function()
			local resolveFunctions = {}

			local testValuesLength, testValues = pack(1, "A string", nil, false)

			local promises = {}

			for i = 1, testValuesLength do
				promises[i] = Promise.new(function(resolve)
					resolveFunctions[i] = {resolve, testValues[i]}
				end)
			end

			local combinedPromise = Promise.all(promises)

			for _, resolve in ipairs(resolveFunctions) do
				expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)
				resolve[1](resolve[2])
			end

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, resolved = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(2)
			expect(success).to.equal(true)
			expect(resolved).to.be.a("table")
			expect(#resolved).to.equal(#promises)

			for i = 1, testValuesLength do
				expect(resolved[i]).to.equal(testValues[i])
			end
		end)

		it("should reject if any individual promise rejected", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			resolveB("foo", "bar")
			rejectA("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should not resolve if resolved after rejecting", function()
			local rejectA
			local resolveB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(resolve)
				resolveB = resolve
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("baz", "qux")
			resolveB("foo", "bar")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("baz")
			expect(second).to.equal("qux")
		end)

		it("should only reject once", function()
			local rejectA
			local rejectB

			local a = Promise.new(function(_, reject)
				rejectA = reject
			end)

			local b = Promise.new(function(_, reject)
				rejectB = reject
			end)

			local combinedPromise = Promise.all({a, b})

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Started)

			rejectA("foo", "bar")

			expect(combinedPromise:getStatus()).to.equal(Promise.Status.Rejected)

			rejectB("baz", "qux")

			local resultLength, result = pack(combinedPromise:_unwrap())
			local success, first, second = unpack(result, 1, resultLength)

			expect(resultLength).to.equal(3)
			expect(success).to.equal(false)
			expect(first).to.equal("foo")
			expect(second).to.equal("bar")
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX8579B108CD5D4A60A5B2D56E6979788B">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Cryo</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[return {
	Dictionary = require(script.Dictionary),
	List = require(script.List),
	None = require(script.None),
}]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXE4A0F506F14943CFAD0B85F11F2D08D1">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">List</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Defines utilities for working with 'list-like' tables.
]]

return {
	getRange = require(script.getRange),
	find = require(script.find),
	filterMap = require(script.filterMap),
	filter = require(script.filter),
	foldLeft = require(script.foldLeft),
	foldRight = require(script.foldRight),
	join = require(script.join),
	removeIndex = require(script.removeIndex),
	removeRange = require(script.removeRange),
	removeValue = require(script.removeValue),
	map = require(script.map),
	reverse = require(script.reverse),
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXEB4B6328C083437F915E9AFE2EDCE963">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">reverse</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Returns a new list with the reversed order of the given list
]]

local function reverse(list)
	local new = {}
	local len = #list
	local top = len + 1

	for i = 1, len do
		new[i] = list[top - i]
	end

	return new
end

return reverse]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2A6A3ADDB7C64F8DB7682F805318CE67">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">foldLeft</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Performs a left-fold of the list with the given initial value and callback.
]]
local function foldLeft(list, initial, callback)
	local accum = initial

	for i = 1, #list do
		accum = callback(accum, list[i], i)
	end

	return accum
end

return foldLeft]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8BA92CB2E2C84136A9BB13EEE37CC7B9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">filter.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local filter = require(script.Parent.filter)

	it("should call the callback for each element", function()
		local a = {
			"foo1",
			"foo2",
			"foo3"
		}
		local copy = {}
		local function copyCallback(value, index)
			copy[index] = value
			return true
		end
		filter(a, copyCallback)

		for key, value in pairs(a) do
			expect(copy[key]).to.equal(value)
		end

		for key, value in pairs(copy) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should correctly use the filter callback", function()
		local a = {1, 2, 3, 4, 5}
		local function evenOnly(value)
			return value % 2 == 0
		end
		local b = filter(a, evenOnly)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(2)
		expect(b[2]).to.equal(4)
	end)

	it("should copy the list correctly", function()
		local a = {1, 2, 3}
		local function keepAll()
			return true
		end
		local b = filter(a, keepAll)

		expect(b).never.to.equal(a)

		for key, value in pairs(a) do
			expect(b[key]).to.equal(value)
		end

		for key, value in pairs(b) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should work with an empty table", function()
		local called = false
		local function callback()
			called = true
			return true
		end
		local a = filter({}, callback)

		expect(#a).to.equal(0)
		expect(called).to.equal(false)
	end)

	it("should remove all element from a list when callback return always false", function()
		local a = {6, 2, 8, 6, 7}
		local function removeAll()
			return false
		end
		local b = filter(a, removeAll)

		expect(#b).to.equal(0)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA9DB8EA8B5E74184929CC056A48895A6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	it("should load", function()
		require(script.Parent)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX971CE830186B44E4BB1A3A0E907E1F96">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">map.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local map = require(script.Parent.map)

	it("should return a new table", function()
		local a = {1, 2, 3}

		expect(map(a, function() end)).never.to.equal(a)
	end)

	it("should call the callback for each element", function()
		local a = {5, 6, 7}
		local copy = {}
		map(a, function(value, index)
			copy[index] = value
			return value
		end)

		for key, value in pairs(a) do
			expect(copy[key]).to.equal(value)
		end

		for key, value in pairs(copy) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should copy list", function()
		local a = {1, 2, 3}
		local b = map(a, function(value)
			return value
		end)

		for key, value in pairs(a) do
			expect(b[key]).to.equal(value)
		end

		for key, value in pairs(b) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should sets the new values to the result of the given callback", function()
		local a = {5, 6, 7}
		local b = map(a, function(value)
			return value * 2
		end)

		expect(#b).to.equal(#a)
		for i = 1, #a do
			expect(b[i]).to.equal(a[i] * 2)
		end
	end)

	it("should work with an empty list", function()
		local a = {}
		local b = map(a, function() end)

		expect(b).to.be.a("table")
		expect(b).never.to.equal(a)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX94FFF81385234B6893B185741BFF4803">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">reverse.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local reverse = require(script.Parent.reverse)

	it("should return a new table", function()
		local a = {1, 2, 3}

		expect(reverse(a)).never.to.equal(a)
	end)

	it("should not mutate the given table", function()
		local a = {1, 2, 3}
		reverse(a)

		expect(#a).to.equal(3)
		expect(a[1]).to.equal(1)
		expect(a[2]).to.equal(2)
		expect(a[3]).to.equal(3)
	end)

	it("should contain the same elements", function()
		local a = {
			"Foo",
			"Bar"
		}
		local aSet = {
			Foo = true,
			Bar = true
		}
		local b = reverse(a)

		expect(#b).to.equal(2)
		for _, value in ipairs(b) do
			expect(aSet[value]).to.equal(true)
		end
	end)

	it("should reverse the list", function()
		local a = {1, 2, 3, 4}
		local b = reverse(a)

		expect(b[1]).to.equal(4)
		expect(b[2]).to.equal(3)
		expect(b[3]).to.equal(2)
		expect(b[4]).to.equal(1)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA6B2BA148CF246219D743D12EBC37FA8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeIndex</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Remove the element at the given index.
]]
local function removeIndex(list, index)
	local new = {}
	local removed = 0

	for i = 1, #list do
		if i == index then
			removed = 1
		else
			new[i - removed] = list[i]
		end
	end

	return new
end

return removeIndex]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX91A6C47BAEDC4DCF836F511571FF7750">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">filterMap</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Create a copy of a list doing a combination filter and map.

	If callback returns nil for any item, it is considered filtered from the
	list. Any other value is considered the result of the 'map' operation.
]]
local function filterMap(list, callback)
	local new = {}
	local index = 1

	for i = 1, #list do
		local result = callback(list[i], i)

		if result ~= nil then
			new[index] = result
			index = index + 1
		end
	end

	return new
end

return filterMap]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX50B762BA26634CCFAADF1662A6A0D546">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">find</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Returns the index of the given value or nil if not found.
]]

local function find(list, value)
	for i = 1, #list do
		if list[i] == value then
			return i
		end
	end
	return nil
end

return find]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0C4DA1469E6A4260BA2E52E98DA66CAE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">foldRight</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Performs a right-fold of the list with the given initial value and callback.
]]
local function foldRight(list, initial, callback)
	local accum = initial

	for i = #list, 1, -1 do
		accum = callback(accum, list[i], i)
	end

	return accum
end

return foldRight]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD7E10770C9154743B328A5A297CFE284">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">join</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local None = require(script.Parent.Parent.None)

--[[
	Joins any number of lists together into a new list
]]
local function join(...)
	local new = {}

	for listKey = 1, select("#", ...) do
		local list = select(listKey, ...)
		local len = #new

		for itemKey = 1, #list do
			if list[itemKey] == None then
				len = len - 1
			else
				new[len + itemKey] = list[itemKey]
			end
		end
	end

	return new
end

return join]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA6DAE67D55B44156A716FA7188FBCCA7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getRange.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local getRange = require(script.Parent.getRange)

	it("should return the correct range", function()
		local a = {1, 2, 3, 4}
		local b = getRange(a, 2, 3)

		expect(b[1]).to.equal(2)
		expect(b[2]).to.equal(3)
		expect(#b).to.equal(2)

		local c = getRange(a, 4, 4)
		expect(#c).to.equal(1)
		expect(c[1]).to.equal(4)
	end)

	it("should throw when the start index is higher than the end index", function()
		local a = {5, 8, 7, 2, 3, 7}

		expect(function()
			getRange(a, 4, 1)
		end).to.throw()
	end)

	it("should copy the table", function()
		local a = {6, 8, 1, 3, 7, 2}
		local b = getRange(a, 1, #a)

		for key, value in pairs(a) do
			expect(b[key]).to.equal(value)
		end

		for key, value in pairs(b) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should work with an empty table", function()
		local a = getRange({}, 1, 5)

		expect(a).to.be.a("table")
		expect(#a).to.equal(0)
	end)

	it("should work when the start index is smaller that 1", function()
		local a = {1, 2, 3, 4}
		local b = getRange(a, -2, 2)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(2)
	end)

	it("should work when the end index is larger that the list length", function()
		local a = {1, 2, 3, 4}
		local b = getRange(a, 3, 18)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(3)
		expect(b[2]).to.equal(4)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6E27F31E972C43C6B13035412129265E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">join.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local join = require(script.Parent.join)
	local None = require(script.Parent.Parent.None)

	it("should return a new table", function()
		local a = {}

		expect(join(a)).never.to.equal(a)
	end)

	it("should remove elements equal to None", function()
		local a = {
			"foo-a"
		}

		local b = {
			None,
			"foo-b"
		}

		local c = join(a, b)

		expect(c[1]).to.equal("foo-a")
		expect(c[2]).to.equal("foo-b")
		expect(c[3]).to.equal(nil)
	end)

	it("should accept arbitrary numbers of tables", function()
		local a = {1}
		local b = {2}
		local c = {3}

		local d = join(a, b, c)

		expect(#d).to.equal(3)
		expect(d[1]).to.equal(1)
		expect(d[2]).to.equal(2)
		expect(d[3]).to.equal(3)
	end)

	it("should accept zero tables", function()
		expect(join()).to.be.a("table")
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDEBFE194BBAA45598F69A4091EB183D4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeValue.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local removeValue = require(script.Parent.removeValue)
	local None = require(script.Parent.Parent.None)

	it("should remove the given value", function()
		local a = {1, 4, 3}
		local b = removeValue(a, 4)

		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(3)
	end)

	it("should remove all occurences of the same given value", function()
		local a = {1, 2, 2, 3}
		local b = removeValue(a, 2)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(3)
	end)

	it("should work with an empty list", function()
		local a = removeValue({}, 1)

		expect(a).to.be.a("table")
		expect(#a).to.equal(0)
	end)

	it("should work with a None element", function()
		local a = {1, 2, None, 3}
		local b = removeValue(a, 2)

		expect(#b).to.equal(3)
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(None)
		expect(b[3]).to.equal(3)

		local c = removeValue(a, None)

		expect(c[3]).to.equal(3)
		expect(#c).to.equal(3)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA7C3030108B34365ADA580B148B76600">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">foldLeft.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local foldLeft = require(script.Parent.foldLeft)

	it("should call the callback", function()
		local a = {1, 2, 3}
		local called = 0

		foldLeft(a, 0, function()
			called = called + 1
		end)

		expect(called).to.equal(3)
	end)

	it("should not call the callback when the list is empty", function()
		local called = false

		foldLeft({}, 0, function()
			called = true
		end)

		expect(called).to.equal(false)
	end)

	it("should call the callback for each element", function()
		local a = {4, 5, 6}
		local copy = {}

		foldLeft(a, 0, function(accum, value, index)
			copy[index] = value
			return accum
		end)

		expect(#copy).to.equal(#a)

		for key, value in pairs(a) do
			expect(value).to.equal(copy[key])
		end
	end)

	it("should pass the same modified initial value to the callback", function()
		local a = {5, 4, 3}
		local initialValue = {}

		foldLeft(a, initialValue, function(accum)
			expect(accum).to.equal(initialValue)
			return accum
		end)
	end)

	it("should call the callback in the correct order", function()
		local a = {5, 4, 3}
		local index = 1

		foldLeft(a, 0, function(accum, value)
			expect(value).to.equal(a[index])
			index = index + 1
			return accum
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX784CDD87D9484E008C85F0D5F64EFC36">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">foldRight.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local foldRight = require(script.Parent.foldRight)

	it("should call the callback", function()
		local a = {1, 2, 3}
		local called = 0

		foldRight(a, 0, function()
			called = called + 1
		end)

		expect(called).to.equal(3)
	end)

	it("should not call the callback when the list is empty", function()
		local called = false

		foldRight({}, 0, function()
			called = true
		end)

		expect(called).to.equal(false)
	end)

	it("should call the callback for each element", function()
		local a = {4, 5, 6}
		local copy = {}

		foldRight(a, 0, function(accum, value, index)
			copy[index] = value
			return accum
		end)

		expect(#copy).to.equal(#a)

		for key, value in pairs(a) do
			expect(value).to.equal(copy[key])
		end
	end)

	it("should pass the same modified initial value to the callback", function()
		local a = {5, 4, 3}
		local initialValue = {}

		foldRight(a, initialValue, function(accum)
			expect(accum).to.equal(initialValue)
			return accum
		end)
	end)

	it("should call the callback in the correct order", function()
		local a = {5, 4, 3}
		local index = 3

		foldRight(a, 0, function(accum, value)
			expect(value).to.equal(a[index])
			index = index - 1
			return accum
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6A2DAFABD9B14070AFECA7A55163910C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeValue</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Creates a new list that has no occurrences of the given value.
]]
local function removeValue(list, value)
	local new = {}
	local index = 1

	for i = 1, #list do
		if list[i] ~= value then
			new[index] = list[i]
			index = index + 1
		end
	end

	return new
end

return removeValue]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA565EC696F89423CA307CE32F44D56D7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeRange.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local removeRange = require(script.Parent.removeRange)
	local None = require(script.Parent.Parent.None)

	it("should remove elements properly", function()
		local a = {1, 2, 3}
		local b = removeRange(a, 2, 2)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(3)

		local c = {1, 2, 3, 4, 5, 6}
		local d = removeRange(c, 1, 4)

		expect(#d).to.equal(2)
		expect(d[1]).to.equal(5)
		expect(d[2]).to.equal(6)

		local e = removeRange(c, 2, 5)

		expect(#e).to.equal(2)
		expect(e[1]).to.equal(1)
		expect(e[2]).to.equal(6)
	end)

	it("should throw when the start index is higher than the end index", function()
		local a = {1, 2, 3}

		expect(function()
			removeRange(a, 2, 0)
		end).to.throw()

		expect(function()
			removeRange(a, 1, -1)
		end).to.throw()
	end)

	it("should copy the table when then indexes are higher than the list length", function()
		local a = {1, 2, 3}
		local b = removeRange(a, 4, 7)

		expect(#b).to.equal(3)
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(2)
		expect(b[3]).to.equal(3)
	end)

	it("should work when the start index is smaller than 1", function()
		local a = {1, 2, 3, 4}
		local b = removeRange(a, -5, 2)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(3)
		expect(b[2]).to.equal(4)
	end)

	it("should work when the end index is greater than the list length", function()
		local a = {1, 2, 3, 4}
		local b = removeRange(a, 3, 8)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(2)
	end)

	it("should work with a None element", function()
		local a = {1, None, 3}
		local b = removeRange(a, 1, 1)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(None)
		expect(b[2]).to.equal(3)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF39171F375DA4239847721136EB9240C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">filterMap.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local filterMap = require(script.Parent.filterMap)

	it("should return a new table", function()
		local a = {1, 2, 3}
		local function callback()
			return 1
		end
		local b = filterMap(a, callback)

		expect(b).never.to.equal(a)
	end)

	it("should call the callback for each element", function()
		local a = {
			"foo1",
			"foo2",
			"foo3"
		}
		local copy = {}
		local function callback(value, index)
			copy[index] = value
			return value
		end
		filterMap(a, callback)

		for key, value in pairs(a) do
			expect(copy[key]).to.equal(value)
		end

		for key, value in pairs(copy) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should correctly use the filter callback", function()
		local a = {1, 2, 3, 4, 5}
		local function doubleOddOnly(value)
			if value % 2 == 0 then
				return nil
			else
				return value * 2
			end
		end
		local b = filterMap(a, doubleOddOnly)

		expect(#b).to.equal(3)
		expect(b[1]).to.equal(2)
		expect(b[2]).to.equal(6)
		expect(b[3]).to.equal(10)
	end)

	it("should copy the list correctly", function()
		local a = {1, 2, 3}
		local function copyCallback(value)
			return value
		end
		local b = filterMap(a, copyCallback)

		expect(b).never.to.equal(a)

		for key, value in pairs(a) do
			expect(b[key]).to.equal(value)
		end

		for key, value in pairs(b) do
			expect(value).to.equal(a[key])
		end
	end)

	it("should work with an empty table", function()
		local called = false
		local function callback()
			called = true
			return true
		end
		local a = filterMap({}, callback)

		expect(#a).to.equal(0)
		expect(called).to.equal(false)
	end)

	it("should remove all elements from a list when callback return always nil", function()
		local a = {6, 2, 8, 6, 7}
		local function removeAll()
			return nil
		end
		local b = filterMap(a, removeAll)

		expect(#b).to.equal(0)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC99417AFA1584F0CA2FC2B161847CF0A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeIndex.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local removeIndex = require(script.Parent.removeIndex)
	local None = require(script.Parent.Parent.None)

	it("should remove the element at the given index", function()
		local a = {
			"first",
			"second",
			"third"
		}

		local b = removeIndex(a, 2)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal("first")
		expect(b[2]).to.equal("third")
	end)

	it("should not remove any element if index is out of bound", function()
		local a = {
			"first",
			"second",
			"third"
		}
		local b = removeIndex(a, 4)

		expect(#b).to.equal(#a)
		for i = 1, #a do
			expect(b[i]).to.equal(a[i])
		end

		local c = removeIndex(a, -2)

		expect(#c).to.equal(#a)
		for i = 1, #a do
			expect(c[i]).to.equal(a[i])
		end
	end)

	it("should work with a None element", function()
		local a = {
			"first",
			None,
			"third"
		}

		local b = removeIndex(a, 1)

		expect(#b).to.equal(2)
		expect(b[1]).to.equal(None)
		expect(b[2]).to.equal("third")
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE2EAEA0E5E0043C18932055721E98647">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">map</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Create a copy of a list where each value is transformed by `callback`
]]
local function map(list, callback)
	local new = {}

	for i = 1, #list do
		new[i] = callback(list[i], i)
	end

	return new
end

return map]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX64F6A46E5B574871AF525EA8B78B62E7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">filter</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Create a copy of a list with only values for which `callback` returns true.
	Calls the callback with (value, index).
]]
local function filter(list, callback)
	local new = {}
	local index = 1

	for i = 1, #list do
		local value = list[i]
		if callback(value, i) then
			new[index] = value
			index = index + 1
		end
	end

	return new
end

return filter]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD18A11CA72CB451A92C65F2E2FE67BD1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">find.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local find = require(script.Parent.find)

	it("should return the correct index", function()
		local a = {5, 4, 3, 2, 1}

		expect(find(a, 1)).to.equal(5)
		expect(find(a, 2)).to.equal(4)
		expect(find(a, 3)).to.equal(3)
		expect(find(a, 4)).to.equal(2)
		expect(find(a, 5)).to.equal(1)
	end)

	it("should work with an empty table", function()
		expect(find({}, 1)).to.equal(nil)
	end)

	it("should return nil when the given value is not found", function()
		local a = {1, 2, 3}

		expect(find(a, 4)).to.equal(nil)
		expect(type(find(a, 4))).to.equal("nil")
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX098C07CBA17B41C0B5222EA92C054D6C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeRange</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Remove the range from the list starting from the index.
]]
local function removeRange(list, startIndex, endIndex)
	assert(startIndex <= endIndex, "startIndex must be less than or equal to endIndex")

	local new = {}
	local index = 1

	for i = 1, math.min(#list, startIndex - 1) do
		new[index] = list[i]
		index = index + 1
	end

	for i = endIndex + 1, #list do
		new[index] = list[i]
		index = index + 1
	end

	return new
end

return removeRange]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5001B2945FCD47F289C23B8666B4B515">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getRange</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Returns a new list containing only the elements within the given range.
]]

local function getRange(list, startIndex, endIndex)
	assert(startIndex <= endIndex, "startIndex must be less than or equal to endIndex")

	local new = {}
	local index = 1

	for i = math.max(1, startIndex), math.min(#list, endIndex) do
		new[index] = list[i]
		index = index + 1
	end

	return new
end

return getRange]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX239F7C564C1A4371902A5CABA75E255E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">None</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Represents a value that is intentionally present, but should be interpreted
	as `nil`.

	Cryo.None is used by included utilities to make removing values more
	ergonomic.
]]

local None = newproxy(true)

getmetatable(None).__tostring = function()
	return "Cryo.None"
end

return None]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX33D86180C43848FFB096E22ED7D65C73">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">None.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local None = require(script.Parent.None)

	it("should be a userdata", function()
		expect(None).to.be.a("userdata")
	end)

	it("should have a nice string name", function()
		local coerced = tostring(None)

		expect(coerced:find("^userdata: ")).never.to.be.ok()
		expect(coerced:find("None")).to.be.ok()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX60311C505B2245E9AEA694508F577EF1">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	it("should load", function()
		require(script.Parent)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX82AC226809714346B49967C141E0CC2D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Dictionary</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Defines utilities for working with 'dictionary-like' tables.

	Dictionaries can be indexed by any value, but don't have the ordering
	expectations that lists have.
]]

return {
	join = require(script.join),
	fold = require(script.fold),
	values = require(script.values),
	keys = require(script.keys),
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX40D3198D3E8C49DA8C436B9495089AB4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">keys</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Returns a list of the keys from the given dictionary.
]]
local function keys(dictionary)
	local new = {}
	local index = 1

	for key in pairs(dictionary) do
		new[index] = key
		index = index + 1
	end

	return new
end

return keys]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD239351220154F2E8271548EEE8C578E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">values</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Returns a list of the values of the given dictionary.
]]

local function values(dictionary)
	local new = {}
	local index = 1

	for _, value in pairs(dictionary) do
		new[index] = value
		index = index + 1
	end

	return new
end

return values]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF8607C410A974CE3BFD33B9D9EDBA204">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">values.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local values = require(script.Parent.values)
	local None = require(script.Parent.Parent.None)

	it("should not mutate the given table", function()
		local a = {
			Foo = "FooValue",
			Bar = "BarValue"
		}
		local aCopy = {
			Foo = "FooValue",
			Bar = "BarValue"
		}

		values(a)

		for key, value in pairs(a) do
			expect(aCopy[key]).to.equal(value)
		end
		for key, value in pairs(aCopy) do
			expect(a[key]).to.equal(value)
		end
	end)

	it("should return the correct values", function()
		local a = {
			Foo = "FooValue",
			Bar = "BarValue",
			Test = "TestValue"
		}
		local valueCount = {
			FooValue = 1,
			BarValue = 1,
			TestValue = 1
		}
		local b = values(a)

		expect(#b).to.equal(3)
		for _, value in ipairs(b) do
			expect(valueCount[value]).never.to.equal(nil)
			valueCount[value] = valueCount[value] - 1
		end
		for _, count in pairs(valueCount) do
			expect(count).to.equal(0)
		end
	end)

	it("should return duplicates if two values are the same", function()
		local a = {
			Foo = "FooValue",
			Bar = "BarValue",
			Test = "FooValue"
		}
		local valueCount = {
			FooValue = 2,
			BarValue = 1,
		}
		local b = values(a)

		expect(#b).to.equal(3)
		for _, value in ipairs(b) do
			expect(valueCount[value]).never.to.equal(nil)
			valueCount[value] = valueCount[value] - 1
		end
		for _, count in pairs(valueCount) do
			expect(count).to.equal(0)
		end
	end)

	it("should work with an empty table", function()
		local a = values({})

		expect(next(a)).to.equal(nil)
	end)

	it("should contain a None element if there is a None value in the dictionary", function()
		local a = {
			Foo = None,
			Bar = "BarValue"
		}
		local valueCount = {
			[None] = 1,
			BarValue = 1
		}
		local b = values(a)

		expect(#b).to.equal(2)
		for _, value in ipairs(b) do
			expect(valueCount[value]).never.to.equal(nil)
			valueCount[value] = valueCount[value] - 1
		end
		for _, count in pairs(valueCount) do
			expect(count).to.equal(0)
		end
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3E3531F7A6E8474A9B517D5A163D2BDA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	it("should load", function()
		require(script.Parent)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1BC7B16E1E6A480F81765EB0D8FA6AB6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">keys.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local keys = require(script.Parent.keys)
	local None = require(script.Parent.Parent.None)

	it("should not mutate the given table", function()
		local a = {
			Foo = "FooValue",
			Bar = "BarValue"
		}
		local aCopy = {
			Foo = "FooValue",
			Bar = "BarValue"
		}

		keys(a)

		for key, value in pairs(a) do
			expect(aCopy[key]).to.equal(value)
		end
		for key, value in pairs(aCopy) do
			expect(a[key]).to.equal(value)
		end
	end)

	it("should return the correct keys", function()
		local a = {
			Foo = "FooValue",
			Bar = "BarValue",
			Test = "TestValue"
		}
		local keyCount = {
			Foo = 1,
			Bar = 1,
			Test = 1
		}
		local b = keys(a)

		expect(#b).to.equal(3)
		for _, key in ipairs(b) do
			expect(keyCount[key]).never.to.equal(nil)
			keyCount[key] = keyCount[key] - 1
		end
		for _, count in pairs(keyCount) do
			expect(count).to.equal(0)
		end
	end)

	it("should work with an empty table", function()
		local a = keys({})

		expect(next(a)).to.equal(nil)
	end)

	it("should contain a None element if there is a None key in the dictionary", function()
		local a = {
			[None] = "Foo",
			Bar = "BarValue"
		}
		local keyCount = {
			[None] = 1,
			Bar = 1
		}
		local b = keys(a)

		expect(#b).to.equal(2)
		for _, key in ipairs(b) do
			expect(keyCount[key]).never.to.equal(nil)
			keyCount[key] = keyCount[key] - 1
		end
		for _, count in pairs(keyCount) do
			expect(count).to.equal(0)
		end
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD72D02D798994CB288542A1E0A7983D1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">join</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local None = require(script.Parent.Parent.None)

--[[
	Combine a number of dictionary-like tables into a new table.

	Keys specified in later tables will overwrite keys in previous tables.

	Use `Cryo.None` as a value to remove a key. This is necessary because
	Lua does not distinguish between a value not being present in a table and a
	value being `nil`.
]]
local function join(...)
	local new = {}

	for i = 1, select("#", ...) do
		local source = select(i, ...)

		for key, value in pairs(source) do
			if value == None then
				new[key] = nil
			else
				new[key] = value
			end
		end
	end

	return new
end

return join]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1D9EED4132904CAA8AC69DED1DCF321A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">fold</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Performs a fold over the entries in the given dictionary.
]]
local function fold(dictionary, initialValue, callback)
	local accum = initialValue

	for key, value in pairs(dictionary) do
		accum = callback(accum, key, value)
	end

	return accum
end

return fold]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCE594F273CCE4FFE81D8726086C435EF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">join.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local join = require(script.Parent.join)
	local None = require(script.Parent.Parent.None)

	it("should return a new table", function()
		local a = {}

		expect(join(a)).never.to.equal(a)
	end)

	it("should merge tables, overwriting previous values", function()
		local a = {
			foo = "foo-a",
			bar = "bar-a",
		}

		local b = {
			foo = "foo-b",
			baz = "baz-b",
		}

		local c = join(a, b)

		expect(c.foo).to.equal(b.foo)
		expect(c.bar).to.equal(a.bar)
		expect(c.baz).to.equal(b.baz)
	end)

	it("should remove values set to None", function()
		local a = {
			foo = "foo-a",
		}

		local b = {
			foo = None,
		}

		local c = join(a, b)

		expect(c.foo).to.equal(nil)
	end)

	it("should not mutate passed in tables", function()
		local mutationsA = 0
		local mutationsB = 0

		local a = {}
		local b = {
			foo = "foo-b",
		}

		setmetatable(a, {
			__newindex = function()
				mutationsA = mutationsA + 1
			end,
		})

		setmetatable(b, {
			__newindex = function()
				mutationsB = mutationsB + 1
			end,
		})

		join(a, b)

		expect(mutationsA).to.equal(0)
		expect(mutationsB).to.equal(0)
		expect(b.foo).to.equal("foo-b")
	end)

	it("should accept arbitrary numbers of tables", function()
		local a = {
			foo = "foo-a",
		}

		local b = {
			bar = "bar-b",
		}

		local c = {
			baz = "baz-c",
		}

		local d = join(a, b, c)

		expect(d.foo).to.equal(a.foo)
		expect(d.bar).to.equal(b.bar)
		expect(d.baz).to.equal(c.baz)
	end)

	it("should accept zero tables", function()
		expect(join()).to.be.a("table")
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC633EBEBD6BF457EBD769DE18B04A7B1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">fold.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local fold = require(script.Parent.fold)

	it("should call the callback", function()
		local a = {
			Test = true
		}
		local called = false

		fold(a, 0, function()
			called = true
		end)

		expect(called).to.equal(true)
	end)

	it("should not call the callback when dictionary is empty", function()
		local a = {}
		local called = false

		fold(a, 0, function()
			called = true
		end)

		expect(called).to.equal(false)
	end)

	it("should call the callback for each pairs in the dictionary", function()
		local a = {
			First = 1,
			Second = 2,
			Third = 3
		}
		local totalPairs = 3
		local count = 0
		local copy = {}

		fold(a, 0, function(accum, key, value)
			copy[key] = value
			count = count + 1
			return accum
		end)

		expect(count).to.equal(totalPairs)

		for key, value in pairs(a) do
			expect(value).to.equal(copy[key])
		end
	end)

	it("should pass the same modified initial value to the callback", function()
		local a = {
			Test = true,
			SecondTest = true
		}
		local initialValue = {}

		fold(a, initialValue, function(accum)
			expect(accum).to.equal(initialValue)
			return accum
		end)
	end)

	it("should update the value as it calls the callback", function()
		local a = {
			Test = true,
			SecondTest = true
		}
		local counter = 0

		fold(a, counter, function(accum)
			expect(accum).to.equal(counter)
			counter = counter + 1
			return counter
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX1A8054158DDF4A2C8CDA4E706022C523">
			<Properties>
				<string name="Name">Src</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX735FD94FFEA4406DBD63D1874A61C1E7">
				<Properties>
					<string name="Name">Util</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX1D225617393D4AE393724B4D3536F4EA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Theme</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local createSignal = require(Plugin.Src.Util.createSignal)
local Constants = require(Plugin.Src.Util.Constants)
local Cryo = require(Plugin.Cryo)

local Theme = {}

function Theme.new(override)
	local self = {
		overrideTheme = override or nil,
		signal = createSignal(),
		externalThemeChangedConnection = nil,

		values = {},
	}

	setmetatable(self, {
		__index = Theme
	})

	if override == nil then
		self.externalThemeChangedConnection = settings().Studio.ThemeChanged:Connect(function()
			self:recalculateTheme()
		end)
	end

	self:recalculateTheme()

	return self
end

function Theme:subscribe(...)
	return self.signal:subscribe(...)
end

function Theme:destroy()
	if self.externalThemeChangedConnection then
		self.externalThemeChangedConnection:Disconnect()
	end
end

function Theme:update(changedValues)
	self.values = Cryo.Dictionary.join(self.values, changedValues)
	self.signal:fire(self.values)
end

function Theme:getExternalTheme()
	local overrideTheme = self.overrideTheme
	if overrideTheme then
		return overrideTheme
	end

	return settings().Studio.Theme
end

function Theme:isDarkerTheme()
	-- Assume "darker" theme if the average main background colour is darker
	local mainColour = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground)
	return (mainColour.r + mainColour.g + mainColour.b) / 3 < 0.5
end

function Theme:recalculateTheme()
	local externalTheme = self:getExternalTheme()
	local isDark = self:isDarkerTheme()

	-- Shorthands for getting a color
	local c = Enum.StudioStyleGuideColor
	local m = Enum.StudioStyleGuideModifier

	local function color(...)
		return externalTheme:GetColor(...)
	end

	self:update({
		isDarkerTheme = isDark,

		backgroundColor = color(c.MainBackground),

		separator = isDark and color(c.Border) or color(c.Titlebar),

		scrollBar = color(c.ScrollBar),

		menuBar = {
			backgroundColor = isDark and color(c.ScrollBarBackground) or color(c.MainBackground),
		},

		menuEntry = {
			hover = color(c.RibbonTab),
			highlight = isDark and color(c.TableItem, m.Selected) or color(c.CurrentMarker),
			text = color(c.BrightText),
		},

		header = {
			text = color(c.BrightText),
		},

		footer = {
			gradient = color(c.MainText),
		},

		titledFrame = {
			text = color(c.SubText),
		},

		textBox = {
			background = color(c.InputFieldBackground),
			disabled = color(c.Tab),
			borderDefault = color(c.Border),
			borderHover = isDark and color(c.MainButton) or color(c.CurrentMarker),
			tooltip = color(c.DimmedText),
			text = color(c.MainText),
		},

		radioButton = {
			background = color(c.InputFieldBackground),
			title = color(c.BrightText),
			description = color(c.DimmedText),
		},

		checkBox = {
			background = color(c.InputFieldBackground),
			title = color(c.BrightText),
		},

		dialog = {
			background = color(c.MainBackground),
			text = color(c.MainText),
		},

		cancelButton = {
			ButtonColor = color(c.Button),
			ButtonColor_Hover = color(c.Button, m.Hover),
			ButtonColor_Disabled = color(c.Button, m.Disabled),
			TextColor = color(c.MainText),
			TextColor_Disabled = color(c.DimmedText),
			BorderColor = color(c.Border),
		},

		defaultButton = {
			ButtonColor = isDark and color(c.MainButton) or color(c.CurrentMarker),
			ButtonColor_Hover = color(c.LinkText),
			ButtonColor_Disabled = isDark and color(c.Button, m.Disabled) or Constants.BLUE_DISABLED,
			TextColor = Color3.new(1, 1, 1),
			TextColor_Disabled = isDark and color(c.DimmedText) or Color3.new(1, 1, 1),
			BorderColor = color(c.Light),
		},
	})
end

function Theme.newDummyTheme()
	return Theme.new({
		GetColor = function()
			return Color3.fromRGB(0, 0, 0)
		end,
	})
end

-- Remove with FFlagStudioLuaGameSettingsDialog2
function Theme.DEPRECATED_constantColors()
	local theme = Theme.newDummyTheme()

	theme:update({
		isDarkerTheme = false,

		backgroundColor = Color3.fromRGB(255, 255, 255),

		separator = Color3.fromRGB(245, 245, 245),

		scrollBar = Color3.fromRGB(255, 255, 255),

		menuBar = {
			backgroundColor = Color3.fromRGB(255, 255, 255),
		},

		menuEntry = {
			hover = Color3.fromRGB(242, 242, 242),
			highlight = Color3.fromRGB(61, 180, 255),
			text = Color3.fromRGB(0, 0, 0),
		},

		header = {
			text = Color3.fromRGB(0, 0, 0),
		},

		footer = {
			gradient = Color3.fromRGB(0, 0, 0),
		},

		titledFrame = {
			text = Color3.fromRGB(184, 184, 184),
		},

		radioButton = {
			background = Color3.fromRGB(255, 255, 255),
			title = Color3.fromRGB(0, 0, 0),
			description = Color3.fromRGB(184, 184, 184),
		},

		dialog = {
			background = Color3.fromRGB(255, 255, 255),
			text = Color3.fromRGB(0, 0, 0),
		},

		cancelButton = {
			ButtonColor = Color3.fromRGB(255, 255, 255),
			ButtonColor_Hover = Color3.fromRGB(242, 242, 242),
			ButtonColor_Disabled = Color3.fromRGB(255, 255, 255),
			TextColor = Color3.fromRGB(0, 0, 0),
			TextColor_Disabled = Color3.fromRGB(117, 117, 117),
			BorderColor = Color3.fromRGB(184, 184, 184),
		},

		defaultButton = {
			ButtonColor = Color3.fromRGB(0, 162, 255),
			ButtonColor_Hover = Color3.fromRGB(61, 180, 255),
			ButtonColor_Disabled = Color3.fromRGB(153, 218, 255),
			TextColor = Color3.fromRGB(255, 255, 255),
			TextColor_Disabled = Color3.fromRGB(255, 255, 255),
			BorderColor = Color3.fromRGB(242, 242, 242),
		},
	})

	return theme
end

return Theme]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFA45F0772B1C4840AC7B6116D445699D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createSignal</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.
		local signal = createSignal()
		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)
		signal:fire("something")
		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFC1B563FF89A43A6ADF8AB274E504E1B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">isEmpty</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Determines if a dictionary is empty.

return function(dictionary)
	return next(dictionary) == nil
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7991235357364E09A97D727F12949951">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Constants</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Constant values that are used across multiple files within this project.
]]

local Constants = {

MENU_BAR_WIDTH = 192,
MENU_ENTRY_HEIGHT = 42,

CENTER_GUTTER = 180,
ELEMENT_PADDING = 32,

RADIO_BUTTON_SIZE = 20,
RADIO_BUTTON_PADDING = 10,

CHECKBOX_SIZE = 20,
CHECKBOX_PADDING = 12,

BUTTON_WIDTH = 125,
BUTTON_HEIGHT = 35,

HEADER_HEIGHT = 45,
FOOTER_HEIGHT = 65,

BLUE_DISABLED = Color3.fromRGB(153, 218, 255),

ROUNDED_BACKGROUND_IMAGE = "rbxasset://textures/StudioToolbox/RoundedBackground.png",
ROUNDED_BORDER_IMAGE = "rbxasset://textures/StudioToolbox/RoundedBorder.png",
ROUNDED_FRAME_SLICE = Rect.new(3, 3, 13, 13),

ERROR_IMAGE = "rbxasset://textures/GameSettings/ErrorIcon.png",
ERROR_COLOR = Color3.new(1, 0.266, 0.266),

WARNING_IMAGE = "rbxasset://textures/GameSettings/Warning.png",
WARNING_COLOR = Color3.fromRGB(246, 136, 2),

}

return Constants]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2471C4E0ABDB467F874DCE755F527D48">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CurrentStatus</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Enum for the current state of the dialog.

return {
	Closed = "Closed",
	Open = "Open",
	Working = "Working",
	Error = "Error",
}]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXD06E9BC869AB4E0DA0CC2D4628963778">
				<Properties>
					<string name="Name">Thunks</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF0ECCCF86E5F45B5B7FFD9CDD092756F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SaveChanges</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Saves all user changed settings to actual setting values.
	Returns a Promise that will resolve when saving is complete.
]]

local Plugin = script.Parent.Parent.Parent

local SetCurrentStatus = require(Plugin.Src.Actions.SetCurrentStatus)
local AddErrors = require(Plugin.Src.Actions.AddErrors)

local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

return function(settingsImpl)
	return function(store)
		store:dispatch(SetCurrentStatus(CurrentStatus.Working))
		local state = store:getState().Settings
		return settingsImpl:SaveAll(state):andThen(function()
			store:dispatch(SetCurrentStatus(CurrentStatus.Closed))
		end)
		:catch(function(errors)
			if errors then
				store:dispatch(SetCurrentStatus(CurrentStatus.Error))
				store:dispatch(AddErrors(errors))
			end
		end)
	end
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD1E03702AFD644A183F08EA8355466AF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LoadAllSettings</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Loads all actual settings values from web endpoints and properties.
	Once complete, saves these loaded values into the main store.
	Returns a Promise that will resolve when loading is complete.
]]

local Plugin = script.Parent.Parent.Parent
local SetCurrentSettings = require(Plugin.Src.Actions.SetCurrentSettings)
local SetCurrentStatus = require(Plugin.Src.Actions.SetCurrentStatus)

local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

return function(settingsImpl)
	return function(store)
		store:dispatch(SetCurrentStatus(CurrentStatus.Working))
		return settingsImpl:GetSettings():andThen(function(settings)
			store:dispatch(SetCurrentSettings(settings))
			store:dispatch(SetCurrentStatus(CurrentStatus.Open))
		end)
	end
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX9B0C094B20DA41F88433E58219D46F32">
				<Properties>
					<string name="Name">Components</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0FD26D650C0D43D99BF3C27FF6600776">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MenuEntry</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Hoverable and clickable menu entry in the left-side menu.

	Props:
		int Index = The index of this menu entry as it appears in the menu, top to bottom
		bool Selected = Whether this entry is the currently opened page
		bool Error = Whether to display an error icon in this MenuEntry tab
		string Title = The text to display on this menu entry
		function OnClicked = Callback invoked when this MenuEntry is clicked
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)
local Constants = require(Plugin.Src.Util.Constants)

local MenuEntry = Roact.PureComponent:extend("MenuEntry")

function MenuEntry:mouseHoverChanged(hovering)
	self:setState({
		Hovering = hovering,
	})
end

function MenuEntry:render()
	return withTheme(function(theme)
		local hovering = self.state.Hovering
		local selected = self.props.Selected
		local highlight = hovering or selected

		return Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 0, Constants.MENU_ENTRY_HEIGHT),
			BackgroundColor3 = highlight and theme.menuEntry.hover or theme.menuBar.backgroundColor,
			BorderSizePixel = 0,

			--Highlight this selection when the mouse hovers over it
			[Roact.Event.MouseEnter] = function()
				self:mouseHoverChanged(true)
			end,

			[Roact.Event.MouseLeave] = function()
				self:mouseHoverChanged(false)
			end,
		}, {
			Highlight = Roact.createElement("Frame", {
				ZIndex = 1,
				Size = theme.isDarkerTheme and UDim2.new(1, 0, 1, 0) or UDim2.new(0, 4, 1, 0),
				BorderSizePixel = 0,
				BackgroundColor3 = theme.menuEntry.highlight,

				BackgroundTransparency = selected and 0 or 1,
			}),

			Title = Roact.createElement("TextButton", {
				ZIndex = 2,
				Size = UDim2.new(1, -15, 1, 0),
				Position = UDim2.new(0, 15, 0, 0),

				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Center,

				Text = self.props.Title,
				Font = selected and Enum.Font.SourceSansSemibold or Enum.Font.SourceSans,
				TextSize = 24,
				TextColor3 = theme.menuEntry.text,

				[Roact.Event.Activated] = function()
					self.props.OnClicked(self.props.Index)
				end,
			}),

			Error = Roact.createElement("ImageLabel", {
				ZIndex = 3,
				Visible = self.props.Error or false,
				Size = UDim2.new(0, 18, 0, 18),
				Position = UDim2.new(1, -12, 0.5, 0),
				AnchorPoint = Vector2.new(1, 0.5),
				BackgroundTransparency = 1,
				Image = Constants.ERROR_IMAGE,
			}),
		})
	end)
end

return MenuEntry]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5B30728A838F4DC8B29BFEE45E8BC44F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TitledFrame</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A frame with a title offset to the left side.
	Used as a distinct vertical entry on a SettingsPage.

	Props:
		string Title = The text to display in this TitledFrame's left-hand title.
		int MaxHeight = The maximum height of this TitledFrame in pixels. Defaults to 100.
		int LayoutOrder = The order which this TitledFrame will sort to in a UIListLayout.
		table Content = The content to display in this TitledFrame.
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)
local Constants = require(Plugin.Src.Util.Constants)

local function TitledFrame(props)
	return withTheme(function(theme)
		return Roact.createElement("Frame", {
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Size = UDim2.new(1, 0, 0, props.MaxHeight or 100),
			LayoutOrder = props.LayoutOrder or 1,
		}, {
			Title = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2.new(0, Constants.CENTER_GUTTER, 1, 0),

				TextColor3 = theme.titledFrame.text,
				Font = Enum.Font.SourceSans,
				TextSize = 22,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				Text = props.Title,
			}),

			Content = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				BorderSizePixel = 0,

				Size = UDim2.new(1, -Constants.CENTER_GUTTER, 1, 0),
				AnchorPoint = Vector2.new(1, 0),
				Position = UDim2.new(1, 0, 0, 0),
			}, props.Content),
		})
	end)
end

return TitledFrame]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD593720A9A9C41508A8869618E7B159D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Header</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Header shown at the top of the currently opened page

	Props:
		string Title = The text to display for this header
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local function Header(props)
	return withTheme(function(theme)
		return Roact.createElement("TextLabel", {
			Size = UDim2.new(1, 0, 0, Constants.HEADER_HEIGHT),
			Text = props.Title,
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Font = Enum.Font.SourceSans,
			TextSize = 24,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Bottom,
			TextColor3 = theme.header.text,
			LayoutOrder = props.LayoutOrder or 1,
		})
	end)
end

return Header]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9790AAD4F7B6410C9A78CF3B40BEC809">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StyledScrollingFrame</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Scrolling frame component with a custom scrollbar that mimics the Studio start page

	Props:
		UDim2 Position = UDim2.new(0, 0, 0, 0)
		UDim2 Size = UDim2.new(1, 0, 1, 0)
		UDim2 CanvasSize = UDim2.new(1, 0, 1, 0)
		number LayoutOrder = 1
		number ZIndex = 1
		boolean Visible = true
]]

local SCROLLBAR_TOP_IMAGE = "rbxasset://textures/StudioToolbox/ScrollBarTop.png"
local SCROLLBAR_MIDDLE_IMAGE = "rbxasset://textures/StudioToolbox/ScrollBarMiddle.png"
local SCROLLBAR_BOTTOM_IMAGE = "rbxasset://textures/StudioToolbox/ScrollBarBottom.png"
local SCROLLBAR_THICKNESS = 8
local SCROLLBAR_PADDING = 2

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local StyledScrollingFrame = Roact.PureComponent:extend("StyledScrollingFrame")

function StyledScrollingFrame:render()
	return withTheme(function(theme)
		local position = self.props.Position or UDim2.new(0, 0, 0, 0)
		local size = self.props.Size or UDim2.new(1, 0, 1, 0)
		local canvasSize = self.props.CanvasSize or UDim2.new(1, 0, 1, 0)

		local layoutOrder = self.props.LayoutOrder or 1
		local zindex = self.props.ZIndex or 1
		local visible = (self.props.Visible ~= nil and self.props.Visible) or (self.props.Visible == nil)

		return Roact.createElement("Frame", {
			Position = position,
			Size = size,
			BackgroundTransparency = 1,

			LayoutOrder = layoutOrder,
			ZIndex = zindex,
			Visible = visible,

			ClipsDescendants = self.props.ClipsDescendants,
		}, {
			ScrollingFrame = Roact.createElement("ScrollingFrame", {
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, -SCROLLBAR_PADDING, 1, 0),
				CanvasSize = canvasSize,
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				ScrollBarThickness = SCROLLBAR_THICKNESS,
				ScrollBarImageColor3 = theme.scrollBar,
				ZIndex = 2,

				TopImage = SCROLLBAR_TOP_IMAGE,
				MidImage = SCROLLBAR_MIDDLE_IMAGE,
				BottomImage = SCROLLBAR_BOTTOM_IMAGE,

				ScrollingEnabled = not self.props.DisableScrolling,
				ElasticBehavior = Enum.ElasticBehavior.Always,
				ScrollingDirection = Enum.ScrollingDirection.Y,

				[Roact.Change.CanvasPosition] = self.props.onScroll,
				[Roact.Ref] = self.props[Roact.Ref],
			}, self.props[Roact.Children]),
		})
	end)
end

return StyledScrollingFrame
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX104FBAACDADA4E449B32E1A46CD9F4E1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ButtonBar</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A horizontal collection of RoundTextButtons.

	Props:
		Enum.HorizontalAlignment HorizontalAlignment = The alignment of the button bar.
			Determines if buttons should be centered or aligned to one corner.
		table Buttons = The buttons to add to this button bar.
]]

local BUTTON_BAR_PADDING = 25
local BUTTON_BAR_EDGE_PADDING = 35

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local RoundTextButton = require(Plugin.Src.Components.RoundTextButton)

local function ButtonBar(props)
	return withTheme(function(theme)
		local horizontalAlignment = props.HorizontalAlignment
		local buttons = props.Buttons

		local components = {
			Layout = Roact.createElement("UIListLayout", {
				Padding = UDim.new(0, BUTTON_BAR_PADDING),
				HorizontalAlignment = horizontalAlignment,
				SortOrder = Enum.SortOrder.LayoutOrder,
				FillDirection = Enum.FillDirection.Horizontal,
			})
		}

		if horizontalAlignment ~= Enum.HorizontalAlignment.Center then
			table.insert(components, Roact.createElement("UIPadding", {
				PaddingRight = UDim.new(0, BUTTON_BAR_EDGE_PADDING),
			}))
		end

		for i, button in ipairs(buttons) do
			table.insert(components, Roact.createElement(RoundTextButton, {
				LayoutOrder = i,
				Style = button.Default and theme.defaultButton or theme.cancelButton,
				BorderMatchesBackground = button.Default and not theme.isDarkerTheme,
				Size = UDim2.new(0, Constants.BUTTON_WIDTH, 1, 0),
				Active = button.Active,
				Name = button.Name,
				Value = button.Value,

				OnClicked = function(value)
					props.ButtonClicked(value)
				end,
			}))
		end

		return Roact.createElement("Frame", {
			LayoutOrder = props.LayoutOrder or 1,
			Size = UDim2.new(1, 0, 0, Constants.BUTTON_HEIGHT),
			AnchorPoint = props.AnchorPoint or Vector2.new(0, 0.5),
			Position = props.Position or UDim2.new(0, 0, 0.5, 0),
			BackgroundTransparency = 1,
		}, components)
	end)
end

return ButtonBar]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX666AB037B11B4F05AE7F38ED2B8B3823">
					<Properties>
						<string name="Name">Dialog</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXCD1D0B12527A4172B8167A3922411350">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">WarningDialog</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	A dialog that displays a warning image and message.
	Used with the showDialog function.

	Props:
		string Header = The header text to display at the top of this Dialog.
		string Description = The main message to display in this Dialog.
		table Buttons = {string cancelButtonName, string confirmButtonName}
]]

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)
local Constants = require(Plugin.Src.Util.Constants)

local BaseDialog = require(Plugin.Src.Components.Dialog.BaseDialog)

local function WarningDialog(props)
	return withTheme(function(theme)
		local buttons = props.Buttons
		local header = props.Header
		local description = props.Description

		return Roact.createElement(BaseDialog, {
			Buttons = buttons,
			OnResult = props.OnResult,
		}, {
			Header = Roact.createElement("TextLabel", {
				Size = UDim2.new(1, -60, 0, 23),
				AnchorPoint = Vector2.new(0.5, 0),
				Position = UDim2.new(0.5, 0, 0, 30),
				BackgroundTransparency = 1,
				Text = header,
				Font = Enum.Font.SourceSans,
				TextColor3 = theme.dialog.text,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextSize = 24,
			}),

			Description = Roact.createElement("TextLabel", {
				Size = UDim2.new(0, 387, 0, 40),
				Position = UDim2.new(0, 56, 0, 65),
				BackgroundTransparency = 1,
				Text = description,
				Font = Enum.Font.SourceSans,
				TextColor3 = Constants.WARNING_COLOR,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextSize = 20,
				TextWrapped = true,
			}),

			Warning = Roact.createElement("ImageLabel", {
				Image = Constants.WARNING_IMAGE,
				BackgroundTransparency = 1,
				Size = UDim2.new(0, 16, 0, 16),
				Position = UDim2.new(0, 30, 0, 68),
			}),
		})
	end)
end

return WarningDialog]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF192F6F306D64A08B04DC38EC2CD8BA3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseDialog</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	A generic dialog that prompts the user for a response.

	Props:
		table Buttons = {string cancelButtonName, string confirmButtonName}
]]

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Cryo = require(Plugin.Cryo)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local ButtonBar = require(Plugin.Src.Components.ButtonBar)

local function BaseDialog(props)
	return withTheme(function(theme)
		local buttons = props.Buttons

		return Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 1, 0),
			BorderSizePixel = 0,
			BackgroundColor3 = theme.dialog.background,
		}, Cryo.Dictionary.join(props[Roact.Children], {
			Buttons = Roact.createElement(ButtonBar, {
				Position = UDim2.new(0, 0, 1, -29),
				AnchorPoint = Vector2.new(0, 1),
				Buttons = {
					{Name = buttons[1], Active = true, Value = false},
					{Name = buttons[2], Default = true, Active = true, Value = true},
				},
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				ButtonClicked = props.OnResult
			})
		}))
	end)
end

return BaseDialog]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX827D968647D34AAE99BD2F45F5157357">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SimpleDialog</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	A dialog that displays one line of text.
	Used with the showDialog function.

	Props:
		string Header = The header text to display at the top of this Dialog.
		table Buttons = {string cancelButtonName, string confirmButtonName}
]]

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local BaseDialog = require(Plugin.Src.Components.Dialog.BaseDialog)

local function SimpleDialog(props)
	return withTheme(function(theme)
		local header = props.Header
		local buttons = props.Buttons

		return Roact.createElement(BaseDialog, {
			Buttons = buttons,
			OnResult = props.OnResult,
		}, {
			Header = Roact.createElement("TextLabel", {
				Position = UDim2.new(0.5, 0, 0, 30),
				AnchorPoint = Vector2.new(0.5, 0),
				Size = UDim2.new(1, 0, 0, 23),
				BackgroundTransparency = 1,
				Text = header,
				Font = Enum.Font.SourceSans,
				TextColor3 = theme.dialog.text,
				TextSize = 24,
			}),
		})
	end)
end

return SimpleDialog]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX27E8A82200CA46EC868F7CD905EBD6D5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ListDialog</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	A dialog that displays multiple text items in a list.
	Used with the showDialog function.

	Props:
		string Header = The header text to display at the top of this Dialog.
		list Entries = The entries to display in this Dialog.
		table Buttons = {string cancelButtonName, string confirmButtonName}
]]

local DOT = "rbxasset://textures/GameSettings/RadioButton.png"

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local BaseDialog = require(Plugin.Src.Components.Dialog.BaseDialog)

local function ListDialog(props)
	return withTheme(function(theme)
		local header = props.Header
		local entries = props.Entries
		local buttons = props.Buttons

		local entriesList = {
			Layout = Roact.createElement("UIListLayout", {
				Padding = UDim.new(0, 4),
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
		}

		for i, item in ipairs(entries) do
			table.insert(entriesList, Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				LayoutOrder = i,
				Size = UDim2.new(1, 0, 0, 20),
			}, {
				Text = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 16, 0, 0),
					Size = UDim2.new(1, -16, 1, 0),
					Text = item,
					Font = Enum.Font.SourceSans,
					TextColor3 = theme.dialog.text,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 22,
				}),

				Dot = Roact.createElement("ImageLabel", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 0, 0.5, 0),
					Size = UDim2.new(0, 4, 0, 4),
					AnchorPoint = Vector2.new(0, 0.5),
					ImageColor3 = theme.dialog.text,
					Image = DOT,
				}),
			}))
		end

		return Roact.createElement(BaseDialog, {
			Buttons = buttons,
			OnResult = props.OnResult,
		}, {
			Header = Roact.createElement("TextLabel", {
				Size = UDim2.new(1, -60, 0, 46),
				AnchorPoint = Vector2.new(0.5, 0),
				Position = UDim2.new(0.5, 0, 0, 30),
				BackgroundTransparency = 1,
				Text = header,
				Font = Enum.Font.SourceSansSemibold,
				TextColor3 = theme.dialog.text,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextSize = 22,
				TextWrapped = true,
			}),

			Entries = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Size = UDim2.new(1, -60, 0, 120),
				AnchorPoint = Vector2.new(0.5, 0),
				Position = UDim2.new(0.5, 0, 0, 100),
			}, entriesList),
		})
	end)
end

return ListDialog]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX6DC62663BA4546F3AAECE8810B91801D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ExternalServicesWrapper</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Top-level component that wraps several providers into one.

	Props:
		store = A Rodux store to provide in the RoactRodux StoreProvider.
		theme = A Theme object to provide in the ThemeProvider.
		showDialog = A function to display a dialog using a PluginGui.
		impl = A SettingsImpl object to provide in the SettingsImplProvider.
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local RoactRodux = require(Plugin.RoactRodux)

local SettingsImplProvider = require(Plugin.Src.Providers.SettingsImplProvider)
local DialogProvider = require(Plugin.Src.Providers.DialogProvider)
local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

local function ExternalServicesWrapper(props)
	return Roact.createElement(RoactRodux.StoreProvider, {
		store = props.store
	}, {
		Roact.createElement(ThemeProvider, {
			theme = props.theme,
		}, {
			Roact.createElement(DialogProvider, {
				showDialog = props.showDialog,
			}, {
				Roact.createElement(SettingsImplProvider, {
					impl = props.impl,
				}, props[Roact.Children])
			}),
		}),
	})
end

return ExternalServicesWrapper]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA6B3D7B51D16480BBBDDEC6B9A1BDED7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CheckBox</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Clickable checkbox, from a CheckBoxSet.

	Props:
		string Id = Unique identifier of this CheckBox
		string Title = Text to display on this CheckBox
		bool Selected = Whether to display this CheckBox as selected
		bool Enabled = Whether this CheckBox accepts input
]]

local BACKGROUND_IMAGE = "rbxasset://textures/CollisionGroupsEditor/unchecked.png"
local SELECTED_IMAGE = "rbxasset://textures/CollisionGroupsEditor/checked-bluebg.png"

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local CheckBox = Roact.PureComponent:extend("CheckBox")

function CheckBox:mouseHoverChanged(hovering)
	--TODO: Set mouse to hand icon?
end

function CheckBox:render()
	return withTheme(function(theme)
		return Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 0, Constants.CHECKBOX_SIZE),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
		}, {
			Background = Roact.createElement("ImageButton", {
				Size = UDim2.new(0, Constants.CHECKBOX_SIZE, 0, Constants.CHECKBOX_SIZE),
				BackgroundTransparency = 1,
				ImageTransparency = self.props.Enabled and 0 or 0.8,
				Image = BACKGROUND_IMAGE,
				ImageColor3 = theme.checkBox.background,
				LayoutOrder = self.props.LayoutOrder or 1,

				[Roact.Event.MouseEnter] = function()
					if self.props.Enabled then
						self:mouseHoverChanged(true)
					end
				end,

				[Roact.Event.MouseLeave] = function()
					if self.props.Enabled then
						self:mouseHoverChanged(false)
					end
				end,

				-- Tell the CheckBoxSet that this was selected
				[Roact.Event.Activated] = function()
					if self.props.Enabled then
						self.props.OnClicked()
					end
				end,
			}, {
				Selection = Roact.createElement("ImageLabel", {
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 1, 0),
					Visible = self.props.Enabled and self.props.Selected,
					Image = SELECTED_IMAGE,
				}),

				TitleLabel = Roact.createElement("TextButton", {
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(0, 250, 1, 0),
					AnchorPoint = Vector2.new(0, 0.5),
					Position = UDim2.new(1, 10, 0.5, 0),

					TextColor3 = theme.checkBox.title,
					Font = Enum.Font.SourceSans,
					TextSize = 22,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Center,
					TextTransparency = self.props.Enabled and 0 or 0.5,
					Text = self.props.Title or self.props.Id,

					[Roact.Event.Activated] = function()
						if self.props.Enabled then
							self.props.OnClicked()
						end
					end,
				}),
			}),
		})
	end)
end

return CheckBox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCDA5AF7053F64825A9589075AEE64DE6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TextEntry</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A text entry that is only one line.
	Used in a RoundTextBox when Multiline is false.

	Props:
		string Text = The text to display
		bool Visible = Whether to display this component
		function SetText(text) = Callback to tell parent that text has changed
		function FocusChanged(focus) = Callback to tell parent that this component has focus
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)

local TextEntry = Roact.PureComponent:extend("TextEntry")

function TextEntry:init()
	self.textBoxRef = Roact.createRef()
	self.onTextChanged = function(rbx)
		if rbx.TextFits then
			rbx.TextXAlignment = Enum.TextXAlignment.Left
		else
			rbx.TextXAlignment = Enum.TextXAlignment.Right
		end
		if rbx.Text ~= self.props.Text then
			self.props.SetText(rbx.Text)
		end
	end
end

function TextEntry:render()
	return Roact.createElement("Frame", {
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		ClipsDescendants = true,
	}, {
		Text = Roact.createElement("TextBox", {
			Visible = self.props.Visible,

			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,

			ClearTextOnFocus = false,
			Font = Enum.Font.SourceSans,
			TextSize = 22,
			TextColor3 = self.props.TextColor3,
			Text = self.props.Text,
			TextXAlignment = Enum.TextXAlignment.Left,

			[Roact.Ref] = self.textBoxRef,

			[Roact.Event.Focused] = function()
				self.props.FocusChanged(true)
			end,

			[Roact.Event.FocusLost] = function()
				local textBox = self.textBoxRef.current
				textBox.TextXAlignment = Enum.TextXAlignment.Left
				self.props.FocusChanged(false)
			end,

			[Roact.Change.Text] = self.onTextChanged,
		}),
	})
end

return TextEntry
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC0F4046144FF4B2FA36990DAA7676753">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MultilineTextEntry</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A multiline text entry with a dynmically appearing scrollbar.
	Used in a RoundTextBox when Multiline is true.

	Props:
		string Text = The text to display
		bool Visible = Whether to display this component
		function SetText(text) = Callback to tell parent that text has changed
		function FocusChanged(focus) = Callback to tell parent that this component has focus
]]

local TextService = game:GetService("TextService")

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)

local StyledScrollingFrame = require(Plugin.Src.Components.StyledScrollingFrame)

local SCROLL_BAR_OUTSET = 9

local function MultilineTextEntry(props)
	return Roact.createElement(StyledScrollingFrame, {
		Size = UDim2.new(1, SCROLL_BAR_OUTSET, 1, 0),
		BackgroundTransparency = 1,
		ClipsDescendants = true,

		[Roact.Ref] = function(instance)
			if instance ~= nil then
				local sizeX = instance.AbsoluteSize.x
				local textSize = TextService:GetTextSize(
					props.Text,
					22,
					Enum.Font.SourceSans,
					Vector2.new(sizeX, 10000)
				)
				instance.CanvasSize = UDim2.new(0, textSize.x, 0, textSize.y)
			end
		end,
	}, {
		Padding = Roact.createElement("UIPadding", {
			PaddingRight = UDim.new(0, SCROLL_BAR_OUTSET),
		}),

		Text = Roact.createElement("TextBox", {
			Visible = props.Visible,
			MultiLine = true,
			TextWrapped = true,

			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,

			ClearTextOnFocus = false,
			Font = Enum.Font.SourceSans,
			TextSize = 22,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Top,
			TextColor3 = props.TextColor3,
			Text = props.Text,

			[Roact.Event.Focused] = function()
				props.FocusChanged(true)
			end,

			[Roact.Event.FocusLost] = function()
				props.FocusChanged(false)
			end,

			[Roact.Change.Text] = function(rbx)
				if rbx.Text ~= props.Text then
					props.SetText(rbx.Text)
				end
			end,
		}),
	})
end

return MultilineTextEntry
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0FA2363D14BC42E490B875FCCCA908C9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MainView</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	The top level container of the Game Settings window.
	Contains the menu bar, the footer, and the currently selected page.

	Props:
		table MenuEntries = The entries to show on the left side menu
		int Selected = The index of the currently selected menu entry
		function SelectionChanged = A callback when the selected entry is changed
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local MenuBar = require(Plugin.Src.Components.MenuBar)
local CurrentPage = require(Plugin.Src.Components.CurrentPage)
local Separator = require(Plugin.Src.Components.Separator)
local Footer = require(Plugin.Src.Components.Footer)

local MainView = Roact.PureComponent:extend("MainView")

function MainView:init()
	self.state = {
		Selected = 1,
	}
end

function MainView:pageSelected(index)
	self:setState({
		Selected = index,
	})
end

function MainView:render(props)
	return withTheme(function(theme)
		local Selected = self.state.Selected

		return Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundColor3 = theme.backgroundColor,
		}, {
			--Add padding to main frame
			Padding = Roact.createElement("UIPadding", {
				PaddingTop = UDim.new(0, 5),
			}),
			--Add MenuBar to the left side of the screen
			MenuBar = Roact.createElement(MenuBar, {
				Entries = self.props.MenuEntries,
				Selected = Selected,
				SelectionChanged = function(index)
					self:pageSelected(index)
				end,
			}),

			Separator = Roact.createElement(Separator, {
				Size = UDim2.new(0, 3, 1, 0),
				Position = UDim2.new(0, Constants.MENU_BAR_WIDTH, 0, 0),
			}),

			--Add the page we are currently on
			Page = Roact.createElement(CurrentPage, {
				Page = self.props.MenuEntries[Selected].Name,
			}),

			--Add footer for cancel and save buttons
			Footer = Roact.createElement(Footer, {
				OnClose = function(didSave, savePromise)
					self.props.OnClose(didSave, savePromise)
				end,
			})
		})
	end)
end

return MainView]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC54B8A71CD3541BA929EB5673DAF37B9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RadioButtonSet</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A set of an arbitrary number of RadioButtons.

	Props:
		int Selected = The current RadioButton to highlight.
		string Title = The title to place to the left of this RadioButtonSet.
		string Description = An optional secondary title to place above this RadioButtonSet.
		table Buttons = A collection of props for all RadioButtons to add.
		function SelectionChanged(index, title) = A callback for when the selected option changes.
		int LayoutOrder = The order this RadioButtonSet will sort to when placed in a UIListLayout.
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local RadioButton = require(Plugin.Src.Components.RadioButton)
local TitledFrame = require(Plugin.Src.Components.TitledFrame)

local function RadioButtonSet(props)
	return withTheme(function(theme)
		local selected
		if props.Selected ~= nil then
			selected = props.Selected
		else
			selected = 1
		end

		local buttons = props.Buttons
		local numButtons = #buttons

		local children = {
			Layout = Roact.createElement("UIListLayout", {
				Padding = UDim.new(0, Constants.RADIO_BUTTON_PADDING),
				SortOrder = Enum.SortOrder.LayoutOrder,
			})
		}

		if (props.Description) then
			table.insert(children, Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2.new(1, 0, 0, Constants.RADIO_BUTTON_SIZE + 5),
				TextColor3 = theme.radioButton.title,
				TextTransparency = props.Enabled and 0 or 0.5,
				Font = Enum.Font.SourceSans,
				TextSize = 22,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				Text = props.Description,
			}))
		end

		for i, button in ipairs(buttons) do
			table.insert(children, Roact.createElement(RadioButton, {
				Title = button.Title,
				Id = button.Id,
				Description = button.Description,
				Selected = (button.Id == selected) or (i == selected),
				Index = i,
				Enabled = props.Enabled,
				LayoutOrder = i,
				OnClicked = function()
					props.SelectionChanged(button)
				end,
			}))
		end

		local maxHeight = numButtons * Constants.RADIO_BUTTON_SIZE * 2
			+ numButtons * Constants.RADIO_BUTTON_PADDING
			+ (props.Description and Constants.RADIO_BUTTON_SIZE + 5 + Constants.RADIO_BUTTON_PADDING or 0)

		return Roact.createElement(TitledFrame, {
			Title = props.Title,
			Content = children,
			MaxHeight = maxHeight,
			LayoutOrder = props.LayoutOrder or 1,
		})
	end)
end

return RadioButtonSet]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4B5444A207F144CEA58F5A29F715F40A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CurrentPage</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Container for the currently opened SettingsPage
	Used to open any arbitrary page from SettingsPage with appropriate header and padding

	Props:
		string Page = The name of the SettingsPage to display. Pages can be found
			in the Src/SettingsPages folder and are referenced by name.
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)

local StyledScrollingFrame = require(Plugin.Src.Components.StyledScrollingFrame)
local Header = require(Plugin.Src.Components.Header)
local SettingsPages = require(Plugin.Src.Components.SettingsPages.SettingsPages)

local CurrentPage = Roact.PureComponent:extend("CurrentPage")

function CurrentPage:init()
	self.state = {
		ContentSize = UDim2.new(1, 0, 1, 0),
	}
end

function CurrentPage:contentHeightChanged(newheight)
	self:setState(function(state)
		return {
		ContentSize = UDim2.new(1, 0, 0, newheight
			+ Constants.ELEMENT_PADDING + Constants.HEADER_HEIGHT + Constants.ELEMENT_PADDING),
		}
	end)
end

function CurrentPage:render()
	local page = SettingsPages[self.props.Page]
	local contentSize = self.state.ContentSize

	return Roact.createElement(StyledScrollingFrame, {
		Position = UDim2.new(0, Constants.MENU_BAR_WIDTH, 0, 0),
		Size = UDim2.new(1, -Constants.MENU_BAR_WIDTH - 5, 1, -Constants.FOOTER_HEIGHT),
		CanvasSize = contentSize,
	}, {
		Padding = Roact.createElement("UIPadding", {
			PaddingLeft = UDim.new(0, 25),
			PaddingRight = UDim.new(0, 25),
		}),

		Layout = Roact.createElement("UIListLayout", {
			Padding = UDim.new(0, 25),
			SortOrder = Enum.SortOrder.LayoutOrder,
		}),

		Header = Roact.createElement(Header, {
			Title = self.props.Page,
			LayoutOrder = 1,
		}),

		[self.props.Page] = page and Roact.createElement(page, {
			ContentHeightChanged = function(height)
				self:contentHeightChanged(height)
			end,
			LayoutOrder = 2,
		}),
	})
end

return CurrentPage]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX55DD0142B4A6454DBCA7628E2689DA51">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Separator</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A simple gray rectangle used to separate elements in the page.
	Can also be customized using its Size and Position.

	Props:
		UDim2 Size = UDim2.new(1, 0, 0, 3)
		UDim2 Position = UDim2.new()
		int LayoutOrder = The order this Separator will sort to when placed in a UIListLayout.
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local function Separator(props)
	return withTheme(function(theme)
		return Roact.createElement("Frame", {
			Size = props.Size or UDim2.new(1, 0, 0, 2),
			Position = props.Position,
			BackgroundColor3 = theme.separator,
			BorderSizePixel = 0,
			LayoutOrder = props.LayoutOrder or 1,
		})
	end)
end

return Separator]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX115DD091A983477EAD88F73A64A945F0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Footer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Footer shown at the bottom of the Game Settings widget.
	Contains the Save and Cancel buttons.

	Props:
		bool SaveActive = Whether or not saving is currently allowed.
			This will enable the Save button if true.
]]

local FOOTER_GRADIENT_SIZE = 10
local FOOTER_GRADIENT_TRANSPARENCY = 0.9
local GRADIENT_IMAGE = "rbxasset://textures/gradient.png"
local GRADIENT_RECT_SIZE = Vector2.new(512, 256)

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local RoactRodux = require(Plugin.RoactRodux)
local Promise = require(Plugin.Promise)

local withTheme = require(Plugin.Src.Consumers.withTheme)
local Constants = require(Plugin.Src.Util.Constants)
local isEmpty = require(Plugin.Src.Util.isEmpty)
local getSettingsImpl = require(Plugin.Src.Consumers.getSettingsImpl)

local ButtonBar = require(Plugin.Src.Components.ButtonBar)

local SaveChanges = require(Plugin.Src.Thunks.SaveChanges)
local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

local Footer = Roact.PureComponent:extend("Footer")

function Footer:render()
	return withTheme(function(theme)
		local interface = getSettingsImpl(self)
		local saveActive = self.props.SaveActive
		local cancelActive = self.props.CancelActive

		return Roact.createElement("Frame", {
			BackgroundColor3 = theme.backgroundColor,
			BorderSizePixel = 0,
			Size = UDim2.new(1, 0, 0, Constants.FOOTER_HEIGHT),
			AnchorPoint = Vector2.new(0, 1),
			Position = UDim2.new(0, 0, 1, 0),
			ZIndex = 2,
		}, {
			Gradient = Roact.createElement("ImageLabel", {
				Size = UDim2.new(1, 0, 0, FOOTER_GRADIENT_SIZE),
				AnchorPoint = Vector2.new(0, 1),
				Image = GRADIENT_IMAGE,
				ImageRectSize = GRADIENT_RECT_SIZE,
				BorderSizePixel = 0,
				BackgroundTransparency = 1,
				ImageColor3 = theme.footer.gradient,
				ImageTransparency = FOOTER_GRADIENT_TRANSPARENCY,
				ZIndex = 1,
			}),

			SaveSettings = Roact.createElement(ButtonBar, {
				Buttons = {
					{Name = "Cancel", Active = cancelActive, Value = false},
					{Name = "Save", Default = true, Active = saveActive, Value = true},
				},
				HorizontalAlignment = Enum.HorizontalAlignment.Right,
				ButtonClicked = function(userPressedSave)
					self.props.ButtonClicked(userPressedSave, interface):await()
					self.props.OnClose(userPressedSave)
				end,
			}),
		})
	end)
end

Footer = RoactRodux.connect(
	function(state, props)
		if not state then return end
		return {
			SaveActive = not isEmpty(state.Settings.Changed)
				and state.Status == CurrentStatus.Open
				and isEmpty(state.Settings.Errors),
			CancelActive = state.Status == CurrentStatus.Open
		}
	end,
	function(dispatch)
		return {
			ButtonClicked = function(userPressedSave, interface)
				if userPressedSave then
					return dispatch(SaveChanges(interface))
				else
					return Promise.resolve()
				end
			end,
		}
	end
)(Footer)

return Footer]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9360BE28BE424C1CA0921F2EFEC2D3AD">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundTextButton</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A button with rounded corners.

	Supports one of two styles:
		"Blue": A blue button with white text and no border.
		"White": A white button with black text and a black border.

	Props:
		bool Active = Whether or not this button can be clicked.
		UDim2 Size = UDim2.new(0, Constants.BUTTON_WIDTH, 0, Constants.BUTTON_HEIGHT)
		int LayoutOrder = The order this RoundTextButton will sort to when placed in a UIListLayout.
		string Name = The text to display in this Button.
		function OnClicked = The function that will be called when this button is clicked.
		variant Value = Data that can be accessed from the OnClicked callback.
		table Style = {
			ButtonColor,
			ButtonColor_Hover,
			ButtonColor_Disabled,
			TextColor,
			TextColor_Disabled,
			BorderColor,
		}
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)

local RoundTextButton = Roact.PureComponent:extend("RoundTextButton")

function RoundTextButton:init()
	self.state = {
		Hovering = false,
	}
end

function RoundTextButton:mouseHoverChanged(hovering)
	self:setState({
		Hovering = hovering,
	})
end

function RoundTextButton:render()
	local active = self.props.Active
	local hovering = self.state.Hovering
	local style = self.props.Style
	local match = self.props.BorderMatchesBackground

	local backgroundProps = {
		-- Necessary to make the rounded background
		BackgroundTransparency = 1,
		Image = Constants.ROUNDED_BACKGROUND_IMAGE,
		ImageTransparency = 0,
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Constants.ROUNDED_FRAME_SLICE,

		Position = UDim2.new(0, 0, 0, 0),
		Size = self.props.Size or UDim2.new(0, Constants.BUTTON_WIDTH, 0, Constants.BUTTON_HEIGHT),

		LayoutOrder = self.props.LayoutOrder or 1,

		[Roact.Event.MouseEnter] = function()
			if active then
				self:mouseHoverChanged(true)
			end
		end,

		[Roact.Event.MouseLeave] = function()
			if active then
				self:mouseHoverChanged(false)
			end
		end,

		[Roact.Event.Activated] = function()
			if active then
				self.props.OnClicked(self.props.Value)
			end
		end,
	}

	if active then
		backgroundProps.ImageColor3 = hovering and style.ButtonColor_Hover or style.ButtonColor
	else
		backgroundProps.ImageColor3 = style.ButtonColor_Disabled
	end

	return Roact.createElement("ImageButton", backgroundProps, {
		Border = Roact.createElement("ImageLabel", {
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
			Image = Constants.ROUNDED_BORDER_IMAGE,
			ImageColor3 = match and backgroundProps.ImageColor3 or style.BorderColor,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Constants.ROUNDED_FRAME_SLICE,
		}),

		Text = Roact.createElement("TextLabel", {
			Size = UDim2.new(1, 0, 1, 0),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Font = Enum.Font.SourceSans,
			TextColor3 = active and style.TextColor or style.TextColor_Disabled,
			TextSize = 22,
			Text = self.props.Name,
		}),
	})
end

return RoundTextButton
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB6AE669E79A947BFB8E2298AA462B5B5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CheckBoxSet</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A set of an arbitrary number of CheckBoxes.

	Props:
		string Title = The title to place to the left of this CheckBoxSet.
		table Boxes = A collection of props for all CheckBoxes to add.
		function EntryClicked(box) = A callback for when a CheckBox was clicked.
		int LayoutOrder = The order this CheckBoxSet will sort to when placed in a UIListLayout.
		string ErrorMessage = An error message to display on this CheckBoxSet.
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local CheckBox = require(Plugin.Src.Components.CheckBox)
local TitledFrame = require(Plugin.Src.Components.TitledFrame)

local function CheckBoxSet(props)
	return withTheme(function(theme)
		local boxes = props.Boxes
		local numBoxes = #boxes
		local errorState = props.ErrorMessage ~= nil

		local children = {
			Layout = Roact.createElement("UIListLayout", {
				Padding = UDim.new(0, Constants.CHECKBOX_PADDING),
				SortOrder = Enum.SortOrder.LayoutOrder,
			})
		}

		for i, box in ipairs(boxes) do
			table.insert(children, Roact.createElement(CheckBox, {
				Title = box.Title,
				Id = box.Id,
				Description = box.Description,
				Selected = box.Selected,
				Enabled = props.Enabled,
				LayoutOrder = i,
				OnClicked = function()
					props.EntryClicked(box)
				end,
			}))
		end

		if errorState then
			children.Error = Roact.createElement("TextBox", {
				LayoutOrder = numBoxes + 1,
				Size = UDim2.new(1, 0, 0, Constants.CHECKBOX_SIZE),
				BackgroundTransparency = 1,
				TextColor3 = Constants.ERROR_COLOR,
				Text = props.ErrorMessage,
				Font = Enum.Font.SourceSans,
				TextSize = 16,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Center,
			})
		end

		local maxHeight = numBoxes * Constants.CHECKBOX_SIZE
			+ numBoxes * Constants.CHECKBOX_PADDING

		return Roact.createElement(TitledFrame, {
			Title = props.Title,
			Content = children,
			MaxHeight = maxHeight,
			LayoutOrder = props.LayoutOrder or 1,
		})
	end)
end

return CheckBoxSet]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE421977470164253B2C9E11910C0135D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RadioButton</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Hoverable and clickable radio button, from a RadioButtonSet.

	Props:
		string Id = Unique identifier of this RadioButton
		string Title = Text to display on this RadioButton
		string Description = Smaller tooltip text to display below this RadioButton
		bool Selected = Whether to display this RadioButton as selected
		int Index = The order in which this RadioButton is displayed, top to bottom
		bool Enabled = Whether this RadioButton accepts input
]]

local BACKGROUND_IMAGE = "rbxasset://textures/GameSettings/RadioButton.png"
local SELECTED_IMAGE = "rbxasset://textures/ui/LuaApp/icons/ic-blue-dot.png"

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local RadioButton = Roact.PureComponent:extend("RadioButton")

function RadioButton:mouseHoverChanged(hovering)
	--TODO: Set mouse to hand icon?
end

function RadioButton:render()
	return withTheme(function(theme)
		return Roact.createElement("Frame", {
			Size = UDim2.new(1, 0, 0, Constants.RADIO_BUTTON_SIZE * 2),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
		}, {
			Button = Roact.createElement("ImageButton", {
				Size = UDim2.new(0, Constants.RADIO_BUTTON_SIZE, 0, Constants.RADIO_BUTTON_SIZE),
				BackgroundTransparency = 1,
				ImageTransparency = self.props.Enabled and 0 or 0.8,
				Image = BACKGROUND_IMAGE,
				ImageColor3 = theme.radioButton.background,
				LayoutOrder = self.props.LayoutOrder or 1,

				[Roact.Event.MouseEnter] = function()
					if self.props.Enabled then
						self:mouseHoverChanged(true)
					end
				end,

				[Roact.Event.MouseLeave] = function()
					if self.props.Enabled then
						self:mouseHoverChanged(false)
					end
				end,

				-- Tell the RadioButtonSet that this is the currently selected button
				[Roact.Event.Activated] = function()
					if self.props.Enabled then
						self.props.OnClicked()
					end
				end,
			}, {
				Highlight = Roact.createElement("ImageLabel", {
					BackgroundTransparency = 1,
					Size = theme.isDarkerTheme and UDim2.new(0.5, 0, 0.5, 0) or UDim2.new(0.6, 0, 0.6, 0),
					Position = UDim2.new(0.5, 0, 0.5, 0),
					AnchorPoint = Vector2.new(0.5, 0.5),
					Visible = self.props.Enabled and self.props.Selected,
					Image = SELECTED_IMAGE,
				}),

				TitleLabel = Roact.createElement("TextButton", {
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(0, 250, 1, 0),
					AnchorPoint = Vector2.new(0, 0.5),
					Position = UDim2.new(1, 10, 0.5, 0),

					TextColor3 = theme.radioButton.title,
					Font = Enum.Font.SourceSans,
					TextSize = 22,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Center,
					TextTransparency = self.props.Enabled and 0 or 0.5,
					Text = self.props.Title,

					[Roact.Event.Activated] = function()
						if self.props.Enabled then
							self.props.OnClicked()
						end
					end,
				}),

				DescriptionLabel = Roact.createElement("TextButton", {
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(0, 250, 1, 0),
					Position = UDim2.new(1, 10, 1, 2),

					TextColor3 = theme.radioButton.description,
					Font = Enum.Font.SourceSans,
					TextSize = 16,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					Text = self.props.Description or "",

					[Roact.Event.Activated] = function()
						if self.props.Enabled then
							self.props.OnClicked()
						end
					end,
				}),
			}),
		})
	end)
end

return RadioButton]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXF7C0809C307D43A8A5E103D1DA570C7F">
					<Properties>
						<string name="Name">SettingsPages</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0FC6D496CE714CF19AAFA6535A4400DE">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Options</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Settings page for Http settings (formerly known as Security).
		- Http Enabled

	Settings:
		bool HttpEnabled - Whether the game is allowed to access external Http endpoints
]]

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local RoactRodux = require(Plugin.RoactRodux)
local Constants = require(Plugin.Src.Util.Constants)

local settingFromState = require(Plugin.Src.Networking.settingFromState)

local RadioButtonSet = require(Plugin.Src.Components.RadioButtonSet)

local AddChange = require(Plugin.Src.Actions.AddChange)

local function Options(props)
	--Make container for this page
	return Roact.createElement("Frame", {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		LayoutOrder = props.LayoutOrder,
	}, {
		Layout = Roact.createElement("UIListLayout", {
			Padding = UDim.new(0, Constants.ELEMENT_PADDING),
			SortOrder = Enum.SortOrder.LayoutOrder,

			[Roact.Change.AbsoluteContentSize] = function(rbx)
				props.ContentHeightChanged(rbx.AbsoluteContentSize.y)
			end,
		}),

		Http = Roact.createElement(RadioButtonSet, {
			Title = "Allow HTTP Requests",
			Buttons = {{
					Id = true,
					Title = "On",
					Description = "Allow game server to issue requests to remote servers.",
				}, {
					Id = false,
					Title = "Off",
				},
			},
			Enabled = props.HttpEnabled ~= nil,
			LayoutOrder = 3,
			--Functionality
			Selected = props.HttpEnabled,
			SelectionChanged = props.HttpEnabledChanged,
		}),
	})
end

Options = RoactRodux.connect(
	function(state, props)
		if not state then return end
		return {
			HttpEnabled = settingFromState(state.Settings, "HttpEnabled"),
		}
	end,
	function(dispatch)
		return {
			HttpEnabledChanged = function(button)
				dispatch(AddChange("HttpEnabled", button.Id))
			end,
		}
	end
)(Options)

return Options]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX21AD6EF7E4834754B92A7C89DA8123EF">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Avatar</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Settings page for Avatar settings.
		- Avatar type
		- User choice override settings for avatar scales and animations
		- Avatar collision settings

	Settings:
		string AvatarType - Whether to morph the avatar to R6 or R15, or let the user decide
		string AvatarScaling - Whether to allow user scale settings for avatars
		string AvatarAnimation - Whether to allow user-equipped animation packs
		string AvatarCollision - Whether to define collision based on avatar scale
]]

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local RoactRodux = require(Plugin.RoactRodux)
local Constants = require(Plugin.Src.Util.Constants)

local settingFromState = require(Plugin.Src.Networking.settingFromState)
local showDialog = require(Plugin.Src.Consumers.showDialog)

local WarningDialog = require(Plugin.Src.Components.Dialog.WarningDialog)

local RadioButtonSet = require(Plugin.Src.Components.RadioButtonSet)

local AddChange = require(Plugin.Src.Actions.AddChange)

local Avatar = Roact.PureComponent:extend("Avatar")

function Avatar:render()
	--Make container for this page
	return Roact.createElement("Frame", {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		LayoutOrder = self.props.LayoutOrder,
	}, {
		Layout = Roact.createElement("UIListLayout", {
			Padding = UDim.new(0, Constants.ELEMENT_PADDING),
			SortOrder = Enum.SortOrder.LayoutOrder,

			[Roact.Change.AbsoluteContentSize] = function(rbx)
				self.props.ContentHeightChanged(rbx.AbsoluteContentSize.y)
			end,
		}),

		Type = Roact.createElement(RadioButtonSet, {
			Title = "Avatar Type",
			Buttons = {{
					Id = "MorphToR6",
					Title = "Morph to R6",
					Description = "Classic arm and leg movement."
				}, {
					Id = "MorphToR15",
					Title = "Morph to R15",
					Description = "Freedom of movement with elbows and knees."
				}, {
					Id = "PlayerChoice",
					Title = "Players Choice",
					Description = "The game will allow R6 or R15 avatars."
				},
			},
			Enabled = self.props.AvatarType ~= nil,
			LayoutOrder = 2,
			--Functionality
			Selected = self.props.AvatarType,
			SelectionChanged = function(button)
				if button.Id ~= "PlayerChoice" then
					local dialogProps = {
						Title = "Warning",
						Header = "Would you like to proceed?",
						Description = "Changing the game's Avatar Type to this setting "
							.. "will shut down any running games.",
						Buttons = {"No", "Yes"},
					}
					if not showDialog(self, WarningDialog, dialogProps):await() then
						return
					end
				end
				self.props.AvatarTypeChanged(button)
			end,
		}),

		Scaling = Roact.createElement(RadioButtonSet, {
			Title = "Scaling",
			Buttons = {{
					Id = "NoScales",
					Title = "Standard",
					Description = "Classic set of proportions."
				}, {
					Id = "AllScales",
					Title = "Players Choice",
					Description = "Allow players to use their own height and width."
				},
			},
			Enabled = self.props.AvatarScaling ~= nil and self.props.AvatarType ~= "MorphToR6",
			LayoutOrder = 3,
			--Functionality
			Selected = self.props.AvatarScaling,
			SelectionChanged = self.props.AvatarScalingChanged,
		}),

		Animation = Roact.createElement(RadioButtonSet, {
			Title = "Animation",
			Buttons = {{
					Id = "Standard",
					Title = "Standard",
					Description = "The default animation set."
				}, {
					Id = "PlayerChoice",
					Title = "Players Choice",
					Description = "Allow players to use their own custom set of animations."
				},
			},
			Enabled = self.props.AvatarAnimation ~= nil and self.props.AvatarType ~= "MorphToR6",
			LayoutOrder = 4,
			--Functionality
			Selected = self.props.AvatarAnimation,
			SelectionChanged = self.props.AvatarAnimationChanged,
		}),

		Collision = Roact.createElement(RadioButtonSet, {
			Title = "Collision",
			Buttons = {{
					Id = "InnerBox",
					Title = "Inner Box",
					Description = "Fixed size collision boxes."
				}, {
					Id = "OuterBox",
					Title = "Outer Box",
					Description = "Dynamically sized collision boxes based on mesh sizes."
				},
			},
			Enabled = self.props.AvatarCollision ~= nil and self.props.AvatarType ~= "MorphToR6",
			LayoutOrder = 5,
			--Functionality
			Selected = self.props.AvatarCollision,
			SelectionChanged = self.props.AvatarCollisionChanged,
		}),
	})
end

Avatar = RoactRodux.connect(
	function(state, props)
		if not state then return end
		return {
			AvatarType = settingFromState(state.Settings, "universeAvatarType"),
			AvatarScaling = settingFromState(state.Settings, "universeScaleType"),
			AvatarAnimation = settingFromState(state.Settings, "universeAnimationType"),
			AvatarCollision = settingFromState(state.Settings, "universeCollisionType"),
		}
	end,
	function(dispatch)
		return {
			AvatarTypeChanged = function(button)
				dispatch(AddChange("universeAvatarType", button.Id))
			end,

			AvatarScalingChanged = function(button)
				dispatch(AddChange("universeScaleType", button.Id))
			end,

			AvatarAnimationChanged = function(button)
				dispatch(AddChange("universeAnimationType", button.Id))
			end,

			AvatarCollisionChanged = function(button)
				dispatch(AddChange("universeCollisionType", button.Id))
			end,
		}
	end
)(Avatar)

return Avatar]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX15F413FC9CCB431C9485515501FF05E2">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SettingsPages</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Modules for each SettingsPage are required here.
]]

local Avatar = require(script.Parent.Avatar)
local Options = require(script.Parent.Options)
local BasicInfo = require(script.Parent.BasicInfo)

local SettingsPages = {
	["Avatar"] = Avatar,
	["Options"] = Options,
	["Basic Info"] = BasicInfo,
}

return SettingsPages]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5C7E40B128EA4A20B4D77D599951DA8E">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BasicInfo</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[--[[
	Settings page for Basic Info settings.
		- Game name and description
		- Game privacy settings (who is allowed to play the game)
		- Playable Devices (which devices can run this game)

	Settings:
		string Name - The game name
		bool IsActive - Whether the game is public or private
		bool IsFriendsOnly - Whether the game is open to everyone or only friends
		string Description - The game description
		table Devices - A map of which devices are playable

	Errors:
		name: "Empty", "TooLong"
		description: "TooLong"
		devices: "NoDevices"
]]

local MAX_NAME_LENGTH = 50
local MAX_DESCRIPTION_LENGTH = 1000

local nameErrors = {
	Moderated = "The name didn't go through our moderation. Please revise it and try again.",
	Empty = "Name cannot be empty.",
}

local descriptionErrors = {
	Moderated = "The description didn't go through our moderation. Please revise it and try again.",
}

local Plugin = script.Parent.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local RoactRodux = require(Plugin.RoactRodux)
local Cryo = require(Plugin.Cryo)
local Constants = require(Plugin.Src.Util.Constants)

local settingFromState = require(Plugin.Src.Networking.settingFromState)
local showDialog = require(Plugin.Src.Consumers.showDialog)

local TitledFrame = require(Plugin.Src.Components.TitledFrame)
local RadioButtonSet = require(Plugin.Src.Components.RadioButtonSet)
local CheckBoxSet = require(Plugin.Src.Components.CheckBoxSet)
local RoundTextBox = require(Plugin.Src.Components.RoundTextBox)
local Separator = require(Plugin.Src.Components.Separator)

local WarningDialog = require(Plugin.Src.Components.Dialog.WarningDialog)
local ListDialog = require(Plugin.Src.Components.Dialog.ListDialog)

local AddChange = require(Plugin.Src.Actions.AddChange)
local AddErrors = require(Plugin.Src.Actions.AddErrors)

local BasicInfo = Roact.PureComponent:extend("BasicInfo")

function BasicInfo:render()
	local devices = self.props.Devices

	return Roact.createElement("Frame", {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, 0),
		LayoutOrder = self.props.LayoutOrder,
	}, {
		Layout = Roact.createElement("UIListLayout", {
			Padding = UDim.new(0, Constants.ELEMENT_PADDING),
			SortOrder = Enum.SortOrder.LayoutOrder,

			[Roact.Change.AbsoluteContentSize] = function(rbx)
				self.props.ContentHeightChanged(rbx.AbsoluteContentSize.y)
			end,
		}),

		Name = Roact.createElement(TitledFrame, {
			Title = "Name",
			MaxHeight = 60,
			LayoutOrder = 1,
			Content = {
				TextBox = Roact.createElement(RoundTextBox, {
					Active = self.props.Name ~= nil,
					ErrorMessage = nameErrors[self.props.NameError],
					MaxLength = MAX_NAME_LENGTH,
					Text = self.props.Name or "",

					SetText = self.props.NameChanged,
				})
			}
		}),

		Description = Roact.createElement(TitledFrame, {
			Title = "Description",
			MaxHeight = 150,
			LayoutOrder = 2,
			Content = {
				TextBox = Roact.createElement(RoundTextBox, {
					Height = 130,
					Multiline = true,

					Active = self.props.Description ~= nil,
					ErrorMessage = descriptionErrors[self.props.DescriptionError],
					MaxLength = MAX_DESCRIPTION_LENGTH,
					Text = self.props.Description or "",

					SetText = self.props.DescriptionChanged,
				})
			}
		}),

		Separator = Roact.createElement(Separator, {
			LayoutOrder = 3,
		}),

		Playability = Roact.createElement(RadioButtonSet, {
			Title = "Playability",
			Description = "Who can see this game?",
			LayoutOrder = 4,
			Buttons = {{
					Id = true,
					Title = "Public",
					Description = "Anyone on Roblox"
				}, {
					Id = "Friends",
					Title = "Friends",
					Description = "Friends on Roblox"
				}, {
					Id = false,
					Title = "Only Me",
					Description = "Only available to yourself"
				},
			},
			Enabled = self.props.IsActive ~= nil,
			--Functionality
			Selected = self.props.IsFriendsOnly and "Friends" or self.props.IsActive,
			SelectionChanged = function(button)
				if button.Id == "Friends" then
					self.props.IsFriendsOnlyChanged(true)
					self.props.IsActiveChanged({Id = true})
				else
					if button.Id == false then
						local dialogProps = {
							Title = "Make Private",
							Header = "Would you like to make it private?",
							Description = "Making a game private will shut down any running games.",
							Buttons = {"No", "Yes"},
						}
						if not showDialog(self, WarningDialog, dialogProps):await() then
							return
						end
					end
					self.props.IsFriendsOnlyChanged(false)
					self.props.IsActiveChanged(button)
				end
			end,
		}),

		Separator2 = Roact.createElement(Separator, {
			LayoutOrder = 5,
		}),

		Devices = Roact.createElement(CheckBoxSet, {
			Title = "Playable Devices",
			LayoutOrder = 6,
			Boxes = {{
					Id = "Computer",
					Selected = devices and devices.Computer or false
				}, {
					Id = "Phone",
					Selected = devices and devices.Phone or false
				}, {
					Id = "Tablet",
					Selected = devices and devices.Tablet or false
				}, {
					Id = "Console",
					Selected = devices and devices.Console or false
				},
			},
			Enabled = devices ~= nil,
			ErrorMessage = (self.props.DevicesError and "You must select at least one playable device.") or nil,
			--Functionality
			EntryClicked = function(box)
				if box.Id == "Console" and not box.Selected then
					local dialogProps = {
						Size = Vector2.new(460, 308),
						Title = "Content Agreement",
						Header = "Do you agree that your game is controller compatible "
							.. "and contains NONE of the following?",
						Entries = {
							"Blood or Gore",
							"Intense Violence",
							"Strong Language (Swearing)",
							"Robux Gambling",
							"Drug Reference or Use",
						},
						Buttons = {"Disagree", "Agree"},
					}
					if not showDialog(self, ListDialog, dialogProps):await() then
						return
					end
				end
				local newDevices = Cryo.Dictionary.join(devices, {
					[box.Id] = not box.Selected,
				})
				self.props.DevicesChanged(newDevices)
			end,
		}),
	})
end

BasicInfo = RoactRodux.connect(
	function(state, props)
		if not state then return end
		return {
			Name = settingFromState(state.Settings, "name"),
			IsActive = settingFromState(state.Settings, "isActive"),
			IsFriendsOnly = settingFromState(state.Settings, "isFriendsOnly"),
			Description = settingFromState(state.Settings, "description"),
			Devices = settingFromState(state.Settings, "playableDevices"),

			NameError = state.Settings.Errors.name,
			DescriptionError = state.Settings.Errors.description,
			DevicesError = state.Settings.Errors.playableDevices,
		}
	end,
	function(dispatch)
		return {
			NameChanged = function(text)
				dispatch(AddChange("name", text))
				local nameLength = string.len(text)
				if nameLength == 0 or string.len(string.gsub(text, " ", "")) == 0 then
					dispatch(AddErrors({name = "Empty"}))
				elseif nameLength > MAX_NAME_LENGTH then
					dispatch(AddErrors({name = "TooLong"}))
				end
			end,
			DescriptionChanged = function(text)
				dispatch(AddChange("description", text))
				local descriptionLength = string.len(text)
				if descriptionLength > MAX_DESCRIPTION_LENGTH then
					dispatch(AddErrors({description = "TooLong"}))
				end
			end,
			IsActiveChanged = function(button)
				dispatch(AddChange("isActive", button.Id))
			end,
			IsFriendsOnlyChanged = function(isFriendsOnly)
				dispatch(AddChange("isFriendsOnly", isFriendsOnly))
			end,
			DevicesChanged = function(devices)
				dispatch(AddChange("playableDevices", devices))
				for _, value in pairs(devices) do
					if value then
						return
					end
				end
				dispatch(AddErrors({playableDevices = "NoDevices"}))
			end,
		}
	end
)(BasicInfo)

return BasicInfo]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX97608FF62F6F4342A292EA9470D16C3D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MenuBar</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Menu bar that accepts any number of MenuEntries.

	Props:
		table Entries: A table of entries to include in this MenuBar
		function SelectionChanged: Callback when the selected menu entry changes
]]

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local RoactRodux = require(Plugin.RoactRodux)

local withTheme = require(Plugin.Src.Consumers.withTheme)
local Constants = require(Plugin.Src.Util.Constants)
local MenuEntry = require(Plugin.Src.Components.MenuEntry)

local errorsFromPage = {
	["Basic Info"] = {
		name = true,
		description = true,
		playableDevices = true,
	}
}

local function MenuBar(props)
	return withTheme(function(theme)
		local menuEntries = {
			Layout = Roact.createElement("UIListLayout", {
				Padding = UDim.new(0, 1),
			})
		}

		for i, entry in ipairs(props.Entries) do
			local errorHighlight = false
			if errorsFromPage[entry.Name] then
				for err in pairs(props.Errors) do
					if errorsFromPage[entry.Name][err] then
						errorHighlight = true
						break
					end
				end
			end

			table.insert(menuEntries, Roact.createElement(MenuEntry, {
				Title = entry.Name,
				Selected = (props.Selected == i),
				Index = i,
				Error = errorHighlight,

				OnClicked = function()
					props.SelectionChanged(i)
				end,
			}))
		end

		return Roact.createElement("Frame", {
			Size = UDim2.new(0, Constants.MENU_BAR_WIDTH, 1, 0),
			BackgroundColor3 = theme.menuBar.backgroundColor,
			BorderSizePixel = 0,
		}, menuEntries)
	end)
end

MenuBar = RoactRodux.connect(
	function(state, props)
		if not state then return end
		return {
			Errors = state.Settings.Errors,
		}
	end
)(MenuBar)

return MenuBar]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9E5B7D4A73B44EED9B4EA424CBCE9454">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundTextBox</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A TextBox with rounded corners that allows single-line or multiline entry,
	maximum character count, and error messages.

	Props:
		bool Active = Whether this component can be interacted with.
		int MaxLength = The maximum number of characters allowed in the TextBox.
		bool Multiline = Whether this TextBox allows a single line of text or multiple.
		int Height = The vertical size of this TextBox, in pixels.
		int LayoutOrder = The sort order of this component in a UIListLayout.

		string ErrorMessage = A general override message used to display an error.
			A non-nil ErrorMessage will border the TextBox in red.

		string Text = The text to display in the TextBox
		function SetText(text) = Callback to tell parent that text has changed
]]

local DEFAULT_HEIGHT = 42
local PADDING = UDim.new(0, 10)

local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)
local Cryo = require(Plugin.Cryo)
local Constants = require(Plugin.Src.Util.Constants)
local withTheme = require(Plugin.Src.Consumers.withTheme)

local TextEntry = require(Plugin.Src.Components.TextEntry)
local MultilineTextEntry = require(Plugin.Src.Components.MultilineTextEntry)

local RoundTextBox = Roact.PureComponent:extend("RoundTextBox")

function RoundTextBox:init()
	self.state = {
		Focused = false,
	}
end

function RoundTextBox:focusChanged(focused)
	if self.props.Active then
		self:setState(Cryo.Dictionary.join(self.state, {
			Focused = focused,
		}))
	end
end

function RoundTextBox:render()
	return withTheme(function(theme)
		local active = self.props.Active
		local focused = self.state.Focused
		local multiline = self.props.Multiline
		local textLength = string.len(self.props.Text)
		local errorState = self.props.ErrorMessage
			or textLength > self.props.MaxLength

		local backgroundProps = {
			-- Necessary to make the rounded background
			BackgroundTransparency = 1,
			Image = Constants.ROUNDED_BACKGROUND_IMAGE,
			ImageTransparency = 0,
			ImageColor3 = active and theme.textBox.background or theme.textBox.disabled,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Constants.ROUNDED_FRAME_SLICE,

			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(1, 0, 0, self.props.Height or DEFAULT_HEIGHT),

			LayoutOrder = self.props.LayoutOrder or 1,
		}

		local tooltipText
		if active then
			if errorState and self.props.ErrorMessage then
				tooltipText = self.props.ErrorMessage
			else
				tooltipText = textLength .. "/" .. self.props.MaxLength
			end
		else
			tooltipText = ""
		end

		local borderColor
		if active then
			if errorState then
				borderColor = Constants.ERROR_COLOR
			elseif focused then
				borderColor = theme.textBox.borderHover
			else
				borderColor = theme.textBox.borderDefault
			end
		else
			borderColor = theme.textBox.borderDefault
		end

		local textEntryProps = {
			Visible = self.props.Active,
			Text = self.props.Text,
			FocusChanged = function(focused)
				self:focusChanged(focused)
			end,
			SetText = self.props.SetText,
			TextColor3 = theme.textBox.text,
		}

		local textEntry
		if multiline then
			textEntry = Roact.createElement(MultilineTextEntry, textEntryProps)
		else
			textEntry = Roact.createElement(TextEntry, textEntryProps)
		end

		return Roact.createElement("ImageLabel", backgroundProps, {
			Tooltip = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 2, 1, 2),
				Size = UDim2.new(1, 0, 0, 10),

				Font = Enum.Font.SourceSans,
				TextSize = 16,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextColor3 = (active and errorState and Constants.ERROR_COLOR) or theme.textBox.tooltip,
				Text = tooltipText,
			}),

			Border = Roact.createElement("ImageLabel", {
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				Image = Constants.ROUNDED_BORDER_IMAGE,
				ImageColor3 = borderColor,
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Constants.ROUNDED_FRAME_SLICE,
			}, {
				Padding = Roact.createElement("UIPadding", {
					PaddingLeft = PADDING,
					PaddingRight = PADDING,
					PaddingTop = PADDING,
					PaddingBottom = PADDING,
				}),
				Text = textEntry,
			}),
		})
	end)
end

return RoundTextBox
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8BDD5E3D11844976BF66415E7207FC69">
				<Properties>
					<string name="Name">Keys</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX70420A78059746B69412009A8BF4A6DC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">themeKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local themeKey = newproxy(true)

getmetatable(themeKey).__tostring = function()
	return "Symbol(Theme)"
end

return themeKey]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF2D3500B9398442482DBC0EC5646E1F9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">dialogKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local dialogKey = newproxy(true)

getmetatable(dialogKey).__tostring = function()
	return "Symbol(Dialog)"
end

return dialogKey]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX72815B9C413746C591022292E34382EA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">settingsImplKey</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local settingsImplKey = newproxy(true)

getmetatable(settingsImplKey).__tostring = function()
	return "Symbol(SettingsImpl)"
end

return settingsImplKey]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBX467AC9F1EBD4474D9A8AEDF1198AAB37">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">main</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[if not plugin then
	return
end

-- Fast flags
local FFlagStudioUseLuaGameSettingsDialog = settings():GetFFlag("StudioUseLuaGameSettingsDialog")
local FFlagStudioLuaGameSettingsDialog2 = settings():GetFFlag("StudioLuaGameSettingsDialog2")

if not FFlagStudioUseLuaGameSettingsDialog then
	return
end

--Turn this on when debugging the store and actions
local LOG_STORE_STATE_AND_EVENTS = false

local RunService = game:GetService("RunService")

local Plugin = script.Parent.Parent
local Roact = require(Plugin.Roact)
local Rodux = require(Plugin.Rodux)
local Cryo = require(Plugin.Cryo)
local Promise = require(Plugin.Promise)

local MainView = require(Plugin.Src.Components.MainView)
local SimpleDialog = require(Plugin.Src.Components.Dialog.SimpleDialog)
local MainReducer = require(Plugin.Src.Reducers.MainReducer)
local SettingsImpl = require(Plugin.Src.Networking.SettingsImpl)
local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)
local Theme = require(Plugin.Src.Util.Theme)

local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

local SetCurrentStatus = require(Plugin.Src.Actions.SetCurrentStatus)
local DiscardChanges = require(Plugin.Src.Actions.DiscardChanges)
local DiscardErrors = require(Plugin.Src.Actions.DiscardErrors)
local SetCurrentSettings = require(Plugin.Src.Actions.SetCurrentSettings)
local LoadAllSettings = require(Plugin.Src.Thunks.LoadAllSettings)

local isEmpty = require(Plugin.Src.Util.isEmpty)

local gameSettingsHandle
local pluginGui

local middlewares = {Rodux.thunkMiddleware}
if LOG_STORE_STATE_AND_EVENTS then
	table.insert(middlewares, Rodux.loggerMiddleware)
end

local settingsStore = Rodux.Store.new(MainReducer, nil, middlewares)

local settingsImpl = SettingsImpl.new(plugin:GetStudioUserId())

--Add all settings pages in order
local settingsPages
if FFlagStudioLuaGameSettingsDialog2 then
	settingsPages = {
		"Basic Info",
		"Avatar",
		"Options",
	}
else
	settingsPages = {
		"Avatar",
		"Options",
	}
end

local function showDialog(type, props)
	return Promise.new(function(resolve, reject)
		spawn(function()
			local dialogHandle
			local dialog = plugin:CreateQWidgetPluginGui(props.Title, {
				Size = props.Size or Vector2.new(473, 197),
				InitialEnabled = true,
				Modal = true,
			})
			dialog.Title = props.Title
			local dialogContents = Roact.createElement(ThemeProvider, {
				theme = FFlagStudioLuaGameSettingsDialog2 and Theme.new() or Theme.DEPRECATED_constantColors(),
			}, {
				Content = Roact.createElement(type, Cryo.Dictionary.join(props, {
					OnResult = function(result)
						Roact.unmount(dialogHandle)
						dialog:Destroy()
						if result then
							resolve()
						else
							reject()
						end
					end
				})),
			})
			dialog:GetPropertyChangedSignal("Enabled"):connect(function()
				Roact.unmount(dialogHandle)
				dialog:Destroy()
				reject()
			end)
			dialogHandle = Roact.mount(dialogContents, dialog)
		end)
	end)
end

--Closes and unmounts the Game Settings popup window
local function closeGameSettings(userPressedSave)
	local state = settingsStore:getState()
	local currentStatus = state.Status
	if not (currentStatus == CurrentStatus.Error and userPressedSave) then
		local changed = state.Settings.Changed
		local hasUnsavedChanges = changed and not isEmpty(changed)
		if hasUnsavedChanges and not userPressedSave then
			--Prompt if the user actually wanted to save using a Modal
			settingsStore:dispatch(SetCurrentStatus(CurrentStatus.Closed))

			local dialogProps = {
				Size = Vector2.new(343, 145),
				Title = "Discard Changes",
				Header = "Would you like to discard all changes?",
				Buttons = {"No", "Yes"},
			}
			local didDiscardAllChanges = showDialog(SimpleDialog, dialogProps):await()

			if didDiscardAllChanges then
				--Exit game settings and delete all changes without saving
				settingsStore:dispatch(DiscardChanges())
				pluginGui.Enabled = false
				Roact.unmount(gameSettingsHandle)
			else
				--Return to game settings window without modifying state,
				--giving the user another chance to modify or save.
				settingsStore:dispatch(SetCurrentStatus(CurrentStatus.Open))
				if not pluginGui.Enabled then
					pluginGui.Enabled = true
				end
				return
			end
		else
			if not userPressedSave then
				settingsStore:dispatch(SetCurrentStatus(CurrentStatus.Closed))
			end
			pluginGui.Enabled = false
			Roact.unmount(gameSettingsHandle)
		end
	else
		settingsStore:dispatch(SetCurrentStatus(CurrentStatus.Open))
	end
end

local function makePluginGui()
	pluginGui = plugin:CreateQWidgetPluginGui("Game Settings", {
		Size = Vector2.new(960, 600),
		MinSize = Vector2.new(960, 600),
		Resizable = true,
		Modal = true,
		InitialEnabled = false,
	})
	pluginGui.Name = plugin.Name
	pluginGui.Title = plugin.Name
	pluginGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	pluginGui:GetPropertyChangedSignal("Enabled"):connect(function()
		-- Handle if user clicked the X button to close the window
		if not pluginGui.Enabled then
			local state = settingsStore:getState()
			local currentStatus = state.Status
			if currentStatus == CurrentStatus.Open then
				closeGameSettings(false)
			end
		end
	end)
end

--Initializes and populates the Game Settings popup window
local function openGameSettings()
	if settingsStore then
		local state = settingsStore:getState()
		local currentStatus = state.Status
		if currentStatus ~= CurrentStatus.Closed then
			return
		end
	end

	local menuEntries = {}
	for i, entry in ipairs(settingsPages) do
		menuEntries[i] = {
			Name = entry,
		}
	end

	local servicesProvider = Roact.createElement(ExternalServicesWrapper, {
		impl = settingsImpl,
		store = settingsStore,
		showDialog = showDialog,
		theme = FFlagStudioLuaGameSettingsDialog2 and Theme.new() or Theme.DEPRECATED_constantColors(),
	}, {
		mainView = Roact.createElement(MainView, {
			MenuEntries = menuEntries,
			OnClose = closeGameSettings,
		}),
	})

	settingsStore:dispatch(SetCurrentSettings({}))
	settingsStore:dispatch(DiscardChanges())
	settingsStore:dispatch(DiscardErrors())
	settingsStore:dispatch(LoadAllSettings(settingsImpl))

	gameSettingsHandle = Roact.mount(servicesProvider, pluginGui)
	pluginGui.Enabled = true
end

--Binds a toolbar button to the Game Settings window
local function main()
	plugin.Name = "Game Settings"

	local toolbar = plugin:CreateToolbar("gameSettingsToolbar")
	local settingsButton = toolbar:CreateButton(
		"gameSettingsButton",
		"Update settings related to current game",
		"rbxasset://textures/GameSettings/ToolbarIcon.png"
	)

	-- Don't want to be able to open game settings while the game is running
	-- it is for edit mode only!
	if RunService:IsEdit() then
		makePluginGui()
		settingsButton.Enabled = true
		settingsButton.Click:connect(function()
			openGameSettings()
		end)
		settingsStore.changed:connect(function(state)
			settingsButton:SetActive(state.Status ~= CurrentStatus.Closed)
		end)
	else
		settingsButton.Enabled = false
	end
end

main()]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX352A0AB732D14038909098CC646E83BC">
				<Properties>
					<string name="Name">Consumers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF5FF17B3216C4AFBBB47DABE16DA11AE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">showDialog</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Gets the showDialog function passed from context.

local Plugin = script.Parent.Parent.Parent

local dialogKey = require(Plugin.Src.Keys.dialogKey)

return function(component, ...)
	return component._context[dialogKey](...)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD93DCB2FC3C7484196536344D5160213">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">withTheme</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Roact = require(Plugin.Roact)

local ThemeConsumer = require(Plugin.Src.Consumers.ThemeConsumer)

return function(callback)
	return Roact.createElement(ThemeConsumer, {
		render = callback,
	})
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC778F7C764D0414993EE3F6C9979A9D6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getSettingsImpl</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--Gets this component's currently attached SettingsImpl.

local Plugin = script.Parent.Parent.Parent

local settingsImplKey = require(Plugin.Src.Keys.settingsImplKey)

return function(component)
	return component._context[settingsImplKey]
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC07DFD5337834129AD66E802C4A4CDC7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ThemeConsumer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Roact = require(Plugin.Roact)

local themeKey = require(Plugin.Src.Keys.themeKey)

local ThemeConsumer = Roact.Component:extend("ThemeConsumer")

function ThemeConsumer:init()
	local theme = self._context[themeKey]

	self.theme = theme
	self.state = {
		themeValues = theme.values,
	}
end

function ThemeConsumer:render()
	return self.props.render(self.state.themeValues)
end

function ThemeConsumer:didMount()
	self.disconnectThemeListener = self.theme:subscribe(function(newValues)
		self:setState({
			themeValues = newValues,
		})
	end)
end

function ThemeConsumer:willUnmount()
	self.disconnectThemeListener()
end

return ThemeConsumer]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXC18EEA3F197140A597B0A5F419D669E2">
				<Properties>
					<string name="Name">Reducers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8F07516A0BD6432D945C022D602F3367">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Status</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Reducer for the current status of the application.
	Stores a CurrentStatus defining what the current status of the app is.
]]

local Plugin = script.Parent.Parent.Parent

local SetCurrentStatus = require(Plugin.Src.Actions.SetCurrentStatus)
local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

local function Status(state, action)
	state = state or CurrentStatus.Closed

	if action.type == SetCurrentStatus.name then
		return action.currentStatus
	end

	return state
end

return Status]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1C11006C074C41D88AA715E6A9D8AB00">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Settings</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Main reducer for all settings values.
	Saves a table of current settings and local changes.

	Changes are finally saved when the SaveChanges thunk is dispatched.
	Alternatively, they can be reset if DiscardChanges is dispatched.

	The state table:
		- Contains all settings and values under the Current key, loaded from a Settings Interface.
		- Contains a table under the Changed key, which keeps track of all changed settings.

	When saving changes, only settings in the Changed table are saved.
	When discarding changes, the Changed table is deleted.
]]

local Plugin = script.Parent.Parent.Parent
local Cryo = require(Plugin.Cryo)

local AddChange = require(Plugin.Src.Actions.AddChange)
local AddErrors = require(Plugin.Src.Actions.AddErrors)
local SetCurrentSettings = require(Plugin.Src.Actions.SetCurrentSettings)
local DiscardChanges = require(Plugin.Src.Actions.DiscardChanges)
local DiscardErrors = require(Plugin.Src.Actions.DiscardErrors)

local function Settings(state, action)
	state = state or {
		Current = {},
		Changed = {},
		Errors = {},
	}

	if action.type == AddChange.name then
		local newValue = action.value
		if state.Current[action.setting] == newValue then
			newValue = Cryo.None
		elseif type(newValue) == "table" then
			local equal = true
			for key, value in pairs(state.Current[action.setting]) do
				if newValue[key] ~= value then
					equal = false
					break
				end
			end
			if equal then
				newValue = Cryo.None
			end
		end

		return Cryo.Dictionary.join(state, {
			Changed = Cryo.Dictionary.join(state.Changed, {
				[action.setting] = newValue,
			}),
			Errors = Cryo.Dictionary.join(state.Errors, {
				[action.setting] = Cryo.None,
			}),
		})

	elseif action.type == AddErrors.name then
		return Cryo.Dictionary.join(state, {
			Errors = Cryo.Dictionary.join(state.Errors, action.errors)
		})

	elseif action.type == DiscardChanges.name then
		return Cryo.Dictionary.join(state, {
			Changed = {},
		})

	elseif action.type == DiscardErrors.name then
		return Cryo.Dictionary.join(state, {
			Errors = {},
		})

	elseif action.type == SetCurrentSettings.name then
		return Cryo.Dictionary.join(state, {
			Current = action.settings,
		})
	end

	return state
end

return Settings]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC7ECC8B4988442DF92582BAB210E2DE6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MainReducer</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Reducer that combines the Settings and Status reducers.
]]

local Plugin = script.Parent.Parent.Parent
local Rodux = require(Plugin.Rodux)

local Settings = require(Plugin.Src.Reducers.Settings)
local Status = require(Plugin.Src.Reducers.Status)

return Rodux.combineReducers({
	Settings = Settings,
	Status = Status,
})]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX878F062E5DF54AE3AF29F0C54665EFF7">
				<Properties>
					<string name="Name">Providers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF52838EFD0EA42048AD5A33D1A93E754">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ThemeProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent

local Roact = require(Plugin.Roact)

local themeKey = require(Plugin.Src.Keys.themeKey)

local ThemeProvider = Roact.Component:extend("ThemeProvider")

function ThemeProvider:init()
	self._context[themeKey] = self.props.theme
end

function ThemeProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

function ThemeProvider:willUnmount()
	self._context[themeKey]:destroy()
end

return ThemeProvider]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX31E8957001084059B3A672AD69088143">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DialogProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)

local dialogKey = require(Plugin.Src.Keys.dialogKey)

local DialogProvider = Roact.Component:extend("DialogProvider")

function DialogProvider:init(props)
	local showDialog = props.showDialog

	if showDialog == nil then
		showDialog = function()
			error("No showDialog function was provided.")
		end
	end

	self._context[dialogKey] = showDialog
end

function DialogProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return DialogProvider]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX553891ADD36046AB91D035C1E23517DC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsImplProvider</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local Plugin = script.Parent.Parent.Parent
local Roact = require(Plugin.Roact)

local settingsImplKey = require(Plugin.Src.Keys.settingsImplKey)

local SettingsImplProvider = Roact.Component:extend("SettingsImplProvider")

function SettingsImplProvider:init(props)
	local impl = props.impl

	if impl == nil then
		error("Error initializing SettingsImplProvider. Expected an `impl` prop.")
	end

	self._context[settingsImplKey] = impl
end

function SettingsImplProvider:render()
	return Roact.oneChild(self.props[Roact.Children])
end

return SettingsImplProvider]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXE3DF5E72656349A3A5B750902D469506">
				<Properties>
					<string name="Name">Networking</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX30A4BBEC677B40CB8456F40422734F76">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsImpl_mock</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Mock interface for changing ingame settings.
	Used for testing. Doesn't do anything beyond that.
]]

local Plugin = script.Parent.Parent.Parent
local Promise = require(Plugin.Promise)

local SettingsImpl_mock = {}

SettingsImpl_mock.__index = SettingsImpl_mock

function SettingsImpl_mock.new()
	local self = setmetatable({}, SettingsImpl_mock)
	return self
end

function SettingsImpl_mock:GetUserId()
	return 0
end

function SettingsImpl_mock:GetSettings()
	return Promise.resolve({})
end

function SettingsImpl_mock:SaveAll()
	return Promise.resolve()
end

return SettingsImpl_mock]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3F417F3B7D8344C893960BA02C2AE3CB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Http</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local HttpRbxApiService = game:GetService("HttpRbxApiService")
local ContentProvider = game:GetService("ContentProvider")

local Plugin = script.Parent.Parent.Parent
local Promise = require(Plugin.Promise)

local BASE_URL = ContentProvider.BaseUrl
if BASE_URL:find("https://www.") then
	BASE_URL = BASE_URL:sub(13)
elseif BASE_URL:find("http://www.") then
	BASE_URL = BASE_URL:sub(12)
end

local Http = {}

function Http.BuildRobloxUrl(front, back, ...)
	return "https://" .. front .. "." .. BASE_URL .. (string.format(back, ...) or "")
end

function Http.Request(requestInfo)
	return Promise.new(function(resolve, reject)
		-- Prevent yielding
		spawn(function()
			local ok, result = pcall(HttpRbxApiService.RequestAsync,
				HttpRbxApiService, requestInfo)

			if ok then
				resolve(result)
			else
				reject(result)
			end
		end)
	end)
end

return Http]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX446B28BAFB3B4BFDA675D2C04A09CB33">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">settingFromState</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Gets the user set setting from the current state.
	If the setting was queued for change by the user and not saved,
	this function will return the queued change. This allows the
	app to display what will happen when the user presses the save button.
]]

return function(settings, setting)
	if settings.Changed[setting] ~= nil then
		return settings.Changed[setting]
	else
		return settings.Current[setting]
	end
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX851ED1BE26F748ACA94B2E47F3B4A695">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsImpl</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	Interface for changing ingame settings.

	Flow:
		SettingsImpl can be provided via a SettingsImplProvider, then
		used as an Interface by the SaveChanges and LoadAllSettings thunks
		to save and load settings. Other implementations, such as
		SettingsImpl_mock, can be provided to allow testing.
]]

local CAN_MANAGE_URL = "users/%d/canmanage/%d"
local CAN_MANAGE_TYPE = "api"

local CONFIGURATION_REQUEST_URL = "v1/universes/%d/configuration"
local CONFIGURATION_REQUEST_TYPE = "develop"

local UNIVERSES_REQUEST_URL = "v1/universes/%d"
local UNIVERSES_REQUEST_TYPE = "develop"

local ACTIVATE_REQUEST_URL = "v1/universes/%d/activate"
local ACTIVATE_REQUEST_TYPE = "develop"

local DEACTIVATE_REQUEST_URL = "v1/universes/%d/deactivate"
local DEACTIVATE_REQUEST_TYPE = "develop"

local PLACES_GET_URL = "v1/universes/%d/places"
local PLACES_GET_REQUEST_TYPE = "develop"

local PLACES_PATCH_URL = "v1/places/%d"
local PLACES_PATCH_REQUEST_TYPE = "develop"

local PLAYABLE_DEVICES = {
	Computer = false,
	Phone = false,
	Tablet = false,
	Console = false,
}

local fromUniverseConfigurationEndpoint = {
	universeAvatarType = true,
	universeScaleType = true,
	universeAnimationType = true,
	universeCollisionType = true,
	playableDevices = true,
	isFriendsOnly = true,
	name = true,
}

local fromUniversesEndpoint = {
	isActive = true,
}

local fromRootPlaceInfoEndpoint = {
	description = true,
}

local HttpService = game:GetService("HttpService")

local Plugin = script.Parent.Parent.Parent
local Promise = require(Plugin.Promise)
local Cryo = require(Plugin.Cryo)
local Http = require(Plugin.Src.Networking.Http)
local isEmpty = require(Plugin.Src.Util.isEmpty)

local SettingsImpl = {}
SettingsImpl.__index = SettingsImpl

local function extractRelevantEntries(body, fromEndpointList)
	local loadedSettings = {}
	for entry, _ in pairs(fromEndpointList) do
		loadedSettings[entry] = body[entry]
	end
	return loadedSettings
end

function SettingsImpl.new(userId)
	local self = setmetatable({}, SettingsImpl)
	self.userId = userId
	self.canManage = false
	return self
end

function SettingsImpl:GetUserId()
	return self.userId
end

function SettingsImpl:CanManagePlace()
	local requestInfo = {
		Url = Http.BuildRobloxUrl(CAN_MANAGE_TYPE, CAN_MANAGE_URL, self.userId, game.PlaceId),
		Method = "GET",
	}

	return Http.Request(requestInfo):andThen(function(jsonResult)
		local result = HttpService:JSONDecode(jsonResult)
		return result.CanManage or false
	end)
	:catch(function()
		warn("Game Settings: Could not determine if the current Studio user can manage game settings.")
		return Promise.resolve(false)
	end)
end

--[[
	Used to get the state of the game settings by downloading them from web
	endpoints or reading their properties from the datamodel.
]]
function SettingsImpl:GetSettings()
	local settings = {
		HttpEnabled = HttpService:GetHttpEnabled()
	}

	return self:CanManagePlace():andThen(function(canManage)
		self.canManage = canManage

		return Promise.all({
			self:GetUniverseConfiguration(),
			self:GetRootPlaceInfo(),
			self:GetUniversesInfo(),
		})
		:andThen(function(loaded)
			for _, values in ipairs(loaded) do
				settings = Cryo.Dictionary.join(settings, values)
			end
			return settings
		end)
	end)
end

--[[
	Used to save the chosen state of all game settings by saving to web
	endpoints or setting properties in the datamodel.
]]
function SettingsImpl:SaveAll(state)
	if state.Changed.HttpEnabled ~= nil then
		HttpService:SetHttpEnabled(state.Changed.HttpEnabled)
	end

	return self:CanManagePlace():andThen(function(canManage)
		self.canManage = canManage

		local universeConfigValues = {}
		local rootPlaceInfoValues = {}
		local isActive = nil

		for setting, value in pairs(state.Changed) do
			if fromUniverseConfigurationEndpoint[setting] then
				universeConfigValues[setting] = value
			elseif fromRootPlaceInfoEndpoint[setting] then
				rootPlaceInfoValues[setting] = value
			elseif setting == "isActive" then
				isActive = value
			end
		end

		return Promise.all({
			self:SetUniverseConfiguration(universeConfigValues),
			self:SetRootPlaceInfo(rootPlaceInfoValues),
			self:SetUniverseActive(isActive),
		})
	end)
end

--[[
	Specific implementations for individual settings endpoints.
	Because some settings use the same endpoint, we want to be able to save
	and load entire categories at the same time, based on the endpoints.
	Get functions should return a table mapping settings names to values.
]]

-- Avatar, description, and name settings
function SettingsImpl:GetUniverseConfiguration()
	if not self.canManage then
		return Promise.resolve({})
	end

	local universeId = game.GameId

	local requestInfo = {
		Url = Http.BuildRobloxUrl(CONFIGURATION_REQUEST_TYPE, CONFIGURATION_REQUEST_URL, universeId),
		Method = "GET",
	}

	return Http.Request(requestInfo):andThen(function(jsonResult)
		local result = HttpService:JSONDecode(jsonResult)
		local values = extractRelevantEntries(result, fromUniverseConfigurationEndpoint)
		if values.playableDevices then
			local toDict = Cryo.Dictionary.join(PLAYABLE_DEVICES, {})
			for _, key in pairs(values.playableDevices) do
				toDict[key] = true
			end
			values.playableDevices = toDict
		end
		return values
	end)
	:catch(function()
		warn("Game Settings: Could not load settings from universe configuration.")
		return Promise.resolve({})
	end)
end

function SettingsImpl:SetUniverseConfiguration(body)
	if not self.canManage or isEmpty(body) then
		return Promise.resolve()
	end

	local universeId = game.GameId

	if body.playableDevices then
		local toTable = {}
		for key, value in pairs(body.playableDevices) do
			if value then
				table.insert(toTable, key)
			end
		end
		body.playableDevices = toTable
	end

	local requestInfo = {
		Url = Http.BuildRobloxUrl(CONFIGURATION_REQUEST_TYPE, CONFIGURATION_REQUEST_URL, universeId),
		Method = "PATCH",
		Body = HttpService:JSONEncode(body),
	}

	return Http.Request(requestInfo)
	:catch(function(err)
		warn("Game Settings: Could not save universe configuration settings.")
		if string.find(err, "HTTP 400") then
			local errors = {}
			if body.name then
				errors.name = "Moderated"
			end
			return Promise.reject(errors)
		else
			return Promise.resolve()
		end
	end)
end

-- Starting place info (description)
function SettingsImpl:GetRootPlaceInfo()
	if not self.canManage then
		return Promise.resolve({})
	end

	local universeId = game.GameId

	local requestInfo = {
		Url = Http.BuildRobloxUrl(UNIVERSES_REQUEST_TYPE, UNIVERSES_REQUEST_URL, universeId),
		Method = "GET",
	}

	return Http.Request(requestInfo):andThen(function(jsonResult)
		local result = HttpService:JSONDecode(jsonResult)
		local rootPlaceId = result.rootPlaceId

		local placesRequestInfo = {
			Url = Http.BuildRobloxUrl(PLACES_GET_REQUEST_TYPE, PLACES_GET_URL, universeId),
			Method = "GET",
		}

		return Http.Request(placesRequestInfo):andThen(function(placesJsonResult)
			local placesResult = HttpService:JSONDecode(placesJsonResult)

			for _, place in ipairs(placesResult.data) do
				if place.id == rootPlaceId then
					return extractRelevantEntries(place, fromRootPlaceInfoEndpoint)
				end
			end
		end)
	end)
end

function SettingsImpl:SetRootPlaceInfo(body)
	if not self.canManage or isEmpty(body) then
		return Promise.resolve()
	end

	local universeId = game.GameId

	local requestInfo = {
		Url = Http.BuildRobloxUrl(UNIVERSES_REQUEST_TYPE, UNIVERSES_REQUEST_URL, universeId),
		Method = "GET",
	}

	return Http.Request(requestInfo):andThen(function(jsonResult)
		local result = HttpService:JSONDecode(jsonResult)
		local rootPlaceId = result.rootPlaceId

		local placeRequestInfo = {
			Url = Http.BuildRobloxUrl(PLACES_PATCH_REQUEST_TYPE, PLACES_PATCH_URL, rootPlaceId),
			Method = "PATCH",
			Body = HttpService:JSONEncode(body),
		}

		return Http.Request(placeRequestInfo)
	end)
	:catch(function(err)
		warn("Game Settings: Could not save root place configuration settings.")
		if string.find(err, "HTTP 400") then
			local errors = {}
			if body.description then
				errors.description = "Moderated"
			end
			return Promise.reject(errors)
		else
			return Promise.resolve()
		end
	end)
end

-- Place activation settings
function SettingsImpl:GetUniversesInfo()
	if not self.canManage then
		return Promise.resolve({})
	end

	local universeId = game.GameId

	local requestInfo = {
		Url = Http.BuildRobloxUrl(UNIVERSES_REQUEST_TYPE, UNIVERSES_REQUEST_URL, universeId),
		Method = "GET",
	}

	return Http.Request(requestInfo):andThen(function(jsonResult)
		local result = HttpService:JSONDecode(jsonResult)
		return extractRelevantEntries(result, fromUniversesEndpoint)
	end)
	:catch(function()
		warn("Game Settings: Could not load settings from universes.")
		return Promise.resolve({})
	end)
end

function SettingsImpl:SetUniverseActive(isActive)
	if not self.canManage or isActive == nil then
		return Promise.resolve()
	end

	local universeId = game.GameId

	local requestInfo = {
		Method = "POST",
	}

	if isActive then
		requestInfo.Url = Http.BuildRobloxUrl(ACTIVATE_REQUEST_TYPE, ACTIVATE_REQUEST_URL, universeId)
	else
		requestInfo.Url = Http.BuildRobloxUrl(DEACTIVATE_REQUEST_TYPE, DEACTIVATE_REQUEST_URL, universeId)
	end

	return Http.Request(requestInfo)
	:catch(function()
		warn("Game Settings: Could not change universe Active status.")
		return Promise.resolve()
	end)
end

return SettingsImpl]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX5E070D81841F48B994E2E469A63F1B39">
				<Properties>
					<string name="Name">Actions</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX700C5704AE4C4F7FB72588665012E5A9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Action</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	A helper function to define a Rodux action creator with an associated name.

	Normally when creating a Rodux action, you can just create a function:

		return function(value)
			return {
				type = "MyAction",
				value = value,
			}
		end

	And then when you check for it in your reducer, you either use a constant,
	or type out the string name:

		if action.type == "MyAction" then
			-- change some state
		end

	Typos here are a remarkably common bug. We also have the issue that there's
	no link between reducers and the actions that they respond to!

	`Action` (this helper) provides a utility that makes this a bit cleaner.

	Instead, define your Rodux action like this:

		return Action("MyAction", function(value)
			return {
				value = value,
			}
		end)

	We no longer need to add the `type` field manually.

	Additionally, the returned action creator now has a 'name' property that can
	be checked by your reducer:

		local MyAction = require(Reducers.MyAction)

		...

		if action.type == MyAction.name then
			-- change some state!
		end

	Now we have a clear link between our reducers and the actions they use, and
	if we ever typo a name, we'll get a warning in LuaCheck as well as an error
	at runtime!
]]

return function(name, fn)
	assert(type(name) == "string", "A name must be provided to create an Action")
	assert(type(fn) == "function", "A function must be provided to create an Action")

	return setmetatable({
		name = name,
	}, {
		__call = function(self, ...)
			local result = fn(...)

			assert(type(result) == "table", "An action must return a table")

			result.type = name

			return result
		end
	})
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC36EFC6F4B3E43E585E6881820227A3C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DiscardChanges</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Discards all user-made changes to settings.

local Plugin = script.Parent.Parent.Parent
local Action = require(Plugin.Src.Actions.Action)

return Action(script.Name, function()
	return {}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC32BE8D1E93747D3B41432CAC6BC971E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SetCurrentStatus</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Sets if the Game Settings window is currently open or working (saving or loading).

local Plugin = script.Parent.Parent.Parent
local Action = require(Plugin.Src.Actions.Action)

return Action(script.Name, function(currentStatus)
	return {
		currentStatus = currentStatus,
	}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3D069EB5F2DA4CC69648A05A74BD7815">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AddChange</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Adds a value to the Settings Changed table.

local Plugin = script.Parent.Parent.Parent
local Action = require(Plugin.Src.Actions.Action)

return Action(script.Name, function(setting, value)
	return {
		setting = setting,
		value = value,
	}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5F582E3CEB964125A283C63D220A51B0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AddErrors</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Adds a value to the Settings Error table.

local Plugin = script.Parent.Parent.Parent
local Action = require(Plugin.Src.Actions.Action)

return Action(script.Name, function(errors)
	return {
		errors = errors,
	}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD0E38B3D5FF546F3929E4FA6DD7FFC66">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SetCurrentSettings</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Sets all store settings to their loaded values.

local Plugin = script.Parent.Parent.Parent
local Action = require(Plugin.Src.Actions.Action)

return Action(script.Name, function(settings)
	return {
		settings = settings,
	}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX980F8FAB66204133A411AA15A6DB2664">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DiscardErrors</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[-- Discards all errors in Settings.

local Plugin = script.Parent.Parent.Parent
local Action = require(Plugin.Src.Actions.Action)

return Action(script.Name, function()
	return {}
end)]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX5AD4EE71C407449F87BDAD885EE85417">
			<Properties>
				<string name="Name">Tests</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX6545A15550294F93A0FB58CDC8A4D594">
				<Properties>
					<string name="Name">Components</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX508321BAFC8F45E48948792278AFB9D7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MultilineTextEntry.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local MultilineTextEntry = require(Plugin.Src.Components.MultilineTextEntry)

	local theme = Theme.newDummyTheme()

	local function createTestMultilineTextEntry(visible)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			textEntry = Roact.createElement(MultilineTextEntry, {
				Text = "Text",
				Visible = visible,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestMultilineTextEntry(true)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestMultilineTextEntry(true), container)
		local frame = container.Frame

		expect(frame.ScrollingFrame).to.be.ok()
		expect(frame.ScrollingFrame).to.be.ok()
		expect(frame.ScrollingFrame.Padding).to.be.ok()
		expect(frame.ScrollingFrame.Text).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should hide its text when not visible", function ()
		local container = workspace
		local instance = Roact.mount(createTestMultilineTextEntry(false), container)
		local frame = container.Frame

		expect(frame.ScrollingFrame.Text.Visible).to.equal(false)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA1E0E6F0046C4ED8B03E819474E4417A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RadioButton.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local RadioButton = require(Plugin.Src.Components.RadioButton)
	local theme = Theme.newDummyTheme()

	local function createTestRadioButton(enabled, selected)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			radioButton = Roact.createElement(RadioButton, {
				Title = "Title",
				Enabled = enabled,
				Description = "",
				Selected = selected,
				OnClicked = function()
				end,
			})
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestRadioButton(true, false)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestRadioButton(true, false), container)
		local button = container.Frame

		expect(button.Button).to.be.ok()
		expect(button.Button.Highlight).to.be.ok()
		expect(button.Button.TitleLabel).to.be.ok()
		expect(button.Button.DescriptionLabel).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should change color when highlighted", function ()
		local container = workspace
		local instance = Roact.mount(createTestRadioButton(true, true), container)
		local frame = container.Frame

		expect(frame.Button.Highlight.Visible).to.equal(true)

		local newButton = createTestRadioButton(true, false)
		instance = Roact.reconcile(instance, newButton)

		expect(frame.Button.Highlight.Visible).to.equal(false)

		Roact.unmount(instance)
	end)

	it("should gray out when disabled", function ()
		local container = workspace
		local instance = Roact.mount(createTestRadioButton(false, true), container)
		local button = container.Frame

		expect(button.Button.Highlight.Visible).to.equal(false)
		expect(button.Button.TitleLabel.TextTransparency).never.to.equal(0)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX63DEBBDD691B405EA615A53DBC599204">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RadioButtonSet.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local RadioButtonSet = require(Plugin.Src.Components.RadioButtonSet)

	local theme = Theme.newDummyTheme()

	local function createTestRadioButtonSet(buttons, enabled, selected)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			buttonSet = Roact.createElement(RadioButtonSet, {
				Title = "Title",
				Enabled = enabled,
				SelectionChanged = function()
				end,
				Buttons = buttons,
				Selected = selected,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestRadioButtonSet({}, true)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestRadioButtonSet({
			{Title = "Button", Description = ""},
		}, true), container)
		local buttonSet = container.Frame

		expect(buttonSet.Title).to.be.ok()
		expect(buttonSet.Content).to.be.ok()
		expect(buttonSet.Content.Layout).to.be.ok()
		expect(buttonSet.Content["1"]).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should highlight one button", function()
		local container = workspace
		local instance = Roact.mount(createTestRadioButtonSet({
			{Title = "Button1", Description = ""},
			{Title = "Button2", Description = ""},
		}, true), container)
		local buttonSet = container.Frame

		expect(buttonSet.Content["1"].Button.Highlight.Visible).to.equal(true)
		expect(buttonSet.Content["2"].Button.Highlight.Visible).to.equal(false)

		Roact.unmount(instance)
	end)

	it("should work with boolean IDs", function()
		local container = workspace
		local instance = Roact.mount(createTestRadioButtonSet({
			{Id = true, Title = "Button1", Description = ""},
			{Id = false, Title = "Button2", Description = ""},
		}, true, false), container)
		local buttonSet = container.Frame

		expect(buttonSet.Content["1"].Button.Highlight.Visible).to.equal(false)
		expect(buttonSet.Content["2"].Button.Highlight.Visible).to.equal(true)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBB9AC5A22D254EEDAD09D3E0A962D991">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CheckBox.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local CheckBox = require(Plugin.Src.Components.CheckBox)
	local theme = Theme.newDummyTheme()

	local function createTestCheckBox(enabled, selected)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			checkBox = Roact.createElement(CheckBox, {
				Title = "Title",
				Enabled = enabled,
				Selected = selected,
				OnClicked = function()
				end,
			})
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestCheckBox(true, false)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestCheckBox(true, false), container)
		local frame = container.Frame

		expect(frame.Background).to.be.ok()
		expect(frame.Background.Selection).to.be.ok()
		expect(frame.Background.TitleLabel).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should change color when highlighted", function ()
		local container = workspace
		local instance = Roact.mount(createTestCheckBox(true, true), container)
		local frame = container.Frame

		expect(frame.Background.Selection.Visible).to.equal(true)

		local newBox = createTestCheckBox(true, false)
		instance = Roact.reconcile(instance, newBox)

		expect(frame.Background.Selection.Visible).to.equal(false)

		Roact.unmount(instance)
	end)

	it("should gray out when disabled", function ()
		local container = workspace
		local instance = Roact.mount(createTestCheckBox(false, true), container)
		local frame = container.Frame

		expect(frame.Background.Selection.Visible).to.equal(false)
		expect(frame.Background.TitleLabel.TextTransparency).never.to.equal(0)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX318A372674834C0FAE0F52CB0D9F6521">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Header.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local Header = require(Plugin.Src.Components.Header)

	local theme = Theme.newDummyTheme()

	it("should create and destroy without errors", function()
		local element = Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			header = Roact.createElement(Header),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0BC302104C4E4D6283779549755C99A7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MenuBar.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	local MenuBar = require(Plugin.Src.Components.MenuBar)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.newDummyTheme()

	local function createTestMenuBar(entries, startState)
		local settingsStore = Rodux.Store.new(
			MainReducer,
			{Settings = startState},
			{Rodux.thunkMiddleware}
		)

		return Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			menuBar = Roact.createElement(MenuBar, {
				Entries = entries,
				SelectionChanged = function()
				end,
			})
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestMenuBar({})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestMenuBar({}), container)
		local menuBar = container.Frame

		expect(menuBar.Layout).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should render its MenuEntries", function()
		local container = workspace
		local instance = Roact.mount(createTestMenuBar({
			{Name = "Entry1"},
			{Name = "Entry2"},
			{Name = "Entry3"},
		}), container)
		local menuBar = container.Frame

		expect(menuBar.Layout).to.be.ok()
		expect(menuBar["1"]).to.be.ok()
		expect(menuBar["2"]).to.be.ok()
		expect(menuBar["3"]).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should tell MenuEntries with errors to highlight", function()
		local container = workspace
		local instance = Roact.mount(createTestMenuBar({
			{Name = "Basic Info"},
			{Name = "Entry2"},
		}, {
			Current = {},
			Changed = {},
			Errors = {
				name = "Filtered",
			}
		}), container)
		local menuBar = container.Frame

		expect(menuBar["1"].Error.Visible).to.equal(true)
		expect(menuBar["2"].Error.Visible).to.equal(false)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX957610E79BCF47378D8579CA5F34BF32">
					<Properties>
						<string name="Name">Dialog</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE2B5BA0CC7B24A1C8AA78EB530534FE5">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">WarningDialog.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local WarningDialog = require(Plugin.Src.Components.Dialog.WarningDialog)

	local theme = Theme.newDummyTheme()

	local function createTestWarningDialog()
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			dialog = Roact.createElement(WarningDialog, {
				Header = "Header",
				Description = "Description",
				Buttons = {"No", "Yes"},
				OnResult = function()
				end,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local instance = Roact.mount(createTestWarningDialog())
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestWarningDialog(), container)
		local dialog = container.Frame

		expect(dialog.Header).to.be.ok()
		expect(dialog.Description).to.be.ok()
		expect(dialog.Warning).to.be.ok()
		expect(dialog.Buttons).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4599753A7C7946069A54D4686636C236">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ListDialog.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local ListDialog = require(Plugin.Src.Components.Dialog.ListDialog)

	local theme = Theme.newDummyTheme()

	local function createTestListDialog()
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			dialog = Roact.createElement(ListDialog, {
				Header = "Header",
				Entries = {"Description"},
				Buttons = {"No", "Yes"},
				OnResult = function()
				end,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local instance = Roact.mount(createTestListDialog())
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestListDialog(), container)
		local dialog = container.Frame

		expect(dialog.Header).to.be.ok()
		expect(dialog.Entries).to.be.ok()
		expect(dialog.Entries["1"]).to.be.ok()
		expect(dialog.Entries["1"].Text).to.be.ok()
		expect(dialog.Entries["1"].Dot).to.be.ok()
		expect(dialog.Buttons).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX219B8152094F4914945953794A740DF3">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseDialog.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local BaseDialog = require(Plugin.Src.Components.Dialog.BaseDialog)

	local theme = Theme.newDummyTheme()

	local function createTestBaseDialog()
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			dialog = Roact.createElement(BaseDialog, {
				Buttons = {"No", "Yes"},
				Children = {},
				OnResult = function()
				end,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local instance = Roact.mount(createTestBaseDialog())
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestBaseDialog(), container)
		local dialog = container.Frame

		expect(dialog.Buttons).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX405B1C7621174706BE49AC709E036A20">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SimpleDialog.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local SimpleDialog = require(Plugin.Src.Components.Dialog.SimpleDialog)

	local theme = Theme.newDummyTheme()

	local function createTestSimpleDialog()
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			dialog = Roact.createElement(SimpleDialog, {
				Header = "Header",
				Buttons = {"No", "Yes"},
				OnResult = function()
				end,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local instance = Roact.mount(createTestSimpleDialog())
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestSimpleDialog(), container)
		local dialog = container.Frame

		expect(dialog.Header).to.be.ok()
		expect(dialog.Buttons).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX34C26D2A08494009BAA08CE48EC26D91">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StyledScrollingFrame.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local StyledScrollingFrame = require(Plugin.Src.Components.StyledScrollingFrame)

	local theme = Theme.newDummyTheme()

	it("should create and destroy without errors", function()
		local element = Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			frame = Roact.createElement(StyledScrollingFrame),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX500D3B620A2B4089B41252542A47D71C">
					<Properties>
						<string name="Name">SettingsPages</string>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX604083D91453414EA56C2B2AD30E8497">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BasicInfo.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	local BasicInfo = require(Plugin.Src.Components.SettingsPages.BasicInfo)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.newDummyTheme()

	local ERROR_COLOR = Color3.new(1, 0.266, 0.266)

	local nameErrors = {
		Moderated = "The name didn't go through our moderation. Please revise it and try again.",
		Empty = "Name cannot be empty.",
	}

	local descriptionErrors = {
		Moderated = "The description didn't go through our moderation. Please revise it and try again.",
	}

	local settingsInfoTest = {
		Current = {
			name = "Name",
			description = "Description",
			isActive = true,
			playableDevices = {
				Computer = true,
				Phone = true,
				Tablet = true,
				Console = false,
			}
		},
		Changed = {},
		Errors = {},
	}

	local settingsInfoEmptyNameTest = {
		Current = {
			name = "",
		},
		Changed = {},
		Errors = {
			name = "Empty"
		},
	}

	local settingsInfoLongNameTest = {
		Current = {
			name = string.rep("w", 150),
		},
		Changed = {},
		Errors = {
			name = "TooLong"
		},
	}

	local settingsInfoBadNameTest = {
		Current = {
			name = "Bad Word",
		},
		Changed = {},
		Errors = {
			name = "Moderated"
		},
	}

	local settingsInfoLongDescriptionTest = {
		Current = {
			description = string.rep("w", 1500),
		},
		Changed = {},
		Errors = {
			description = "TooLong"
		},
	}

	local settingsInfoBadDescriptionTest = {
		Current = {
			description = "Bad Word",
		},
		Changed = {},
		Errors = {
			description = "Moderated"
		},
	}

	local function createTestOptions(startState)
		local settingsStore = Rodux.Store.new(
			MainReducer,
			{Settings = startState},
			{Rodux.thunkMiddleware}
		)

		return Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			basicInfo = Roact.createElement(BasicInfo),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestOptions()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace

		local element = createTestOptions()
		local instance = Roact.mount(element, container)
		local info = container.Frame

		expect(info.Layout).to.be.ok()
		expect(info.Name).to.be.ok()
		expect(info.Description).to.be.ok()
		expect(info.Playability).to.be.ok()
		expect(info.Devices).to.be.ok()
		expect(info.Separator).to.be.ok()
		expect(info.Separator2).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should disable when no permissions", function()
		local container = workspace

		local element = createTestOptions()
		local instance = Roact.mount(element, container)
		local info = container.Frame

		local textBoxes = {
			info:FindFirstChild("Name").Content.TextBox.Border.Text.Text,
			info.Description.Content.TextBox.Border.Text.ScrollingFrame.Text,
		}

		for _, textBox in ipairs(textBoxes) do
			expect(textBox.Visible).to.equal(false)
		end

		for _, button in ipairs(info.Playability.Content:GetChildren()) do
			if (button:IsA("Frame")) then
				expect(button.Button.TitleLabel.TextTransparency).never.to.equal(0)
			end
		end

		for _, box in ipairs(info.Devices.Content:GetChildren()) do
			if (box:IsA("Frame")) then
				expect(box.Background.TitleLabel.TextTransparency).never.to.equal(0)
			end
		end

		Roact.unmount(instance)
	end)

	it("should enable with permissions", function()
		local container = workspace

		local element = createTestOptions(settingsInfoTest)
		local instance = Roact.mount(element, container)
		local info = container.Frame

		local textBoxes = {
			info:FindFirstChild("Name").Content.TextBox.Border.Text.Text,
			info.Description.Content.TextBox.Border.Text.ScrollingFrame.Text,
		}

		for _, textBox in ipairs(textBoxes) do
			expect(textBox.Visible).to.equal(true)
		end

		for _, button in ipairs(info.Playability.Content:GetChildren()) do
			if (button:IsA("Frame")) then
				expect(button.Button.TitleLabel.TextTransparency).to.equal(0)
			end
		end

		for _, box in ipairs(info.Devices.Content:GetChildren()) do
			if (box:IsA("Frame")) then
				expect(box.Background.TitleLabel.TextTransparency).to.equal(0)
			end
		end

		Roact.unmount(instance)
	end)

	describe("Name", function()
		it("should error when name is empty", function()
			local container = workspace

			local element = createTestOptions(settingsInfoEmptyNameTest)
			local instance = Roact.mount(element, container)
			local info = container.Frame

			expect(info:FindFirstChild("Name").Content.TextBox.Border.ImageColor3).to.equal(ERROR_COLOR)
			expect(info:FindFirstChild("Name").Content.TextBox.Tooltip.Text).to.equal(nameErrors.Empty)

			Roact.unmount(instance)
		end)

		it("should error when name is too long", function()
			local container = workspace

			local element = createTestOptions(settingsInfoLongNameTest)
			local instance = Roact.mount(element, container)
			local info = container.Frame

			expect(info:FindFirstChild("Name").Content.TextBox.Border.ImageColor3).to.equal(ERROR_COLOR)

			Roact.unmount(instance)
		end)

		it("should error when name is moderated", function()
			local container = workspace

			local element = createTestOptions(settingsInfoBadNameTest)
			local instance = Roact.mount(element, container)
			local info = container.Frame

			expect(info:FindFirstChild("Name").Content.TextBox.Border.ImageColor3).to.equal(ERROR_COLOR)
			expect(info:FindFirstChild("Name").Content.TextBox.Tooltip.Text).to.equal(nameErrors.Moderated)

			Roact.unmount(instance)
		end)
	end)

	describe("Description", function()
		it("should error when description is too long", function()
			local container = workspace

			local element = createTestOptions(settingsInfoLongDescriptionTest)
			local instance = Roact.mount(element, container)
			local info = container.Frame

			expect(info.Description.Content.TextBox.Border.ImageColor3).to.equal(ERROR_COLOR)

			Roact.unmount(instance)
		end)

		it("should error when description is moderated", function()
			local container = workspace

			local element = createTestOptions(settingsInfoBadDescriptionTest)
			local instance = Roact.mount(element, container)
			local info = container.Frame

			expect(info.Description.Content.TextBox.Border.ImageColor3).to.equal(ERROR_COLOR)
			expect(info.Description.Content.TextBox.Tooltip.Text).to.equal(descriptionErrors.Moderated)

			Roact.unmount(instance)
		end)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1FB1780F72C54217B426A1E18E9BC388">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Avatar.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	local Avatar = require(Plugin.Src.Components.SettingsPages.Avatar)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.newDummyTheme()

	local settingsAvatarTest = {
		Current = {
			universeAvatarType = "MorphToR15",
			universeScaleType = "AllScales",
			universeAnimationType = "PlayerChoice",
			universeCollisionType = "OuterBox",
		},
		Changed = {},
	}

	local function createTestAvatar(startState)
		local settingsStore = Rodux.Store.new(
			MainReducer,
			{Settings = startState},
			{Rodux.thunkMiddleware}
		)

		return Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			avatar = Roact.createElement(Avatar),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestAvatar()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace

		local element = createTestAvatar()

		local instance = Roact.mount(element, container)
		local avatar = container.Frame

		expect(avatar.Layout).to.be.ok()
		expect(avatar.Type).to.be.ok()
		expect(avatar.Scaling).to.be.ok()
		expect(avatar.Animation).to.be.ok()
		expect(avatar.Collision).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should disable when no permissions", function()
		local container = workspace

		local element = createTestAvatar()
		local instance = Roact.mount(element, container)
		local avatar = container.Frame

		local sets = {
			avatar.Type,
			avatar.Scaling,
			avatar.Animation,
			avatar.Collision,
		}

		for _, set in ipairs(sets) do
			for _, button in ipairs(set.Content:GetChildren()) do
				if (button:IsA("Frame")) then
					expect(button.Button.TitleLabel.TextTransparency).never.to.equal(0)
				end
			end
		end

		Roact.unmount(instance)
	end)

	it("should enable with permissions", function()
		local container = workspace

		local element = createTestAvatar(settingsAvatarTest)
		local instance = Roact.mount(element, container)
		local avatar = container.Frame

		local sets = {
			avatar.Type,
			avatar.Scaling,
			avatar.Animation,
			avatar.Collision,
		}

		for _, set in ipairs(sets) do
			for _, button in ipairs(set.Content:GetChildren()) do
				if (button:IsA("Frame")) then
					expect(button.Button.TitleLabel.TextTransparency).to.equal(0)
				end
			end
		end

		Roact.unmount(instance)
	end)

	it("should highlight the correct buttons", function()
		local container = workspace

		local element = createTestAvatar(settingsAvatarTest)
		local instance = Roact.mount(element, container)
		local avatar = container.Frame

		local sets = {
			avatar.Type,
			avatar.Scaling,
			avatar.Animation,
			avatar.Collision,
		}

		for _, set in ipairs(sets) do
			expect(set.Content["2"].Button.Highlight.Visible).to.equal(true)
		end

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB3D8174F3767405F959E076F20526A95">
						<Properties>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Options.spec</string>
							<string name="ScriptGuid"></string>
							<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	local Options = require(Plugin.Src.Components.SettingsPages.Options)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.newDummyTheme()

	local settingsOptionsTest = {
		Current = {
			HttpEnabled = true,
		},
		Changed = {},
	}

	local function createTestOptions(startState)
		local settingsStore = Rodux.Store.new(
			MainReducer,
			{Settings = startState},
			{Rodux.thunkMiddleware}
		)

		return Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			options = Roact.createElement(Options),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestOptions()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace

		local element = createTestOptions()
		local instance = Roact.mount(element, container)
		local publication = container.Frame

		expect(publication.Layout).to.be.ok()
		expect(publication.Http).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should disable when no permissions", function()
		local container = workspace

		local element = createTestOptions()
		local instance = Roact.mount(element, container)
		local publication = container.Frame

		local sets = {
			publication.Http,
		}

		for _, set in ipairs(sets) do
			for _, button in ipairs(set.Content:GetChildren()) do
				if (button:IsA("Frame")) then
					expect(button.Button.Highlight.Visible).to.equal(false)
				end
			end
		end

		Roact.unmount(instance)
	end)

	it("should enable with permissions", function()
		local container = workspace

		local element = createTestOptions(settingsOptionsTest)
		local instance = Roact.mount(element, container)
		local publication = container.Frame

		local sets = {
			publication.Http,
		}

		for _, set in ipairs(sets) do
			for _, button in ipairs(set.Content:GetChildren()) do
				if (button:IsA("Frame")) then
					expect(button.Button.TitleLabel.TextTransparency).to.equal(0)
				end
			end
		end

		Roact.unmount(instance)
	end)

	it("should highlight the correct buttons", function()
		local container = workspace

		local element = createTestOptions(settingsOptionsTest)
		local instance = Roact.mount(element, container)
		local publication = container.Frame

		local sets = {
			publication.Http,
		}

		for _, set in ipairs(sets) do
			expect(set.Content["1"].Button.Highlight.Visible).to.equal(true)
			expect(set.Content["2"].Button.Highlight.Visible).to.equal(false)
		end

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXA567A28EFE644D20AC17ADFFEAE4DDD2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CurrentPage.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	local CurrentPage = require(Plugin.Src.Components.CurrentPage)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.newDummyTheme()

	local settingsStore = Rodux.Store.new(
		MainReducer,
		nil,
		{Rodux.thunkMiddleware}
	)

	local function createTestCurrentPage(page)
		local services = Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			currentPage = Roact.createElement(CurrentPage, {
				Page = page,
			})
		})

		return services
	end

	it("should create and destroy without errors", function()
		local element = createTestCurrentPage("")
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace

		local element = createTestCurrentPage("")
		local instance = Roact.mount(element, container)
		local currentPage = container.Frame

		expect(currentPage.ScrollingFrame).to.be.ok()
		expect(currentPage.ScrollingFrame.Padding).to.be.ok()
		expect(currentPage.ScrollingFrame.Layout).to.be.ok()
		expect(currentPage.ScrollingFrame.Header).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should display a page", function()
		local container = workspace

		local element = createTestCurrentPage("Avatar")
		local instance = Roact.mount(element, container)
		local currentPage = container.Frame

		expect(currentPage.ScrollingFrame).to.be.ok()
		expect(currentPage.ScrollingFrame.Avatar).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDC315FBF3C274D7CBA8A2EB6E569CEFA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Footer.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)
	local Constants = require(Plugin.Src.Util.Constants)

	local Footer = require(Plugin.Src.Components.Footer)

	local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.new()

	local settingsFooterTest = {
		Current = {},
		Changed = {
			Something = "Changed",
		},
		Errors = {},
	}

	local settingsFooterErrorTest = {
		Current = {},
		Changed = {
			Something = "Changed",
		},
		Errors = {
			Value = "Error",
		},
	}

	local function buttonIsDisabled(color)
		local c = Enum.StudioStyleGuideColor
		local m = Enum.StudioStyleGuideModifier
		local disabledColor = settings().Studio.Theme:GetColor(c.Button, m.Disabled)
		return color == disabledColor or color == Constants.BLUE_DISABLED
	end

	local function textIsDisabled(color)
		local c = Enum.StudioStyleGuideColor
		local disabledColor = settings().Studio.Theme:GetColor(c.DimmedText)
		return color == disabledColor
	end

	local function createTestFooter(startState, status)
		local settingsStore = Rodux.Store.new(MainReducer, {
				Settings = startState,
				Status = status or CurrentStatus.Open,
			},
			{Rodux.thunkMiddleware}
		)

		return Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			footer = Roact.createElement(Footer, {
				SaveActive = false,
				ButtonClicked = function()
				end,
				OnClose = function()
				end,
			})
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestFooter()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace

		local element = createTestFooter()
		local instance = Roact.mount(element, container)
		local footer = container.Frame

		expect(footer.Gradient).to.be.ok()
		expect(footer.SaveSettings).to.be.ok()

		Roact.unmount(instance)
	end)

	describe("Save Button", function()
		it("should enable when there are changes", function()
			local container = workspace

			local element = createTestFooter(settingsFooterTest)
			local instance = Roact.mount(element, container)
			local footer = container.Frame

			expect(buttonIsDisabled(footer.SaveSettings["3"].ImageColor3)).to.equal(false)

			Roact.unmount(instance)
		end)

		it("should disable when there are no changes", function()
			local container = workspace

			local element = createTestFooter()
			local instance = Roact.mount(element, container)
			local footer = container.Frame

			expect(buttonIsDisabled(footer.SaveSettings["3"].ImageColor3)).to.equal(true)

			Roact.unmount(instance)
		end)

		it("should disable when the app is working", function()
			local container = workspace

			local element = createTestFooter(settingsFooterTest, CurrentStatus.Working)
			local instance = Roact.mount(element, container)
			local footer = container.Frame

			expect(buttonIsDisabled(footer.SaveSettings["3"].ImageColor3)).to.equal(true)

			Roact.unmount(instance)
		end)

		it("should disable when there is an error", function()
			local container = workspace

			local element = createTestFooter(settingsFooterErrorTest)
			local instance = Roact.mount(element, container)
			local footer = container.Frame

			expect(buttonIsDisabled(footer.SaveSettings["3"].ImageColor3)).to.equal(true)

			Roact.unmount(instance)
		end)
	end)

	describe("Cancel Button", function()
		it("should enable when the app is open", function()
			local container = workspace

			local element = createTestFooter(settingsFooterTest)
			local instance = Roact.mount(element, container)
			local footer = container.Frame

			expect(textIsDisabled(footer.SaveSettings["2"].Text.TextColor3)).to.equal(false)

			Roact.unmount(instance)
		end)

		it("should disable when the app is working", function()
			local container = workspace

			local element = createTestFooter(settingsFooterTest, CurrentStatus.Working)
			local instance = Roact.mount(element, container)
			local footer = container.Frame

			expect(textIsDisabled(footer.SaveSettings["2"].Text.TextColor3)).to.equal(true)

			Roact.unmount(instance)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4AA9D5278AD24CA6BFA3ED44389B602F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ExternalServicesWrapper.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local Theme = require(Plugin.Src.Util.Theme)

	local theme = Theme.newDummyTheme()
	local store = Rodux.Store.new(function()
	end)
	local settingsImpl = SettingsImpl_mock.new()

	it("should create and destroy without errors", function()
		local element = Roact.createElement(ExternalServicesWrapper, {
			impl = settingsImpl,
			theme = theme,
			store = store,
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element)

		Roact.unmount(handle)
	end)

	it("should expect a 'store' prop", function()
		local element = Roact.createElement(ExternalServicesWrapper, {
			impl = settingsImpl,
			theme = theme,
		})

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)

	it("should expect an 'impl' prop", function()
		local element = Roact.createElement(ExternalServicesWrapper, {
			theme = theme,
			store = store,
		})

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)

	it("should expect a 'theme' prop", function()
		local element = Roact.createElement(ExternalServicesWrapper, {
			impl = settingsImpl,
			theme = theme,
		})

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE11CCC43F89E4E588775046C8A2F2324">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundTextButton.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local RoundTextButton = require(Plugin.Src.Components.RoundTextButton)

	local function createTestRoundTextButton()
		return Roact.createElement(RoundTextButton, {
			Active = true,
			Style = {},
			Name = "Name",
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestRoundTextButton()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestRoundTextButton(), container)
		local button = container.ImageButton

		expect(button.Border).to.be.ok()
		expect(button.Text).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX47A2D4EA8A624BA38CC1018157C505EB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TextEntry.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local TextEntry = require(Plugin.Src.Components.TextEntry)

	local function createTestTextEntry(text, visible)
		return Roact.createElement(TextEntry, {
			Text = text,
			Visible = visible,
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestTextEntry()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestTextEntry("", true), container)
		local frame = container.Frame

		expect(frame.Text).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should hide its text when not visible", function ()
		local container = workspace
		local instance = Roact.mount(createTestTextEntry("", false), container)
		local frame = container.Frame

		expect(frame.Text.Visible).to.equal(false)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0B598E88AEEE4C6FA4163540908E35A8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Separator.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local Separator = require(Plugin.Src.Components.Separator)

	local theme = Theme.newDummyTheme()

	it("should create and destroy without errors", function()
		local element = Roact.createElement(ThemeProvider, {
			theme = theme
		}, {
			separator = Roact.createElement(Separator),
		})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9705911655714D5EB6F5F258D543E3EE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RoundTextBox.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local RoundTextBox = require(Plugin.Src.Components.RoundTextBox)

	local theme = Theme.newDummyTheme()

	local function createTestRoundTextBox(active, errorMessage)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			textBox = Roact.createElement(RoundTextBox, {
				Active = active,
				MaxLength = 50,
				Multiline = false,
				Text = "Text",
				ErrorMessage = errorMessage,
			})
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestRoundTextBox(true)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestRoundTextBox(true), container)
		local background = container.ImageLabel

		expect(background.Border).to.be.ok()
		expect(background.Border.Padding).to.be.ok()
		expect(background.Border.Text).to.be.ok()
		expect(background.Tooltip).to.be.ok()

		Roact.unmount(instance)
	end)

	describe("Tooltip", function()
		it("should show the correct length of the text", function ()
			local container = workspace
			local instance = Roact.mount(createTestRoundTextBox(true), container)
			local background = container.ImageLabel

			expect(background.Tooltip.Text).to.equal("4/50")

			Roact.unmount(instance)
		end)

		it("should show an error message if one exists", function ()
			local container = workspace
			local instance = Roact.mount(createTestRoundTextBox(true, "Error"), container)
			local background = container.ImageLabel

			expect(background.Tooltip.Text).to.equal("Error")

			Roact.unmount(instance)
		end)

		it("should be empty if component is inactive", function ()
			local container = workspace
			local instance = Roact.mount(createTestRoundTextBox(false), container)
			local background = container.ImageLabel

			expect(background.Tooltip.Text).to.equal("")

			Roact.unmount(instance)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA94262A07E164991B177BBA1257B834D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MenuEntry.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local MenuEntry = require(Plugin.Src.Components.MenuEntry)

	local theme = Theme.newDummyTheme()

	local function createTestMenuEntry(selected, err)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			menuEntry = Roact.createElement(MenuEntry, {
				Title = "Title",
				Selected = selected,
				Error = err or false,
				OnClicked = function()
				end,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestMenuEntry(false)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestMenuEntry(false), container)
		local menuEntry = container.Frame

		expect(menuEntry.Title).to.be.ok()
		expect(menuEntry.Highlight).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should show a ribbon when selected", function ()
		local container = workspace
		local instance = Roact.mount(createTestMenuEntry(false), container)
		local menuEntry = container.Frame

		expect(menuEntry.Highlight.BackgroundTransparency).to.equal(1)

		local newMenuEntry = createTestMenuEntry(true)

		instance = Roact.reconcile(instance, newMenuEntry)

		expect(menuEntry.Highlight.BackgroundTransparency).to.equal(0)

		Roact.unmount(instance)
	end)

	it("should show an error icon when appropriate", function ()
		local container = workspace
		local instance = Roact.mount(createTestMenuEntry(false, false), container)
		local menuEntry = container.Frame

		expect(menuEntry.Error.Visible).to.equal(false)

		local newMenuEntry = createTestMenuEntry(false, true)

		instance = Roact.reconcile(instance, newMenuEntry)

		expect(menuEntry.Error.Visible).to.equal(true)

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4C533895AFA3439D90559AFAF0B5B062">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TitledFrame.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local TitledFrame = require(Plugin.Src.Components.TitledFrame)

	local theme = Theme.newDummyTheme()

	local function createTestTitledFrame()
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			frame = Roact.createElement(TitledFrame, {
				Title = "Title",
			}),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestTitledFrame()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestTitledFrame(), container)
		local titledFrame = container.Frame

		expect(titledFrame.Title).to.be.ok()
		expect(titledFrame.Content).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX12E90233D3CF42DB85E9C8CD32ECC0E8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CheckBoxSet.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local CheckBoxSet = require(Plugin.Src.Components.CheckBoxSet)

	local theme = Theme.newDummyTheme()

	local function createBoxes(first, second)
		local testBoxes = {{
				Id = "First",
				Selected = first,
			}, {
				Id = "Second",
				Selected = second,
			},
		}
		return testBoxes
	end

	local function createTestCheckBoxSet(boxes, enabled, err)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			buttonSet = Roact.createElement(CheckBoxSet, {
				Title = "Title",
				Enabled = enabled,
				SelectionChanged = function()
				end,
				Boxes = boxes,
				ErrorMessage = err,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestCheckBoxSet({}, true)
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace
		local instance = Roact.mount(createTestCheckBoxSet(createBoxes(true, true)), container)
		local checkBoxSet = container.Frame

		expect(checkBoxSet.Title).to.be.ok()
		expect(checkBoxSet.Content).to.be.ok()
		expect(checkBoxSet.Content.Layout).to.be.ok()
		expect(checkBoxSet.Content["1"]).to.be.ok()
		expect(checkBoxSet.Content["2"]).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should enable its boxes when enabled", function()
		local container = workspace
		local instance = Roact.mount(createTestCheckBoxSet(createBoxes(true, false), true), container)
		local checkBoxSet = container.Frame

		expect(checkBoxSet.Content["1"].Background.Selection.Visible).to.equal(true)
		expect(checkBoxSet.Content["2"].Background.Selection.Visible).to.equal(false)

		Roact.unmount(instance)
	end)

	it("should disable its boxes when disabled", function()
		local container = workspace
		local instance = Roact.mount(createTestCheckBoxSet(createBoxes(true, true), false), container)
		local checkBoxSet = container.Frame

		expect(checkBoxSet.Content["1"].Background.Selection.Visible).to.equal(false)
		expect(checkBoxSet.Content["2"].Background.Selection.Visible).to.equal(false)

		Roact.unmount(instance)
	end)

	it("should display the passed error message", function()
		local container = workspace
		local instance = Roact.mount(createTestCheckBoxSet(createBoxes(true, true), true, "Error"), container)
		local checkBoxSet = container.Frame

		expect(checkBoxSet.Content.Error).to.be.ok()
		expect(checkBoxSet.Content.Error.Visible).to.equal(true)
		expect(checkBoxSet.Content.Error.Text).to.equal("Error")

		local noError = createTestCheckBoxSet(createBoxes(true, true), true, nil)
		instance = Roact.reconcile(instance, noError)

		expect(checkBoxSet.Content:FindFirstChild("Error")).never.to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX25A581F30F844EB6B85BCB11FF94FC00">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ButtonBar.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)

	local Theme = require(Plugin.Src.Util.Theme)
	local ThemeProvider = require(Plugin.Src.Providers.ThemeProvider)

	local ButtonBar = require(Plugin.Src.Components.ButtonBar)

	local theme = Theme.newDummyTheme()

	local function createTestButtonBar(horizontalAlignment, buttons)
		return Roact.createElement(ThemeProvider, {
			theme = theme,
		}, {
			buttonBar = Roact.createElement(ButtonBar, {
				HorizontalAlignment = horizontalAlignment,
				Buttons = buttons,
			}),
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestButtonBar(Enum.HorizontalAlignment.Center, {})
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function ()
		local container = workspace
		local instance = Roact.mount(createTestButtonBar(
			Enum.HorizontalAlignment.Center, {}), container)
		local buttonBar = container.Frame

		expect(buttonBar.Layout).to.be.ok()

		local newButtonBar = createTestButtonBar(Enum.HorizontalAlignment.Right, {})

		instance = Roact.reconcile(instance, newButtonBar)

		expect(buttonBar.Layout).to.be.ok()
		expect(buttonBar["1"]).to.be.ok()

		Roact.unmount(instance)
	end)

	it("should hold buttons", function ()
		local container = workspace
		local instance = Roact.mount(createTestButtonBar(
			Enum.HorizontalAlignment.Center, {
			{Name = "Button1", Style = "White", Active = true},
			{Name = "Button2", Style = "White", Active = true},
		}), container)
		local buttonBar = container.Frame

		expect(buttonBar["1"]).to.be.ok()
		expect(buttonBar["2"]).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB04BB9A9BE9F4720B6B0634774C8A17F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MainView.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)

	local ExternalServicesWrapper = require(Plugin.Src.Components.ExternalServicesWrapper)
	local Theme = require(Plugin.Src.Util.Theme)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	local MainView = require(Plugin.Src.Components.MainView)

	local settingsImpl = SettingsImpl_mock.new()
	local theme = Theme.newDummyTheme()

	local settingsStore = Rodux.Store.new(
		MainReducer,
		{Settings = nil},
		{Rodux.thunkMiddleware}
	)

	local function createTestMainView()
		return Roact.createElement(ExternalServicesWrapper, {
			store = settingsStore,
			impl = settingsImpl,
			theme = theme,
		}, {
			mainView = Roact.createElement(MainView, {
				MenuEntries = {
					{Name = "Avatar"},
				},
				Selected = 1,
				SelectionChanged = function()
				end,
			})
		})
	end

	it("should create and destroy without errors", function()
		local element = createTestMainView()
		local instance = Roact.mount(element)
		Roact.unmount(instance)
	end)

	it("should render correctly", function()
		local container = workspace

		local element = createTestMainView()
		local instance = Roact.mount(element, container)
		local mainView = container.Frame

		expect(mainView.Padding).to.be.ok()
		expect(mainView.MenuBar).to.be.ok()
		expect(mainView.Separator).to.be.ok()
		expect(mainView.Page).to.be.ok()
		expect(mainView.Footer).to.be.ok()

		Roact.unmount(instance)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX160AD4C721104151B1DCCFA5EF82E542">
				<Properties>
					<string name="Name">Actions</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXCE59056609F94B2F918E8F3A222BF7D8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Action.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Action = require(Plugin.Src.Actions.Action)

	it("should return a table", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action).to.be.a("table")
	end)

	it("should set the name of the action", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action.name).to.equal("foo")
	end)

	it("should be able to be called as a function", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action).never.to.throw()
	end)

	it("should return a table when called as a function", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action()).to.be.a("table")
	end)

	it("should set the type of the action", function()
		local action = Action("foo", function()
			return {}
		end)

		expect(action().type).to.equal("foo")
	end)

	it("should set values", function()
		local action = Action("foo", function(value)
			return {
				value = value
			}
		end)

		expect(action(100).value).to.equal(100)
	end)

	it("should throw when passed a function", function()
		local action = Action("foo", function()
			return function() end
		end)

		expect(action).to.throw()
	end)

	it("should throw with a invalid name", function()
		expect(function()
			Action(nil, function()
				return {}
			end)
		end).to.throw()

		expect(function()
			Action(100, function()
				return {}
			end)
		end).to.throw()
	end)

	it("should throw when passed a invalid function", function()
		expect(function()
			Action("foo", nil)
		end).to.throw()

		expect(function()
			Action("foo", {})
		end).to.throw()
	end)
end
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBXBC7D6694B9F54B719E573BFE3892DF00">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GameSettingsTests</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[if workspace:FindFirstChild("RunGameSettingsTests") and workspace.RunGameSettingsTests.Value then
	local TestEZ = script.Parent.Parent.TestEZ
	local tests = script.Parent

	local TestBootstrap = require(TestEZ.TestBootstrap)
	local TextReporter = require(TestEZ.Reporters.TextReporter)

	TestBootstrap:run(tests, TextReporter)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX41D10D7A965D4489A0E84DD26F1D70C6">
				<Properties>
					<string name="Name">Thunks</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE9E2139DC49B46FB9CCC56973866AE20">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SaveChanges.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Rodux = require(Plugin.Rodux)
	local Promise = require(Plugin.Promise)

	local SettingsReducer = require(Plugin.Src.Reducers.Settings)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local SaveChanges = require(Plugin.Src.Thunks.SaveChanges)

	local settingsImpl = SettingsImpl_mock.new()

	it("should return a Promise", function()
		local store = Rodux.Store.new(
			SettingsReducer,
			nil,
			{Rodux.thunkMiddleware}
		)

		local result = store:dispatch(SaveChanges(settingsImpl))
		expect(Promise.is(result)).to.equal(true)
	end)

	it("should not modify the store", function()
		local startState = {
			Current = {
				SomeKey = "SomeValue"
			},
			Changed = {},
		}
		local store = Rodux.Store.new(
			SettingsReducer,
			startState,
			{Rodux.thunkMiddleware}
		)

		expect(store:getState()).to.equal(startState)

		store:dispatch(SaveChanges(settingsImpl)):await()

		expect(store:getState()).to.equal(startState)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX10CC5BFCA9EC4417B3A04EDA3ECE3342">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LoadAllSettings.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Rodux = require(Plugin.Rodux)
	local Promise = require(Plugin.Promise)

	local SettingsReducer = require(Plugin.Src.Reducers.Settings)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local LoadAllSettings = require(Plugin.Src.Thunks.LoadAllSettings)
	local isEmpty = require(Plugin.Src.Util.isEmpty)

	local settingsImpl = SettingsImpl_mock.new()

	it("should return a Promise", function()
		local store = Rodux.Store.new(
			SettingsReducer,
			nil,
			{Rodux.thunkMiddleware}
		)

		local result = store:dispatch(LoadAllSettings(settingsImpl))
		expect(Promise.is(result)).to.equal(true)
	end)

	it("should load settings to the store", function()
		local startState = {
			Current = {
				SomeKey = "SomeValue"
			},
			Changed = {},
		}
		local store = Rodux.Store.new(
			SettingsReducer,
			startState,
			{Rodux.thunkMiddleware}
		)

		store:dispatch(LoadAllSettings(settingsImpl)):await()

		expect(store:getState()).never.to.equal(startState)
		expect(isEmpty(store:getState().Current)).to.equal(true)
		expect(isEmpty(store:getState().Changed)).to.equal(true)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0E91A37F0BB14CBEAC9611D03922C0CD">
				<Properties>
					<string name="Name">Providers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX462F36B3DB2D4D25A8B78BDD34875063">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SettingsImplProvider.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Roact = require(Plugin.Roact)

	local SettingsImplProvider = require(Plugin.Src.Providers.SettingsImplProvider)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)

	it("should create and destroy without errors", function()
		local settingsImpl = SettingsImpl_mock.new()

		local element = Roact.createElement(SettingsImplProvider, {
			impl = settingsImpl
		})

		expect(element).to.be.ok()

		local handle = Roact.mount(element)

		Roact.unmount(handle)
	end)

	it("should expect an 'interface' prop", function()
		local element = Roact.createElement(SettingsImplProvider)

		expect(function()
			Roact.mount(element)
		end).to.throw()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX9DBB8548A75A4E3196B75EFE27B7F1AE">
				<Properties>
					<string name="Name">Reducers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXEA6CEC61C86746828EF8D9B145781C33">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Settings.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Rodux = require(Plugin.Rodux)

	local SettingsReducer = require(Plugin.Src.Reducers.Settings)

	local AddChange = require(Plugin.Src.Actions.AddChange)
	local AddErrors = require(Plugin.Src.Actions.AddErrors)
	local DiscardChanges = require(Plugin.Src.Actions.DiscardChanges)
	local SetCurrentSettings = require(Plugin.Src.Actions.SetCurrentSettings)

	it("should initialize with Current and Changed if given nil", function()
		local store = Rodux.Store.new(SettingsReducer)
		expect(store:getState()).to.be.ok()
		expect(store:getState().Current).to.be.ok()
		expect(store:getState().Changed).to.be.ok()
	end)

	describe("AddChange", function()
		it("should add a key to Changed if a value is set", function()
			local startState = {
				Current = {},
				Changed = {},
				Errors = {},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(AddChange("SomeKey", "SomeValue"))

			expect(store:getState().Changed.SomeKey).to.be.ok()
		end)

		it("should remove a key within Changed if set back to its actual value", function()
			local startState = {
				Current = {
					SomeKey = "SomeValue",
				},
				Changed = {
					SomeKey = "SomeOtherValue",
					SomeOtherKey = "SomeOtherValue2",
				},
				Errors = {},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(AddChange("SomeKey", "SomeValue"))

			expect(store:getState().Changed.SomeKey).never.to.be.ok()
		end)

		it("should remove any errors related to the changed setting", function()
			local startState = {
				Current = {
					SomeKey = "SomeValue",
				},
				Changed = {
					SomeKey = "OtherValue",
				},
				Errors = {
					SomeKey = "SomeError",
				},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(AddChange("SomeKey", "OtherValue2"))

			expect(store:getState().Errors.SomeKey).never.to.be.ok()
		end)
	end)

	describe("AddErrors", function()
		it("should join Errors and the new values", function()
			local startState = {
				Current = {},
				Changed = {},
				Errors = {
					ExistingKey = "ExistingError",
				},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(AddErrors({NewKey = "NewError"}))

			expect(store:getState().Errors.ExistingKey).to.equal("ExistingError")
			expect(store:getState().Errors.NewKey).to.equal("NewError")
		end)

		it("should replace an old error with a new one", function()
			local startState = {
				Current = {},
				Changed = {},
				Errors = {
					ExistingKey = "ExistingError",
				},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(AddErrors({ExistingKey = "NewError"}))

			expect(store:getState().Errors.ExistingKey).to.equal("NewError")
		end)
	end)

	describe("DiscardChanges", function()
		it("should empty the Changed table", function()
			local startState = {
				Changed = {
					SomeKey = "SomeValue",
					OtherKey = "OtherValue",
				},
				Errors = {},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(DiscardChanges())

			expect(store:getState().Changed.SomeKey).never.to.be.ok()
			expect(store:getState().Changed.OtherKey).never.to.be.ok()
		end)
	end)

	describe("SetCurrentSettings", function()
		it("should not modify the Changed table", function()
			local startState = {
				Current = {},
				Changed = {
					SomeKey = "SomeValue",
				},
				Errors = {},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(SetCurrentSettings({}))

			expect(store:getState().Changed.SomeKey).to.be.ok()
		end)

		it("should not modify the Errors table", function()
			local startState = {
				Current = {},
				Changed = {},
				Errors = {SomeKey = "SomeError",},
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(SetCurrentSettings({}))

			expect(store:getState().Errors.SomeKey).to.be.ok()
		end)

		it("should overwrite the old Current values", function()
			local startState = {
				Current = {},
				Changed = {},
				Errors = {},
			}
			local newState = {
				SomeKey = "SomeValue",
				OtherKey = "OtherValue",
			}
			local store = Rodux.Store.new(
				SettingsReducer,
				startState,
				{Rodux.thunkMiddleware}
			)

			store:dispatch(SetCurrentSettings(newState))

			expect(store:getState().Current).to.equal(newState)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC6B073AB169D45BA863E24CE0D1A97BF">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MainReducer.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Rodux = require(Plugin.Rodux)

	local MainReducer = require(Plugin.Src.Reducers.MainReducer)

	it("should combine all other reducers", function()
		local store = Rodux.Store.new(MainReducer)
		expect(store:getState().Status).to.be.ok()
		expect(store:getState().Settings).to.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7D966919DF2E48828D16325AC5910358">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Status.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local Rodux = require(Plugin.Rodux)

	local StatusReducer = require(Plugin.Src.Reducers.Status)

	local SetCurrentStatus = require(Plugin.Src.Actions.SetCurrentStatus)
	local CurrentStatus = require(Plugin.Src.Util.CurrentStatus)

	it("should initialize with Closed if given nil", function()
		local store = Rodux.Store.new(StatusReducer)
		expect(store:getState()).to.be.ok()
		expect(store:getState()).to.equal(CurrentStatus.Closed)
	end)

	describe("SetCurrentStatus", function()
		it("should modify the store's status", function()
			local store = Rodux.Store.new(StatusReducer)

			store:dispatch(SetCurrentStatus(CurrentStatus.Open))

			expect(store:getState()).to.equal(CurrentStatus.Open)
		end)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXE5CD21CDDA0548F5B3DE097D7B083DEB">
				<Properties>
					<string name="Name">Networking</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX71E706702EDE4F31AC93A60A77FE0DA6">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">settingFromState.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local settingFromState = require(Plugin.Src.Networking.settingFromState)

	it("should return the state itself if there is no Changed value", function()
		local state = {
			Current = {
				Setting = "Value",
			},
			Changed = {},
		}

		expect(settingFromState(state, "Setting")).to.equal("Value")
	end)

	it("should return the Changed value if it exists", function()
		local state = {
			Current = {
				Setting = "Value",
			},
			Changed = {
				Setting = "OtherValue",
			},
		}

		expect(settingFromState(state, "Setting")).to.equal("OtherValue")
	end)

	it("should return nil if setting doesn't exist", function()
		local state = {
			Current = {},
			Changed = {},
		}

		expect(settingFromState(state, "Setting")).never.to.be.ok()
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX966B3DD4A96F48C48216BFC716B43E1C">
				<Properties>
					<string name="Name">Consumers</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXD46C20F07A8D490486D22A827B57398C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getSettingsImpl.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent
	local Roact = require(Plugin.Roact)
	local Rodux = require(Plugin.Rodux)
	local RoactRodux = require(Plugin.RoactRodux)

	local SettingsImplProvider = require(Plugin.Src.Providers.SettingsImplProvider)
	local SettingsImpl_mock = require(Plugin.Src.Networking.SettingsImpl_mock)
	local SettingsReducer = require(Plugin.Src.Reducers.Settings)
	local getSettingsImpl = require(Plugin.Src.Consumers.getSettingsImpl)

	it("should return a SettingsImpl when one is present", function()
		local settingsStore = Rodux.Store.new(
			SettingsReducer,
			nil,
			{Rodux.thunkMiddleware}
		)

		local settingsImpl = SettingsImpl_mock.new()

		local consumedImpl = nil
		local SettingsImplConsumer = Roact.Component:extend("SettingsImplConsumer")

		function SettingsImplConsumer:init()
			consumedImpl = getSettingsImpl(self)
		end

		function SettingsImplConsumer:render()
			return nil
		end

		local element = Roact.createElement(SettingsImplConsumer, {})

		local storeProvider = Roact.createElement(RoactRodux.StoreProvider, {
			store = settingsStore
		}, {
			settingsImplProvider = Roact.createElement(SettingsImplProvider, {
				impl = settingsImpl,
			}, {
				consumer = element,
			}),
		})

		local handle = Roact.mount(storeProvider)

		expect(consumedImpl).to.equal(settingsImpl)

		Roact.unmount(handle)
	end)

	it("should return nil when no SettingsImpl is present", function()
		local consumedImpl = nil
		local SettingsImplConsumer = Roact.Component:extend("InterfaceConsumer")

		function SettingsImplConsumer:init()
			consumedImpl = getSettingsImpl(self)
		end

		function SettingsImplConsumer:render()
			return nil
		end

		local element = Roact.createElement(SettingsImplConsumer, {})
		local handle = Roact.mount(element)

		expect(consumedImpl).never.to.be.ok()

		Roact.unmount(handle)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX1D8C48C432164101AD7900D0072E0F06">
				<Properties>
					<string name="Name">Util</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX61722758AEE44367B92F60159A96E937">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">isEmpty.spec</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Plugin = script.Parent.Parent.Parent

	local isEmpty = require(Plugin.Src.Util.isEmpty)

	it("should return true when the table is empty", function()
		local emptyTable = {}

		expect(isEmpty(emptyTable)).to.equal(true)
	end)

	it("should return false when the table is not empty", function()
		local notEmptyTable = {
			Key = "value"
		}

		expect(isEmpty(notEmptyTable)).to.equal(false)
	end)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX341BB5889FA147A584A2B904461E5CF8">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TestEZ</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanBuilder = require(script.TestPlanBuilder)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanBuilder = TestPlanBuilder,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2C43036FA00B474B94C2F994F7663379">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestBootstrap</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end

	return path
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root, modules, current)
	modules = modules or {}
	current = current or root

	for _, child in ipairs(current:GetChildren()) do
		if child:IsA("ModuleScript") and child.Name:match("%.spec$") then
			local method = require(child)
			local path = getPath(child, root)

			table.insert(modules, {
				method = method,
				path = path
			})
		else
			self:getModules(root, modules, child)
		end
	end

	table.sort(modules, function(a, b)
		return a.path[#a.path]:lower() < b.path[#b.path]:lower()
	end)

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(root, reporter, showTimingInfo, noXpcallByDefault)
	noXpcallByDefault = noXpcallByDefault or false
	if not root then
		error("You must provide a root object to search for tests in!", 2)
	end

	reporter = reporter or TextReporter

	local startTime = tick()

	local modules
	if type(root) == "function" then
		modules = {{method = root, path = {}}}
	else
		modules = self:getModules(root)
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, noXpcallByDefault)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1390CE988A1547BEA63FA88B70411024">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestEnum</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Try = "Try",
	Describe = "Describe",
	It = "It"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA209599770A6475588FEA5745F5B13A4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestPlanner</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestPlanBuilder = require(script.Parent.TestPlanBuilder)

local TestPlanner = {}

local function buildPlan(builder, module, env)
	local currentEnv = getfenv(module.method)

	for key, value in pairs(env) do
		currentEnv[key] = value
	end

	local nodeCount = #module.path

	-- Dive into auto-named nodes for this module
	for i = nodeCount, 1, -1 do
		local name = module.path[i]
		builder:pushNode(name, TestEnum.NodeType.Describe)
	end

	local ok, err = xpcall(module.method, function(err)
		return err .. "\n" .. debug.traceback()
	end)

	-- This is an error outside of any describe/it blocks.
	-- We attach it to the node we generate automatically per-file.
	if not ok then
		local node = builder:getCurrentNode()
		node.loadError = err
	end

	-- Back out of auto-named nodes
	for _ = 1, nodeCount do
		builder:popNode()
	end
end

--[[
	Create a new environment with functions for defining the test plan structure
	using the given TestPlanBuilder.

	These functions illustrate the advantage of the stack-style tree navigation
	as state doesn't need to be passed around between functions or explicitly
	global.
]]
function TestPlanner.createEnvironment(builder)
	local env = {}

	function env.describe(phrase, callback)
		local node = builder:pushNode(phrase, TestEnum.NodeType.Describe)

		local ok, err = pcall(callback)

		-- loadError on a TestPlan node is an automatic failure
		if not ok then
			node.loadError = err
		end

		builder:popNode()
	end

	function env.try(phrase, callback)
		local node = builder:pushNode(phrase, TestEnum.NodeType.Try)

		local ok, err = pcall(callback)

		-- loadError on a TestPlan node is an automatic failure
		if not ok then
			node.loadError = err
		end

		builder:popNode()
	end

	function env.it(phrase, callback)
		local node = builder:pushNode(phrase, TestEnum.NodeType.It)

		node.callback = callback

		builder:popNode()
	end

	function env.itFOCUS(phrase, callback)
		local node = builder:pushNode(phrase, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)

		node.callback = callback

		builder:popNode()
	end

	function env.itSKIP(phrase, callback)
		local node = builder:pushNode(phrase, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)

		node.callback = callback

		builder:popNode()
	end

	function env.FOCUS()
		local currentNode = builder:getCurrentNode()

		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		local currentNode = builder:getCurrentNode()

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		These method is intended to disable the use of xpcall when running
		nodes contained in the same node that this function is called in.
		This is because xpcall breaks badly if the method passed yields.

		This function is intended to be hideous and seldom called.

		Once xpcall is able to yield, this function is obsolete.
	]]
	function env.HACK_NO_XPCALL()
		local currentNode = builder:getCurrentNode()

		currentNode.HACK_NO_XPCALL = true
	end

	env.step = env.it

	function env.include(...)
		local args = {...}
		local method, path
		if #args == 1 then
			method = args[1]
			path = {}
		elseif #args == 2 then
			method = args[2]
			path = {args[1]}
		end
		buildPlan(builder, {path = path, method = method}, env)
	end

	return env
end

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.
]]
function TestPlanner.createPlan(specFunctions, noXpcallByDefault)
	local builder = TestPlanBuilder.new()
	builder.noXpcallByDefault = noXpcallByDefault
	local env = TestPlanner.createEnvironment(builder)

	for _, module in ipairs(specFunctions) do
		buildPlan(builder, module, env)
	end

	return builder:finalize()
end

return TestPlanner]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7FBA796CAE6E4A3EA0C5D3882428633E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestSession</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)

	local lastNode = self.nodeStack[#self.nodeStack] or self.results

	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	return node
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	return table.remove(self.nodeStack, #self.nodeStack)
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

return TestSession]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6C25C3AFF2AA4D6E84E7D5B1265D71EB">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestResults</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXA1551E200080455D89A7851FBCF94B67">
				<Properties>
					<string name="Name">Reporters</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0095839845C74C6792A1C8AA969D791B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TextReporter</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX227B2BCE6FB34C159B999B22AD1298E9">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TeamCityReporter</string>
						<string name="ScriptGuid"></string>
						<ProtectedString name="Source"><![CDATA[local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXA72FBD507701445E9C90B7DE1AAC724C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Stack</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local Stack = {}
Stack.__index = Stack

function Stack.new()
	local self = {}
	setmetatable(self, Stack)
	self.data = {}
	return self
end

function Stack:size()
	return #self.data
end

function Stack:push(obj)
	self.data[self:size()+1] = obj
	return self
end

function Stack:pop()
	local result = self:getBack()
	table.remove(self.data,self:size())
	return result
end

function Stack:getBack()
	if self:size() == 0 then error("stack is empty") end
	local result = self.data[self:size()]
	return result
end

function Stack:setBack(obj)
	if self:size() == 0 then error("stack is empty") end
	self.data[self:size()] = obj
	return self
end

return Stack]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3E3BF287911344D091BC1AE90581F2D9">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestRunner</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local Expectation = require(script.Parent.Expectation)
local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local Stack = require(script.Parent.Stack)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

function TestRunner.environment.expect(...)
	return Expectation.new(...)
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local tryStack = Stack.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, tryStack)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, tryStack, noXpcall)
	for _, childPlanNode in ipairs(planNode.children) do
		local childResultNode = session:pushNode(childPlanNode)

		if childPlanNode.type == TestEnum.NodeType.It then
			if session:shouldSkip() then
				childResultNode.status = TestEnum.TestStatus.Skipped
			else
				if tryStack:size() > 0 and tryStack:getBack().isOk == false then
					childResultNode.status = TestEnum.TestStatus.Failure
					table.insert(childResultNode.errors,
						string.format("%q failed without trying, because test case %q failed",
							childPlanNode.phrase, tryStack:getBack().failedNode.phrase))
				else
					-- Errors can be set either via `error` propagating upwards or
					-- by a test calling fail([message]).
					local success = true
					local errorMessage

					local testEnvironment = getfenv(childPlanNode.callback)

					for key, value in pairs(TestRunner.environment) do
						testEnvironment[key] = value
					end

					testEnvironment.fail = function(message)
						if message == nil then
							message = "fail() was called."
						end

						success = false
						errorMessage = message .. "\n" .. debug.traceback()
					end

					-- We prefer xpcall, but yielding doesn't work from xpcall.
					-- As a workaround, you can mark nodes as "not xpcallable"
					local call = noXpcall and pcall or xpcall

					-- Any code can check RUNNING_GLOBAL to fork behavior based on
					-- whether a test is running. We use this to avoid accessing
					-- protected APIs; it's a workaround that will go away someday.
					_G[RUNNING_GLOBAL] = true

					local nodeSuccess, nodeResult = call(childPlanNode.callback, function(message)
						return message .. "\n" .. debug.traceback()
					end)

					_G[RUNNING_GLOBAL] = nil

					-- If a node threw an error, we prefer to use that message over
					-- one created by fail() if it was set.
					if not nodeSuccess then
						success = false
						errorMessage = nodeResult
					end

					if success then
						childResultNode.status = TestEnum.TestStatus.Success
					else
						childResultNode.status = TestEnum.TestStatus.Failure
						table.insert(childResultNode.errors, errorMessage)
					end
				end
			end
		elseif childPlanNode.type == TestEnum.NodeType.Describe or childPlanNode.type == TestEnum.NodeType.Try then
			if childPlanNode.type == TestEnum.NodeType.Try then tryStack:push({isOk = true, failedNode = nil}) end
			TestRunner.runPlanNode(session, childPlanNode, tryStack, childPlanNode.HACK_NO_XPCALL)
			if childPlanNode.type == TestEnum.NodeType.Try then tryStack:pop() end

			local status = TestEnum.TestStatus.Success

			-- Did we have an error trying build a test plan?
			if childPlanNode.loadError then
				status = TestEnum.TestStatus.Failure

				local message = "Error during planning: " .. childPlanNode.loadError

				table.insert(childResultNode.errors, message)
			else
				local skipped = true

				-- If all children were skipped, then we were skipped
				-- If any child failed, then we failed!
				for _, child in ipairs(childResultNode.children) do
					if child.status ~= TestEnum.TestStatus.Skipped then
						skipped = false

						if child.status == TestEnum.TestStatus.Failure then
							status = TestEnum.TestStatus.Failure
						end
					end
				end

				if skipped then
					status = TestEnum.TestStatus.Skipped
				end
			end

			childResultNode.status = status
		end

		session:popNode()
	end
end

return TestRunner]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3AB4943A7A2644AC87221D2B49E27297">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Expectation</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (type(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is truthy
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called
]]
function Expectation:throw()
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected function to succeed, but it threw an error: %s"):format(
			tostring(err)
		),
		"Expected function to throw an error, but it did not."
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEE09FA0EF4B142849A95FBEAB7278F19">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestPlan</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner and TestPlanBuilder.
]]

local TestEnum = require(script.Parent.TestEnum)

local TestPlan = {}

TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new()
	local self = {
		children = {}
	}

	setmetatable(self, TestPlan)

	return self
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a new node that would be suitable to insert into the TestPlan.
]]
function TestPlan.createNode(phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil
	}

	return node
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.type == TestEnum.NodeType.It then
			table.insert(buffer, (" "):rep(3 * level) .. child.phrase)
		else
			table.insert(buffer, (" "):rep(3 * level) .. child.phrase)
		end

		if #child.children > 0 then
			local text = self:visualize(child, level + 1)
			table.insert(buffer, text)
		end
	end

	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback, results, node)
	node = node or self
	results = results or {}

	for _, childNode in ipairs(node.children) do
		if callback(childNode) then
			table.insert(results, childNode)
		end

		self:findNodes(callback, results, childNode)
	end

	return results
end

return TestPlan]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCC71E1D4A0E0493F87FFC6DF58907C83">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TestPlanBuilder</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Represents the ephermal state used for building a TestPlan from some other
	representation.

	TestPlanBuilder keeps track of a stack of nodes that represents the current
	position in the hierarchy, allowing the consumer to move up and down the
	tree as new nodes are discovered.
]]

local TestPlan = require(script.Parent.TestPlan)

local TestPlanBuilder = {}

TestPlanBuilder.__index = TestPlanBuilder

--[[
	Create a new TestPlanBuilder, used for creating a TestPlan.
]]
function TestPlanBuilder.new()
	local self = {
		plan = TestPlan.new(),
		nodeStack = {},
		noXpcallByDefault = false,
	}

	setmetatable(self, TestPlanBuilder)

	return self
end

--[[
	Verify that the TestPlanBuilder's state is valid and get a TestPlan from it.
]]
function TestPlanBuilder:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize a TestPlan with nodes still on the stack!", 2)
	end

	return self.plan
end

--[[
	Grab the current node being worked on by the TestPlanBuilder.
]]
function TestPlanBuilder:getCurrentNode()
	return self.nodeStack[#self.nodeStack] or self.plan
end

--[[
	Creates and pushes a node onto the navigation stack.
]]
function TestPlanBuilder:pushNode(phrase, nodeType, nodeModifier)
	local lastNode = self.nodeStack[#self.nodeStack] or self.plan

	-- Find an existing node with this phrase to use
	local useNode
	for _, child in ipairs(lastNode.children) do
		if child.phrase == phrase then
			useNode = child
			break
		end
	end

	-- Didn't find one, create a new node
	if not useNode then
		useNode = TestPlan.createNode(phrase, nodeType, nodeModifier)
		useNode.parent = lastNode

		table.insert(lastNode.children, useNode)
	end

	table.insert(self.nodeStack, useNode)

	useNode.HACK_NO_XPCALL = self.noXpcallByDefault

	return useNode
end

--[[
	Pops a node off of the node navigation stack.
]]
function TestPlanBuilder:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	return table.remove(self.nodeStack, #self.nodeStack)
end

return TestPlanBuilder]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXBE535E2493AD47408FFF57B24C01B3A7">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Rodux</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local Store = require(script.Store)
local createReducer = require(script.createReducer)
local combineReducers = require(script.combineReducers)
local loggerMiddleware = require(script.loggerMiddleware)
local thunkMiddleware = require(script.thunkMiddleware)

return {
	Store = Store,
	createReducer = createReducer,
	combineReducers = combineReducers,
	loggerMiddleware = loggerMiddleware.middleware,
	thunkMiddleware = thunkMiddleware,
}
]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX9FF9714A49D941709475CC7A89219CE1">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">loggerMiddleware</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local indent = "    "

local function prettyPrint(value, indentLevel)
	indentLevel = indentLevel or 0
	local output = {}

	if typeof(value) == "table" then
		table.insert(output, "{\n")

		for key, value in pairs(value) do
			table.insert(output, indent:rep(indentLevel + 1))
			table.insert(output, tostring(key))
			table.insert(output, " = ")

			table.insert(output, prettyPrint(value, indentLevel + 1))
			table.insert(output, "\n")
		end

		table.insert(output, indent:rep(indentLevel))
		table.insert(output, "}")
	elseif typeof(value) == "string" then
		table.insert(output, string.format("%q", value))
		table.insert(output, " (string)")
	else
		table.insert(output, tostring(value))
		table.insert(output, " (")
		table.insert(output, typeof(value))
		table.insert(output, ")")
	end

	return table.concat(output, "")
end

-- We want to be able to override outputFunction in tests, so the shape of this
-- module is kind of unconventional.
--
-- We fix it this weird shape in init.lua.
local loggerMiddleware = {
	outputFunction = print,
}

function loggerMiddleware.middleware(nextDispatch, store)
	return function(action)
		local result = nextDispatch(action)

		loggerMiddleware.outputFunction(("Action dispatched: %s\nState changed to: %s"):format(
			prettyPrint(action),
			prettyPrint(store:getState())
		))

		return result
	end
end

return loggerMiddleware
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE7C9E878E8614379BA59A7EFAEB9A284">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signal.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Signal = require(script.Parent.Signal)

	it("should construct from nothing", function()
		local signal = Signal.new()

		expect(signal).to.be.ok()
	end)

	it("should fire connected callbacks", function()
		local callCount = 0
		local value1 = "Hello World"
		local value2 = 7

		local callback = function(arg1, arg2)
			expect(arg1).to.equal(value1)
			expect(arg2).to.equal(value2)
			callCount = callCount + 1
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)

		connection:disconnect()
		signal:fire(value1, value2)

		expect(callCount).to.equal(1)
	end)

	it("should disconnect handlers", function()
		local callback = function()
			error("Callback was called after disconnect!")
		end

		local signal = Signal.new()

		local connection = signal:connect(callback)
		connection:disconnect()

		signal:fire()
	end)

	it("should fire handlers in order", function()
		local signal = Signal.new()
		local x = 0
		local y = 0

		local callback1 = function()
			expect(x).to.equal(0)
			expect(y).to.equal(0)
			x = x + 1
		end

		local callback2 = function()
			expect(x).to.equal(1)
			expect(y).to.equal(0)
			y = y + 1
		end

		signal:connect(callback1)
		signal:connect(callback2)
		signal:fire()

		expect(x).to.equal(1)
		expect(y).to.equal(1)
	end)

	it("should continue firing despite mid-event disconnection", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionA
		connectionA = signal:connect(function()
			connectionA:disconnect()
			countA = countA + 1
		end)

		signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(1)
	end)

	it("should skip listeners that were disconnected during event evaluation", function()
		local signal = Signal.new()
		local countA = 0
		local countB = 0

		local connectionB

		signal:connect(function()
			countA = countA + 1
			connectionB:disconnect()
		end)

		connectionB = signal:connect(function()
			countB = countB + 1
		end)

		signal:fire()

		expect(countA).to.equal(1)
		expect(countB).to.equal(0)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX824EA85DA3EE4A9CB42D8F598D6AE26C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">combineReducers.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local combineReducers = require(script.Parent.combineReducers)

	it("should invoke each sub-reducer for every action", function()
		local aCount = 0
		local bCount = 0

		local reducer = combineReducers({
			a = function(state, action)
				aCount = aCount + 1
			end,
			b = function(state, action)
				bCount = bCount + 1
			end,
		})

		-- Mock reducer invocation
		reducer({}, {})
		expect(aCount).to.equal(1)
		expect(bCount).to.equal(1)
	end)

	it("should assign each sub-reducer's value to the new state", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		local newState = reducer({}, {})
		expect(newState.a).to.equal(1)
		expect(newState.b).to.equal(3)
	end)

	it("should not throw when state is nil", function()
		local reducer = combineReducers({
			a = function(state, action)
				return (state or 0) + 1
			end,
			b = function(state, action)
				return (state or 0) + 3
			end,
		})

		expect(function()
			reducer(nil, {})
		end).to.never.throw()
	end)
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7BEE2980BED94D79B0622D8CDB6A43FD">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Store.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)

	describe("new", function()
		it("should instantiate with a reducer", function()
			local store = Store.new(function(state, action)
				return "hello, world"
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("hello, world")

			store:destruct()
		end)

		it("should instantiate with a reducer and an initial state", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state")

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should instantiate with a reducer, initial state, and middlewares", function()
			local store = Store.new(function(state, action)
				return state
			end, "initial state", {})

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("initial state")

			store:destruct()
		end)

		it("should modify the dispatch method when middlewares are passed", function()
			local middlewareInstantiateCount = 0
			local middlewareInvokeCount = 0
			local passedDispatch
			local passedStore
			local passedAction

			local function reducer(state, action)
				if action.type == "test" then
					return "test state"
				end

				return state
			end

			local function testMiddleware(nextDispatch, store)
				middlewareInstantiateCount = middlewareInstantiateCount + 1
				passedDispatch = nextDispatch
				passedStore = store

				return function(action)
					middlewareInvokeCount = middlewareInvokeCount + 1
					passedAction = action

					nextDispatch(action)
				end
			end

			local store = Store.new(reducer, "initial state", { testMiddleware })

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(0)
			expect(passedDispatch).to.be.a("function")
			expect(passedStore).to.equal(store)

			store:dispatch({
				type = "test",
			})

			expect(middlewareInstantiateCount).to.equal(1)
			expect(middlewareInvokeCount).to.equal(1)
			expect(passedAction.type).to.equal("test")

			store:flush()

			expect(store:getState()).to.equal("test state")

			store:destruct()
		end)

		it("should execute middleware left-to-right", function()
			local events = {}

			local function reducer(state)
				return state
			end

			local function middlewareA(nextDispatch, store)
				table.insert(events, "instantiate a")
				return function(action)
					table.insert(events, "execute a")
					return nextDispatch(action)
				end
			end

			local function middlewareB(nextDispatch, store)
				table.insert(events, "instantiate b")
				return function(action)
					table.insert(events, "execute b")
					return nextDispatch(action)
				end
			end

			local store = Store.new(reducer, 5, { middlewareA, middlewareB })

			expect(#events).to.equal(2)
			expect(events[1]).to.equal("instantiate b")
			expect(events[2]).to.equal("instantiate a")

			store:dispatch({
				type = "test",
			})

			expect(#events).to.equal(4)
			expect(events[3]).to.equal("execute a")
			expect(events[4]).to.equal("execute b")
		end)

		it("should send an initial action with a 'type' field", function()
			local lastAction
			local callCount = 0

			local store = Store.new(function(state, action)
				lastAction = action
				callCount = callCount + 1

				return state
			end)

			expect(callCount).to.equal(1)
			expect(lastAction).to.be.a("table")
			expect(lastAction.type).to.be.ok()

			store:destruct()
		end)
	end)

	describe("getState", function()
		it("should get the current state", function()
			local store = Store.new(function(state, action)
				return "foo"
			end)

			local state = store:getState()

			expect(state).to.equal("foo")

			store:destruct()
		end)
	end)

	describe("dispatch", function()
		it("should be sent through the reducer", function()
			local store = Store.new(function(state, action)
				state = state or "foo"

				if action.type == "act" then
					return "bar"
				end

				return state
			end)

			expect(store).to.be.ok()
			expect(store:getState()).to.equal("foo")

			store:dispatch({
				type = "act",
			})

			store:flush()

			expect(store:getState()).to.equal("bar")

			store:destruct()
		end)

		it("should trigger the changed event after a flush", function()
			local store = Store.new(function(state, action)
				state = state or 0

				if action.type == "increment" then
					return state + 1
				end

				return state
			end)

			local callCount = 0

			store.changed:connect(function(state, oldState)
				expect(oldState).to.equal(0)
				expect(state).to.equal(1)

				callCount = callCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			store:flush()

			expect(callCount).to.equal(1)

			store:destruct()
		end)

		it("should handle actions dispatched within the changed event", function()
			local store = Store.new(function(state, action)
				state = state or {
					value = 0,
				}

				if action.type == "increment" then
					return {
						value = state.value + 1,
					}
				elseif action.type == "decrement" then
					return {
						value = state.value - 1,
					}
				end

				return state
			end)

			local changeCount = 0

			store.changed:connect(function(state, oldState)
				expect(state).never.to.equal(oldState)

				if state.value > 0 then
					store:dispatch({
						type = "decrement",
					})
				end

				changeCount = changeCount + 1
			end)

			store:dispatch({
				type = "increment",
			})
			store:flush()
			store:flush()

			expect(changeCount).to.equal(2)

			store:destruct()
		end)

		it("should prevent yielding from changed handler", function()
			local preCount = 0
			local postCount = 0

			local store = Store.new(function(state, action)
				state = state or 0
				return state + 1
			end)

			store.changed:connect(function(state, oldState)
				preCount = preCount + 1
				wait()
				postCount = postCount + 1
			end)

			store:dispatch({
				type = "increment",
			})

			expect(function()
				store:flush()
			end).to.throw()

			expect(preCount).to.equal(1)
			expect(postCount).to.equal(0)

			store:destruct()
		end)

		it("should throw if an action is dispatched without a type field", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch({})
			end).to.throw()

			store:destruct()
		end)

		it("should throw if the action is not a function or table", function()
			local store = Store.new(function(state, action)
				return state
			end)

			expect(function()
				store:dispatch(1)
			end).to.throw()

			store:destruct()
		end)
	end)

	describe("flush", function()
		it("should not fire a changed event if there were no dispatches", function()
			local store = Store.new(function()
			end)

			local count = 0
			store.changed:connect(function()
				count = count + 1
			end)

			store:flush()

			expect(count).to.equal(0)

			store:dispatch({
				type = "increment",
			})
			store:flush()

			expect(count).to.equal(1)

			store:flush()

			expect(count).to.equal(1)

			store:destruct()
		end)
	end)
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4FB1636E722C49ACA686718CF635DEA0">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">thunkMiddleware.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local thunkMiddleware = require(script.Parent.thunkMiddleware)

	it("should dispatch thunks", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkCount = 0

		local function thunk(store)
			thunkCount = thunkCount + 1
		end

		store:dispatch(thunk)

		expect(thunkCount).to.equal(1)
	end)

	it("should allow normal actions to pass through", function()
		local reducerCount = 0

		local function reducer(state, action)
			reducerCount = reducerCount + 1
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })

		store:dispatch({
			type = "test",
		})

		-- Reducer will be invoked twice:
		-- Once when creating the store (@@INIT action)
		-- Once when the test action is dispatched
		expect(reducerCount).to.equal(2)
	end)

	it("should return the value from the thunk", function()
		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {}, { thunkMiddleware })
		local thunkValue = "test"

		local function thunk(store)
			return thunkValue
		end

		local result = store:dispatch(thunk)

		expect(result).to.equal(thunkValue)
	end)
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4CD1B11179004BF7A4B9A925AFF7DBF6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReducer.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local createReducer = require(script.Parent.createReducer)

	it("should handle actions", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		}, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer({
			a = 0,
			b = 0,
		}, {
			type = "a",
		})

		expect(newState.a).to.equal(1)

		newState = reducer(newState, {
			type = "b",
		})

		expect(newState.b).to.equal(2)
	end)

	it("should return the initial state if the state is nil", function()
		local reducer = createReducer({
			a = 0,
			b = 0,
		-- We don't care about the actions here
		}, {})

		local newState = reducer(nil, {})
		expect(newState).to.be.ok()
		expect(newState.a).to.equal(0)
		expect(newState.b).to.equal(0)
	end)

	it("should still run action handlers if the state is nil", function()
		local callCount = 0

		local reducer = createReducer(0, {
			foo = function(state, action)
				callCount = callCount + 1
				return nil
			end
		})

		expect(callCount).to.equal(0)

		local newState = reducer(nil, {
			type = "foo",
		})

		expect(callCount).to.equal(1)
		expect(newState).to.equal(nil)

		newState = reducer(newState, {
			type = "foo",
		})

		expect(callCount).to.equal(2)
		expect(newState).to.equal(nil)
	end)

	it("should return the same state if the action is not handled", function()
		local initialState = {
			a = 0,
			b = 0,
		}

		local reducer = createReducer(initialState, {
			a = function(state, action)
				return {
					a = state.a + 1,
					b = state.b,
				}
			end,
			b = function(state, action)
				return {
					a = state.a,
					b = state.b + 2,
				}
			end,
		})

		local newState = reducer(initialState, {
			type = "c",
		})

		expect(newState).to.equal(initialState)
	end)
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX088303CE564444C5805DC0855552118F">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">thunkMiddleware</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	A middleware that allows for functions to be dispatched.
	Functions will receive a single argument, the store itself.
	This middleware consumes the function; middleware further down the chain
	will not receive it.
]]
local function thunkMiddleware(nextDispatch, store)
	return function(action)
		if typeof(action) == "function" then
			return action(store)
		else
			return nextDispatch(action)
		end
	end
end

return thunkMiddleware
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX255A5B82CF9D4FF2950A6DC57D357155">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NoYield</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Calls a function and throws an error if it attempts to yield.

	Pass any number of arguments to the function after the callback.

	This function supports multiple return; all results returned from the
	given function will be returned.
]]

local function resultHandler(co, ok, ...)
	if not ok then
		local message = (...)
		error(debug.traceback(co, message), 2)
	end

	if coroutine.status(co) ~= "dead" then
		error(debug.traceback(co, "Attempted to yield inside changed event!"), 2)
	end

	return ...
end

local function NoYield(callback, ...)
	local co = coroutine.create(callback)

	return resultHandler(co, coroutine.resume(co, ...))
end

return NoYield]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC1A22547D26C472FA8CB94B1627B1CBB">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">createReducer</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function(initialState, handlers)
	return function(state, action)
		if state == nil then
			state = initialState
		end

		local handler = handlers[action.type]

		if handler then
			return handler(state, action)
		end

		return state
	end
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX224D048A89C5437EA726744EDF53DD77">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">combineReducers</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	Create a composite reducer from a map of keys and sub-reducers.
]]
local function combineReducers(map)
	return function(state, action)
		-- If state is nil, substitute it with a blank table.
		if state == nil then
			state = {}
		end

		local newState = {}

		for key, reducer in pairs(map) do
			-- Each reducer gets its own state, not the entire state table
			newState[key] = reducer(state[key], action)
		end

		return newState
	end
end

return combineReducers
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB9DBD078F07E4CD48BAF239377E70D1B">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Signal</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[--[[
	A limited, simple implementation of a Signal.

	Handlers are fired in order, and (dis)connections are properly handled when
	executing an event.
]]

local function immutableAppend(list, ...)
	local new = {}
	local len = #list

	for key = 1, len do
		new[key] = list[key]
	end

	for i = 1, select("#", ...) do
		new[len + i] = select(i, ...)
	end

	return new
end

local function immutableRemoveValue(list, removeValue)
	local new = {}

	for i = 1, #list do
		if list[i] ~= removeValue then
			table.insert(new, list[i])
		end
	end

	return new
end

local Signal = {}

Signal.__index = Signal

function Signal.new()
	local self = {
		_listeners = {}
	}

	setmetatable(self, Signal)

	return self
end

function Signal:connect(callback)
	local listener = {
		callback = callback,
		disconnected = false,
	}

	self._listeners = immutableAppend(self._listeners, listener)

	local function disconnect()
		listener.disconnected = true
		self._listeners = immutableRemoveValue(self._listeners, listener)
	end

	return {
		disconnect = disconnect
	}
end

function Signal:fire(...)
	for _, listener in ipairs(self._listeners) do
		if not listener.disconnected then
			listener.callback(...)
		end
	end
end

return Signal]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8BA0DE6A527F46ABA243953D3DD29657">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Store</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)
local NoYield = require(script.Parent.NoYield)

local Store = {}

-- This value is exposed as a private value so that the test code can stay in
-- sync with what event we listen to for dispatching the Changed event.
-- It may not be Heartbeat in the future.
Store._flushEvent = RunService.Heartbeat

Store.__index = Store

--[[
	Create a new Store whose state is transformed by the given reducer function.

	Each time an action is dispatched to the store, the new state of the store
	is given by:

		state = reducer(state, action)

	Reducers do not mutate the state object, so the original state is still
	valid.
]]
function Store.new(reducer, initialState, middlewares)
	assert(typeof(reducer) == "function", "Bad argument #1 to Store.new, expected function.")
	assert(middlewares == nil or typeof(middlewares) == "table", "Bad argument #3 to Store.new, expected nil or table.")

	local self = {}

	self._reducer = reducer
	self._state = reducer(initialState, {
		type = "@@INIT",
	})
	self._lastState = self._state

	self._mutatedSinceFlush = false
	self._connections = {}

	self.changed = Signal.new()

	setmetatable(self, Store)

	local connection = self._flushEvent:Connect(function()
		self:flush()
	end)
	table.insert(self._connections, connection)

	if middlewares then
		local unboundDispatch = self.dispatch
		local dispatch = function(...)
			return unboundDispatch(self, ...)
		end

		for i = #middlewares, 1, -1 do
			local middleware = middlewares[i]
			dispatch = middleware(dispatch, self)
		end

		self.dispatch = function(self, ...)
			return dispatch(...)
		end
	end

	return self
end

--[[
	Get the current state of the Store. Do not mutate this!
]]
function Store:getState()
	return self._state
end

--[[
	Dispatch an action to the store. This allows the store's reducer to mutate
	the state of the application by creating a new copy of the state.

	Listeners on the changed event of the store are notified when the state
	changes, but not necessarily on every Dispatch.
]]
function Store:dispatch(action)
	if typeof(action) == "table" then
		if action.type == nil then
			error("action does not have a type field", 2)
		end

		self._state = self._reducer(self._state, action)
		self._mutatedSinceFlush = true
	else
		error(("actions of type %q are not permitted"):format(typeof(action)), 2)
	end
end

--[[
	Marks the store as deleted, disconnecting any outstanding connections.
]]
function Store:destruct()
	for _, connection in ipairs(self._connections) do
		connection:Disconnect()
	end

	self._connections = nil
end

--[[
	Flush all pending actions since the last change event was dispatched.
]]
function Store:flush()
	if not self._mutatedSinceFlush then
		return
	end

	self._mutatedSinceFlush = false

	-- On self.changed:fire(), further actions may be immediately dispatched, in
	-- which case self._lastState will be set to the most recent self._state,
	-- unless we cache this value first
	local state = self._state

	-- If a changed listener yields, *very* surprising bugs can ensue.
	-- Because of that, changed listeners cannot yield.
	NoYield(function()
		self.changed:fire(state, self._lastState)
	end)

	self._lastState = state
end

return Store
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8C78A656B0784A498A1083DA235AD28E">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">loggerMiddleware.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local Store = require(script.Parent.Store)
	local loggerMiddleware = require(script.Parent.loggerMiddleware)

	it("should print whenever an action is dispatched", function()
		local outputCount = 0
		local outputMessage

		local function reducer(state, action)
			return state
		end

		local store = Store.new(reducer, {
			fooValue = 12345,
			barValue = {
				bazValue = "hiBaz",
			},
		}, { loggerMiddleware.middleware })

		loggerMiddleware.outputFunction = function(message)
			outputCount = outputCount + 1
			outputMessage = message
		end

		store:dispatch({
			type = "testActionType",
		})

		expect(outputCount).to.equal(1)
		expect(outputMessage:find("testActionType")).to.be.ok()
		expect(outputMessage:find("fooValue")).to.be.ok()
		expect(outputMessage:find("12345")).to.be.ok()
		expect(outputMessage:find("barValue")).to.be.ok()
		expect(outputMessage:find("bazValue")).to.be.ok()
		expect(outputMessage:find("hiBaz")).to.be.ok()

		loggerMiddleware.outputFunction = print
	end)
end
]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX6CB69ECA745A42299B51230D5D26BF20">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	describe("Rodux", function()
		it("should load", function()
			local Rodux = require(script.Parent)

			expect(Rodux.Store).to.be.ok()
		end)
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX04F302EA0D984BF1A3C3502BD30EEAB7">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NoYield.spec</string>
					<string name="ScriptGuid"></string>
					<ProtectedString name="Source"><![CDATA[return function()
	local NoYield = require(script.Parent.NoYield)

	it("should call functions normally", function()
		local callCount = 0

		local function test(a, b)
			expect(a).to.equal(5)
			expect(b).to.equal(6)

			callCount = callCount + 1

			return 11, "hello"
		end

		local a, b = NoYield(test, 5, 6)

		expect(a).to.equal(11)
		expect(b).to.equal("hello")
	end)

	it("should throw on yield", function()
		local preCount = 0
		local postCount = 0

		local function testMethod()
			preCount = preCount + 1
			wait()
			postCount = postCount + 1
		end

		local ok, err = pcall(NoYield, testMethod)

		expect(preCount).to.equal(1)
		expect(postCount).to.equal(0)

		expect(ok).to.equal(false)
		expect(err:find("wait")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)

	it("should propagate error messages", function()
		local count = 0

		local function test()
			count = count + 1
			error("foo")
		end

		local ok, err = pcall(NoYield, test)

		expect(ok).to.equal(false)
		expect(err:find("foo")).to.be.ok()
		expect(err:find("NoYield.spec")).to.be.ok()
	end)
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>