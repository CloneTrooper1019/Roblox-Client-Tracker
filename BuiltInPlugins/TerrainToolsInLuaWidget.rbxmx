<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXa23d4d83aabd410dbb9bbeb7f0a0ccc7">
		<Properties>
			<string name="Name">TerrainToolPlugin</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXaa2e215aa48941478ada4afad123eb20">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TerrainBrush</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Stickmasterluke

local module = {}

GuiUtilities = require(script.Parent.GuiUtilities)
CollapsibleTitledSection = require(script.Parent.CollapsibleTitledSection)
VerticallyScalingListFrame = require(script.Parent.VerticallyScalingListFrame)
MaterialsListClass = require(script.Parent.MaterialsList)
LabeledCheckbox = require(script.Parent.LabeledCheckbox)
LabeledSlider = require(script.Parent.LabeledSlider)

local on
local kCurrentTool
local plugin
local pluginGui 
local kMaterialsListObject = nil

-- FIXME(dbanks)
-- Clean this up, ugly globals.
local kSizeSliderObj = nil
local kStrengthSliderObj = nil
local kMinSelectionSize = 1
local kMaxSelectionSize = 16
local kSelectionSize = 6
local kStrength = .5

local kShapeButtonRowHeight = 50

local function MakeShapeButtonsRow()
	local row = GuiUtilities.MakeFixedHeightFrame("ShapeButtonRow", kShapeButtonRowHeight)

	local shapeLabel = GuiUtilities.MakeStandardPropertyLabel("Shape") 
	shapeLabel.Parent = row
	shapeLabel.AnchorPoint = Vector2.new(0, 0.5)
	shapeLabel.Position = UDim2.new(0, GuiUtilities.StandardLineLabelLeftMargin, 0, kShapeButtonRowHeight/2)

	local shapeButton1 = GuiUtilities.MakeShapeButton("ShapeButton1", 
		"http://www.roblox.com/asset/?id=225799533", 
		row)
	shapeButton1.AnchorPoint = Vector2.new(0, 0.5)
	shapeButton1.Position = UDim2.new(0, GuiUtilities.StandardLineElementLeftMargin, 0, kShapeButtonRowHeight/2)

	local shapeButton2 = GuiUtilities.MakeShapeButton("ShapeButton2", 
		"http://www.roblox.com/asset/?id=225799696", 
		row)
	shapeButton2.AnchorPoint = Vector2.new(0, 0.5)
	shapeButton2.Position = UDim2.new(0, GuiUtilities.StandardLineElementLeftMargin + GuiUtilities.kShapeButtonSize + GuiUtilities.kStandardHMargin, 
		0, kShapeButtonRowHeight/2)

	return row
end

local function MakeMaterialsSectionWithTitle()
	local vsl = VerticallyScalingListFrame.new("mwt")

	local titleLabel = GuiUtilities.MakeFrameWithSubSectionLabel("Material", "Material")
	vsl:AddChild(titleLabel)

	kMaterialsListObject = MaterialsListClass.new()
	local materialsFrame = kMaterialsListObject:GetMaterialsFrame()
	vsl:AddChild(materialsFrame)

	return vsl:GetFrame()
end

module.FirstTimeSetup = function(theMouse, thePluginGui, theContentFrame)
	mouse = theMouse
	pluginGui = thePluginGui
	contentFrame = theContentFrame
	local changeHistory = game:GetService('ChangeHistoryService')
	local terrain = game.Workspace.Terrain
	local coreGui = game:GetService("CoreGui")
	
	local screenGui = Instance.new("ScreenGui") 
	screenGui.Name = "TerrainBrushGui"

	-- Create top level container.  
	-- It has no title bar.
	local verticallyScalingListFrameObj = VerticallyScalingListFrame.new("BrushFrame")
	local verticallyScalingListFrame = verticallyScalingListFrameObj:GetFrame()
	verticallyScalingListFrame.Parent = contentFrame
	verticallyScalingListFrame.Visible = false

	-- Top level container has 3 collapsible sections:
	-- 1) Brush Settings.
	local brushSettingsObj = CollapsibleTitledSection.new('BrushSettings', 
		'Brush Settings', 
		true, 
		true)
	GuiUtilities.MakeFrameAutoScalingList(brushSettingsObj:GetContentsFrame())

	kSizeSliderObj = LabeledSlider.new("Size", "Size", kMaxSelectionSize, kSelectionSize)
	local sizeSliderRow =kSizeSliderObj:GetFrame()

	kStrengthSliderObj = LabeledSlider.new("Strength", "Strength", 101, kStrength*100)
	local strengthSliderRow = kStrengthSliderObj:GetFrame()

	local shapeButtonsRow = MakeShapeButtonsRow()

	GuiUtilities.AddStripedChildrenToListFrame(brushSettingsObj:GetContentsFrame(), 
		{sizeSliderRow, strengthSliderRow, shapeButtonsRow})
	
	verticallyScalingListFrameObj:AddChild(brushSettingsObj:GetSectionFrame())

	-- 2) Materials Settings.	
	local materialSettingsObj = CollapsibleTitledSection.new("MaterialSettings", 
		"Material Settings",
		true, 
		true)
	GuiUtilities.MakeFrameAutoScalingList(materialSettingsObj:GetContentsFrame())

	local autoColorObj= LabeledCheckbox.new("Auto", 'Auto')

	local materialSectionWithTitle = MakeMaterialsSectionWithTitle()

	GuiUtilities.AddStripedChildrenToListFrame(materialSettingsObj:GetContentsFrame(), 
		{autoColorObj:GetFrame(), materialSectionWithTitle})
		
	verticallyScalingListFrameObj:AddChild(materialSettingsObj:GetSectionFrame())

	-- 3) Advanced settings.
	local advancedSettingsObj = CollapsibleTitledSection.new("AdvancedSettings", 
		"Advanced",
		true, 
		true)
	GuiUtilities.MakeFrameAutoScalingList(advancedSettingsObj:GetContentsFrame())

	local planeLockObj = LabeledCheckbox.new("PLock", 'Plane Lock')
	local snapToGridObj = LabeledCheckbox.new("STG", 'Snap to Grid')
	local ignoreWaterObj = LabeledCheckbox.new("IGW", 'Ignore Water')
	planeLockObj:SetValueChangedFunction(function(value)
		if not planeLockObj:GetValue() then
			clearGrid()
		end
	end)

	GuiUtilities.AddStripedChildrenToListFrame(advancedSettingsObj:GetContentsFrame(), 
		{planeLockObj:GetFrame(), 
		 snapToGridObj:GetFrame(),
		 ignoreWaterObj:GetFrame()})

	verticallyScalingListFrameObj:AddChild(advancedSettingsObj:GetSectionFrame())





	local userInput = game:GetService('UserInputService')
	local prevCameraType = game.Workspace.CurrentCamera.CameraType

	--SUB SETTINGS--	(Non-userfacing Settings)
	local resolution = 4			--This is the size of voxels on Roblox. Why is this a variable? ;)
	local clickThreshold = .1
	local toolTipShowTime = 3.5
	local materialsTable = MaterialsListClass.MaterialsTable
	local brushShapes = {
		['Sphere'] = {
			name = 'Sphere',
			button = shapeButtonsRow.ShapeButton1,
			image = 'http://www.roblox.com/asset/?id=225799533',
			selectedImage = 'http://www.roblox.com/asset/?id=225801914',
		},
		['Box'] = {
			name = 'Box',
			button = shapeButtonsRow.ShapeButton2,
			image = 'http://www.roblox.com/asset/?id=225799696',
			selectedImage = 'http://www.roblox.com/asset/?id=225802254',
		},
	}
	----------------

	----SETTINGS----	(Interface Settings)
	local brushShape = 'Sphere'
	----------------

	----Variables----
	local forceMaterial = nil
	local nearMaterial = nil
	local selectionPart = nil
	local selectionObject = nil
	local gridLineParts = {}
	local currentLoopTag = nil
	local lastMainPoint = Vector3.new(0, 0, 0)
	local click = false
	local firstOperation = tick()
	local downKeys = {}
	local lastPlanePoint = Vector3.new(0, 0, 0)
	local lastNormal = Vector3.new(0, 1, 0)
	local lastCursorDistance = 300
	local one256th = 1/256							--This should later be replaced with 0 once smooth terrain doesn't aproximate 1/256 to 0. This is causing small occupancies to become air
	local toolTip1Change = nil
	local toolTip2Change = nil
	local materialAir = Enum.Material.Air
	local materialWater = Enum.Material.Water
	local ceil = math.ceil
	local floor = math.floor
	local abs = math.abs
	local min = math.min
	local max = math.max
	local sqrt = math.sqrt
	local sin = math.sin
	local cos = math.cos
	local pi = math.pi
	
	---------------
	
	kSizeSliderObj:SetValueChangedFunction(function(newValue)
		kSelectionSize = newValue
		if selectionPart then
			selectionPart.Size = Vector3.new(1, 1, 1) * kSelectionSize * resolution + Vector3.new(.1, .1, .1)
		end
	end)

	kStrengthSliderObj:SetValueChangedFunction(function(newValue)
		kStrength = (newValue - 1) / 100
		if selectionObject then
			selectionObject.SurfaceTransparency = .95 - kStrength * .3
		end
	end)

	function setBrushShape(newBrushShape)
		brushShape = newBrushShape
		for _,v in pairs(brushShapes) do
			--v.button.Image = (newBrushShape == v) and v.selectedImage or v.image
			v.button.ImageTransparency = (newBrushShape == v.name) and 0 or .5
			v.button.ImageColor3 = (newBrushShape == v.name) and Color3.new(1,1,1) or Color3.new(.5,.5,.5)
		end
		clearSelection()
	end
	for _,v in pairs(brushShapes) do
		v.button.MouseButton1Down:connect(function()
			setBrushShape(v.name)
		end)
	end

	local function updateUsabilityLocks()
		if kCurrentTool then
			-- If the kCurrentTool uses materials, and the material selected, then force SnapToGrid to true.
			snapToGridObj:SetDisabled(kCurrentTool.UsesMaterials and kMaterialsListObject:GetCurrentMaterialSelection().forceSnapToGrid)
			if snapToGridObj:GetDisabled() then
				snapToGridObj:SetValue(true)
			end
	
			-- If the kCurrentTool as Add or Subtract then force planeLock for usability
			planeLockObj:SetDisabled(kCurrentTool.Name == 'Add' or kCurrentTool.Name == 'Subtract')
			if planeLockObj:GetDisabled() then
				planeLockObj:SetValue(true)
			end
	
			--
			autoColorObj:SetDisabled(kCurrentTool.Name == 'Subtract' or kCurrentTool.Name == 'Erode' or kCurrentTool.Name == 'Paint' or kCurrentTool.Name == 'Smooth' or kCurrentTool.Name == 'Smoother')
			if autoColorObj:GetDisabled() then
				autoColorObj:SetValue(kCurrentTool.Name ~= 'Paint')
			end
	
			--
			ignoreWaterObj:SetDisabled((kMaterialsListObject:GetCurrentMaterialSelection().forceIgnoreWater and not autoColorObj:GetValue()) or kCurrentTool.Name == 'Smooth')
			if ignoreWaterObj:GetDisabled() then
				if kCurrentTool.Name == 'Smooth' then
					ignoreWaterObj:SetValue(false)
				else
					ignoreWaterObj:SetValue(kMaterialsListObject:GetCurrentMaterialSelection().forceIgnoreWaterTo)
				end
			end
	
			autoColorObj:GetFrame().Visible = kCurrentTool.UsesMaterials
			materialSettingsObj:GetSectionFrame().Visible = not not kCurrentTool.UsesMaterials
		end
	end

	kMaterialsListObject:SetCallbackOnSelectionChanged(updateUsabilityLocks)

	-------------

	do
		local runService = game:GetService('RunService').RenderStepped
		function quickWait(waitTime)
			if not waitTime then
				runService:wait()
			elseif waitTime < .033333 then
				local startTick = tick()
				runService:wait()
				local delta = tick() - startTick
				if delta <= waitTime * .5 then
					quickWait(waitTime - delta)
				end
			else
				wait(waitTime)
			end
		end
	end

	function deepCast(origin, endPoint, ignoreList, filterFunction, cubeTerrain)
		local ray = Ray.new(origin, endPoint - origin)
		local hit, pos, normal, material = game.Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, cubeTerrain)
		if hit and filterFunction(hit) then
			table.insert(ignoreList, hit)
			return deepCast(pos, endPoint, ignoreList, filterFunction, cubeTerrain)
		else
			return hit, pos, normal, material
		end
	end

	function clearSelection()
		if selectionObject then
			selectionObject:Destroy()
			selectionObject = nil
		end
		if selectionPart then
			selectionPart:Destroy()
			selectionPart = nil
		end
	end

	function clearGrid()
		for i, v in pairs(gridLineParts) do
			if v then
				v:Destroy()
			end
			gridLineParts[i] = nil
		end
	end

	function drawGrid(point, normal, transparency, color)
		local transparency = transparency or .95
		local color = BrickColor.new(color or 'Institutional white')--'Pastel light blue')
		local gridCellSize = kSelectionSize * resolution
		local gridSize = 10
		local baseCframe = CFrame.new(point, point + normal)
		local normalSpase = CFrame.new(Vector3.new(0, 0, 0), normal):pointToObjectSpace(point)
		local roundedNormalOffset = (Vector3.new((normalSpase.x / gridCellSize) % 1, (normalSpase.y / gridCellSize) % 1, 0) - Vector3.new(.5, .5, 0)) * -gridCellSize
		for u = 1, gridSize do
			local linePart = gridLineParts[u]
			if not linePart then
				linePart = Instance.new('Part')
				linePart.Transparency = 1
				linePart.TopSurface = 'Smooth'
				linePart.BottomSurface = 'Smooth'
				linePart.Anchored = true
				linePart.CanCollide = false
				local selectionBox = Instance.new('SelectionBox')
				selectionBox.Color = color
				selectionBox.Transparency = transparency
				selectionBox.Adornee = linePart
				selectionBox.Parent = linePart
				linePart.Parent = screenGui
				gridLineParts[u] = linePart
			elseif linePart.SelectionBox.Transparency ~= transparency or linePart.SelectionBox.Color ~= color then
				linePart.SelectionBox.Transparency = transparency
				linePart.SelectionBox.Color = color
			end
			local percent = (u - 1) / (gridSize - 1)
			linePart.Size = Vector3.new(gridCellSize * gridSize * sin(math.acos(percent * 1.8 - .9)), 0, 0)
			linePart.CFrame = baseCframe * CFrame.new(0, (percent - .5) * (gridSize - 1) * gridCellSize, 0) * CFrame.new(roundedNormalOffset)
		end
		for u = 1, gridSize do
			local linePart = gridLineParts[gridSize + u]
			if not linePart then
				linePart = Instance.new('Part')
				linePart.Transparency = 1
				linePart.TopSurface = 'Smooth'
				linePart.BottomSurface = 'Smooth'
				linePart.Anchored = true
				linePart.CanCollide = false
				local selectionBox = Instance.new('SelectionBox')
				selectionBox.Color = color
				selectionBox.Transparency = transparency
				selectionBox.Adornee = linePart
				selectionBox.Parent = linePart
				linePart.Parent = screenGui
				gridLineParts[gridSize + u] = linePart
			elseif linePart.SelectionBox.Transparency ~= transparency or linePart.SelectionBox.Color ~= color then
				linePart.SelectionBox.Transparency = transparency
				linePart.SelectionBox.Color = color
			end
			local percent = (u - 1) / (gridSize - 1)
			linePart.Size = Vector3.new(0, gridCellSize * gridSize * sin(math.acos(percent * 1.8 - .9)), 0)
			linePart.CFrame = baseCframe * CFrame.new((percent - .5) * (gridSize - 1) * gridCellSize, 0, 0) * CFrame.new(roundedNormalOffset)
		end
	end

	local function getCell(list, x, y, z, materialList)
		-- only include materialsList if you want to ignore water
		return (materialList and materialList[x] and materialList[x][y] and materialList[x][y][z]) == materialWater and 0
				or list and list[x] and list[x][y] and list[x][y][z]
	end

	local function getNeighborOccupancies(list, x, y, z, materialsList, includeSelf)
		--only include materialsList if you want to ignore water
		local fullNeighbor = false
		local emptyNeighbor = false
		local neighborOccupancies = includeSelf and getCell(list, x, y, z, materialsList) or 0
		local totalNeighbors = includeSelf and 1 or 0
		local nearMaterial = kMaterialsListObject:GetCurrentMaterialSelection().enum
		for axis = 1, 3 do
			for offset = -1, 1, 2 do
				local neighbor = nil
				local neighborMaterial = nil
				if axis == 1 then
					neighbor = list[x + offset] and list[x + offset][y][z]
				elseif axis == 2 then
					neighbor = list[x][y + offset] and list[x][y + offset][z]
				elseif axis == 3 then
					neighbor = list[x][y][z + offset]
				end
				if neighbor then
					if materialsList then
						if axis == 1 then
							neighborMaterial = materialsList[x + offset] and materialsList[x + offset][y][z]
						elseif axis == 2 then
							neighborMaterial = materialsList[x][y + offset] and materialsList[x][y + offset][z]
						elseif axis == 3 then
							neighborMaterial = materialsList[x][y][z + offset]
						end
						if neighborMaterial == materialWater then
							neighbor = 0
						end
					end
					if neighbor >= 1 then
						fullNeighbor = true
					end
					if neighbor <= 0 then
						emptyNeighbor = true
					end
					totalNeighbors = totalNeighbors + 1
					neighborOccupancies = neighborOccupancies + neighbor
				end
			end
		end
		return neighborOccupancies / (totalNeighbors ~= 0 and totalNeighbors or getCell(list, x, y, z, materialsList)), fullNeighbor, emptyNeighbor
	end

	local function round(n)
		return floor(n + .5)
	end

	function findFace()
		local cameraLookVector = game.Workspace.CurrentCamera.CoordinateFrame.lookVector
		--[[local absx = abs(cameraLookVector.x)		--this code is for 90 plane locking
		local absy = abs(cameraLookVector.y)
		local absz = abs(cameraLookVector.z)
		if absy >= absx and absy >= absz then	--preference towards y axis planes
			return Vector3.new(0, cameraLookVector.y / absy, 0)
		elseif absx >= absz then
			return	Vector3.new(cameraLookVector.x / absx, 0, 0)
		end
		return Vector3.new(0, 0, cameraLookVector.z / absz)]]

		return Vector3.new(round(cameraLookVector.x), round(cameraLookVector.y), round(cameraLookVector.z)).unit	--this code is for 45 degree plane locking
	end

	function lineToPlaneIntersection(linePoint, lineDirection, planePoint, planeNormal)
		local denominator = lineDirection:Dot(planeNormal)
		if denominator == 0 then
			return linePoint
		end
		local distance = ((planePoint - linePoint):Dot(planeNormal)) / denominator
		return linePoint + lineDirection * distance
	end

	function operation(centerPoint)
		local desiredMaterial = autoColorObj:GetValue() and nearMaterial or kMaterialsListObject:GetCurrentMaterialSelection().enum

		local radius = kSelectionSize * .5 * resolution
		local minBounds = Vector3.new(
			floor((centerPoint.x - radius) / resolution) * resolution,
			floor((centerPoint.y - radius) / resolution) * resolution,
			floor((centerPoint.z - radius) / resolution) * resolution)
		local maxBounds = Vector3.new(
			ceil((centerPoint.x + radius) / resolution) * resolution,
			ceil((centerPoint.y + radius) / resolution) * resolution,
			ceil((centerPoint.z + radius) / resolution) * resolution)
		local region = Region3.new(minBounds, maxBounds)

		local materials, occupancies = terrain:ReadVoxels(region, resolution)
		local toolBrushOperation = nil
		for _, toolModule in pairs(kCurrentTool.Modules) do
			if toolModule.BrushOperation then
				toolBrushOperation = toolModule.BrushOperation
				break
			end
		end
		if toolBrushOperation then
			local middle = materials[ceil(#materials * .5)]	--This little section of code sets nearMaterial to middle of matrix
			if middle then	--dig X
				local middle = middle[ceil(#middle * .5)]
				if middle then	--dig Y
					local middle = middle[ceil(#middle * .5)]
					if middle and middle ~= materialAir and middle ~= materialWater then	--dig Z
						nearMaterial = middle
						desiredMaterial = autoColorObj:GetValue() and nearMaterial or desiredMaterial
					end
				end
			end

			toolBrushOperation(centerPoint, materials, occupancies, resolution, kSelectionSize, kStrength, desiredMaterial, brushShape, minBounds, maxBounds)
		else
			local airFillerMaterial = materialAir
			local waterHeight = 0
			if ignoreWaterObj:GetValue() and (kCurrentTool.Name == 'Erode' or kCurrentTool.Name == 'Subtract') then
				--[[local centerPointCell = Vector3.new(floor((centerPoint.x+.5)/resolution) * resolution, floor((centerPoint.y+.5)/resolution) * resolution, floor((centerPoint.z+.5)/resolution) * resolution)
				local sampleRegion = Region3.new(centerPointCell - Vector3.new(resolution,resolution,resolution), centerPointCell + Vector3.new(resolution,resolution,resolution))
				local sampleMaterials, sampleOccupancies = terrain:ReadVoxels(sampleRegion, resolution)]]
				
				for ix,vx in ipairs(materials) do
					for iy,vy in ipairs(vx) do
						for iz, vz in ipairs(vy) do
							if vz == materialWater then
								airFillerMaterial = materialWater
								if iy > waterHeight then
									waterHeight = iy
								end
							end
						end
					end
				end
			end

			for ix, vx in ipairs(occupancies) do
				local cellVectorX = minBounds.x + (ix - .5) * resolution - centerPoint.x

				for iy, vy in pairs(vx) do
					local cellVectorY = minBounds.y + (iy - .5) * resolution - centerPoint.y

					for iz, cellOccupancy in pairs(vy) do
						local cellVectorZ = minBounds.z + (iz - .5) * resolution - centerPoint.z

						local cellMaterial = materials[ix][iy][iz]
						local distance = sqrt(cellVectorX * cellVectorX + cellVectorY * cellVectorY + cellVectorZ * cellVectorZ)
	
						local magnitudePercent = 1
						local brushOccupancy = 1
						if brushShape == 'Sphere' then
							magnitudePercent = cos(min(1, distance / (radius + resolution * .5)) * pi * .5)
							brushOccupancy = max(0, min(1, (radius + .5 * resolution - distance) / resolution))
						elseif brushShape == 'Box' then
							if not snapToGridObj:GetValue() then
								local xOutside = 1 - max(0, abs(cellVectorX / resolution) + .5 - kSelectionSize * .5)
								local yOutside = 1 - max(0, abs(cellVectorY / resolution) + .5 - kSelectionSize * .5)
								local zOutside = 1 - max(0, abs(cellVectorZ / resolution) + .5 - kSelectionSize * .5)
								brushOccupancy = xOutside * yOutside * zOutside
							end
						end

						if cellMaterial ~= materialAir and cellMaterial ~= materialWater and cellMaterial ~= nearMaterial then
							nearMaterial = cellMaterial
							if autoColorObj:GetValue() then
								desiredMaterial = nearMaterial
							end
						end

						if ignoreWaterObj:GetValue() and cellMaterial == materialWater then
							cellMaterial = materialAir
							cellOccupancy = 0
						end
						local airFillerMaterial = waterHeight >= iy and airFillerMaterial or materialAir
	
						if kCurrentTool.Name == 'Add' then
							if kSelectionSize <= 2 then
								if brushOccupancy >= .5 then
									if cellMaterial == materialAir or cellOccupancy <= 0 then
										materials[ix][iy][iz] = desiredMaterial
									end
									occupancies[ix][iy][iz] = 1
								end 
							else
								if brushOccupancy > cellOccupancy then
									occupancies[ix][iy][iz] = brushOccupancy
								end
								if brushOccupancy >= .5 and cellMaterial == materialAir then
									materials[ix][iy][iz] = desiredMaterial
								end
							end
						elseif kCurrentTool.Name == 'Subtract' then
							if cellMaterial ~= materialAir then
								if kSelectionSize <= 2 then
									if brushOccupancy >= .5 then
										occupancies[ix][iy][iz] = airFillerMaterial == materialWater and 1 or 0
										materials[ix][iy][iz] = airFillerMaterial
									end
								else
									local desiredOccupancy = max(0,1 - brushOccupancy)
									if desiredOccupancy < cellOccupancy then
										if desiredOccupancy <= one256th then
											occupancies[ix][iy][iz] = airFillerMaterial == materialWater and 1 or 0
											materials[ix][iy][iz] = airFillerMaterial
										else
											occupancies[ix][iy][iz] = min(cellOccupancy, desiredOccupancy)
										end
									end
								end
							end
						elseif kCurrentTool.Name == 'Grow' then
							if brushOccupancy >= .5 then --working on
								local desiredOccupancy = cellOccupancy
								local neighborOccupancies, fullNeighbor, emptyNeighbor = getNeighborOccupancies(occupancies, ix, iy, iz, ignoreWaterObj:GetValue() and materials)
								if cellOccupancy > 0 or fullNeighbor then	--problem if selection size is small.
									desiredOccupancy = desiredOccupancy + neighborOccupancies * (kStrength + .1) * .25 * brushOccupancy * magnitudePercent
								end
								if cellMaterial == materialAir and desiredOccupancy > 0 then
									materials[ix][iy][iz] = desiredMaterial
								end
								if desiredOccupancy ~= cellOccupancy then
									occupancies[ix][iy][iz] = desiredOccupancy
								end
							end
						elseif kCurrentTool.Name == 'Erode' then
							if cellMaterial ~= materialAir then
								local flippedBrushOccupancy = 1 - brushOccupancy
								if flippedBrushOccupancy <= .5 then
									local desiredOccupancy = cellOccupancy
									local emptyNeighbor = false
									local neighborOccupancies = 6
									for axis = 1, 3 do
										for offset = -1, 1, 2 do
											local neighbor = nil
											local neighborMaterial = nil
											if axis == 1 then
												neighbor = occupancies[ix + offset] and occupancies[ix + offset][iy][iz]
												neighborMaterial = materials[ix + offset] and materials[ix + offset][iy][iz]
											elseif axis == 2 then
												neighbor = occupancies[ix][iy + offset] and occupancies[ix][iy + offset][iz]
												neighborMaterial = materials[ix][iy + offset] and materials[ix][iy + offset][iz]
											elseif axis == 3 then
												neighbor = occupancies[ix][iy][iz + offset]
												neighborMaterial = materials[ix][iy][iz + offset]
											end
											if neighbor then
												if ignoreWaterObj:GetValue() and neighborMaterial == materialWater then
													neighbor = 0
												end
												if neighbor <= 0 then
													emptyNeighbor = true
												end
												neighborOccupancies = neighborOccupancies - neighbor
											end
										end
									end
									if cellOccupancy < 1 or emptyNeighbor then
										desiredOccupancy = max(0,desiredOccupancy - (neighborOccupancies / 6) * (kStrength + .1) * .25 * brushOccupancy * magnitudePercent)
									end
									if desiredOccupancy <= one256th then
										occupancies[ix][iy][iz] = airFillerMaterial == materialWater and 1 or 0
										materials[ix][iy][iz] = airFillerMaterial
									else
										occupancies[ix][iy][iz] = desiredOccupancy
									end
								end
							end
						elseif kCurrentTool.Name == 'Paint' then
							if brushOccupancy > 0 and cellOccupancy > 0 then
								materials[ix][iy][iz] = desiredMaterial
							end
						end
					end
				end
			end
		end
		terrain:WriteVoxels(region, resolution, materials, occupancies)
	end

	
	module.On = function(theTool)
		kCurrentTool = theTool
		screenGui.Parent = coreGui
		verticallyScalingListFrame.Visible = true
		on = true

		updateUsabilityLocks()

		local loopTag = {}	--using table as a unique value for debouncing
		currentLoopTag = loopTag

		while currentLoopTag and currentLoopTag == loopTag do
			local t = tick()
			local radius = kSelectionSize * .5 * resolution
			local cameraPos = mouse.Origin.p
			
			local ignoreModel = nil
			if game.Players.LocalPlayer and game.Players.LocalPlayer.Character then
				ignoreModel = game.Players.LocalPlayer.Character
			end
			local mouseRay = Ray.new(cameraPos, mouse.UnitRay.Direction*10000)
			local hitObject, mainPoint = game.Workspace:FindPartOnRay(mouseRay, ignoreModel, false, ignoreWaterObj:GetValue())

			if kCurrentTool.Name == 'Add' then
				mainPoint = mainPoint - mouse.UnitRay.Direction * .05
			elseif kCurrentTool.Name == 'Subtract' or kCurrentTool.Name == 'Paint' or kCurrentTool.Name == 'Grow' then
				mainPoint = mainPoint + mouse.UnitRay.Direction * .05
			end

			if mouse.Target == nil then	--cage the cursor so that it does not fly away
				mainPoint = cameraPos + mouse.UnitRay.Direction * lastCursorDistance --limits the distance of the mainPoint if the mouse is not hitting an object
			end

			if not mouseDown or click then
				lastPlanePoint = mainPoint
				lastNormal = findFace()
			end

			if planeLockObj:GetValue() then
				mainPoint = lineToPlaneIntersection(cameraPos, mouse.UnitRay.Direction, lastPlanePoint, lastNormal)
			end

			if snapToGridObj:GetValue() then
				local snapOffset = Vector3.new(1, 1, 1) * (radius % resolution)		--in studs
				local tempMainPoint = (mainPoint - snapOffset) / resolution + Vector3.new(.5, .5, .5)	--in voxels
				mainPoint = Vector3.new(floor(tempMainPoint.x), floor(tempMainPoint.y), floor(tempMainPoint.z)) * resolution + snapOffset
			end

			if mouseDown then
				if click then
					firstOperation = t
					lastMainPoint = mainPoint
				end
				
				if click or t > firstOperation + clickThreshold then
					click = false
					if downKeys[Enum.KeyCode.LeftAlt] or downKeys[Enum.KeyCode.RightAlt] then
						--pick color
						local function filterNonTerrain(thing)
							if thing and thing == terrain then
								return false
							end
							return true
						end
						local hit, hitPosition, normal, foundMaterial = deepCast(cameraPos, cameraPos + mouse.UnitRay.Direction*10000, {}, filterNonTerrain, true)
						if hit then
							kMaterialsListObject:UpdateSelectionUsingEnum(foundMaterial)
						end
					else
						local difference = mainPoint - lastMainPoint
						local dragDistance = (difference).magnitude
						local crawlDistance = radius * .5			--Maybe adjustable setting? Considering using a different method of crawling, with a percent rather than a finite distance.
						if dragDistance > crawlDistance then
							local differenceVector = difference.unit
							local dragDistance = min(dragDistance, crawlDistance * 2 + 20)	--limiting this so that it does not attempt too many operations within a single drag.
							local samples = ceil(dragDistance / crawlDistance - .1)
							for i = 1, samples do
								operation(lastMainPoint + differenceVector * dragDistance * (i / samples))
							end
							mainPoint = lastMainPoint + differenceVector * dragDistance
						else
							operation(mainPoint)
						end
						lastMainPoint = mainPoint
					end
				end
			end

			if not selectionPart then
				selectionPart = Instance.new('Part')
				selectionPart.Name = 'SelectionPart'
				selectionPart.Transparency = 1
				selectionPart.TopSurface = 'Smooth'
				selectionPart.BottomSurface = 'Smooth'
				selectionPart.Anchored = true
				selectionPart.CanCollide = false
				selectionPart.Size = Vector3.new(1, 1, 1) * kSelectionSize * resolution + Vector3.new(.1, .1, .1)
				selectionPart.Parent = screenGui
			end
			if not selectionObject then
				selectionObject = Instance.new(brushShape == 'Sphere' and 'SelectionSphere' or 'SelectionBox')
				selectionObject.Name = 'SelectionObject'
				selectionObject.Color = BrickColor.new('Toothpaste')
				selectionObject.SurfaceTransparency = .95 - kStrength * .3
				selectionObject.SurfaceColor = BrickColor.new('Toothpaste')
				selectionObject.Adornee = selectionPart
				selectionObject.Parent = selectionPart
			end
			
			if not userInput.TouchEnabled or mouseDown then
				selectionPart.CFrame = CFrame.new(mainPoint)
				
				if planeLockObj:GetValue() then
					local mainPointIntersect = lineToPlaneIntersection(mainPoint, mouse.UnitRay.Direction, lastPlanePoint, lastNormal)	--we need to get this otherwise the plane can shift whiel drawing
					drawGrid(mainPointIntersect, lastNormal, mouseDown and .8)
				end
			end

			lastCursorDistance = max(20 + kSelectionSize * resolution * 1.5,(mainPoint - cameraPos).magnitude)

			quickWait()
		end
	end
	
	module.Off = function()
		currentLoopTag = nil
		screenGui.Parent = script.Parent
		verticallyScalingListFrame.Visible = false
		on = false
		
		clearSelection()
		clearGrid()
		mouseDown = false
	end

	--Touch controls
	local fingerTouches = {}
	local NumUnsunkTouches = 0

	local StartingDiff = nil
	local startingSelectionSize = nil

	local function OnTouchBegan(input, processed)
		fingerTouches[input] = processed
		if not processed then
			click = true
			NumUnsunkTouches = NumUnsunkTouches + 1
		end
	end

	local function OnTouchChanged(input, processed)
		if fingerTouches[input] == nil then
			fingerTouches[input] = processed
			if not processed then
				NumUnsunkTouches = NumUnsunkTouches + 1
			end
		end

		if NumUnsunkTouches == 1 then
			if fingerTouches[input] == false then
				mouseDown = true
			end
		else
			mouseDown = false
		end
		if NumUnsunkTouches == 2 then
			local unsunkTouches = {}
			for touch, wasSunk in pairs(fingerTouches) do
				if not wasSunk then
					table.insert(unsunkTouches, touch)
				end
			end
			if #unsunkTouches == 2 then
				local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
				if StartingDiff and startingSelectionSize then
					local scale = difference/max(0.01, StartingDiff)
					kSelectionSize = max(kMinSelectionSize, min(kMaxSelectionSize, startingSelectionSize/scale))
					selectionSizeValue.Value = kSelectionSize
				else
					StartingDiff = difference
					startingSelectionSize = selectionSizeValue.Value
				end
			end
		else
			StartingDiff = nil
			startingSelectionSize = nil
		end
	end

	local function OnTouchEnded(input, processed)
		if fingerTouches[input] == false then
			if NumUnsunkTouches == 1 then
				mouseDown = false
			elseif NumUnsunkTouches == 2 then
				StartingDiff = nil
				startingSelectionSize = nil
				mouseDown = true
			end
		end

		if fingerTouches[input] ~= nil and fingerTouches[input] == false then
			NumUnsunkTouches = NumUnsunkTouches - 1
		end
		fingerTouches[input] = nil
	end
	
	-- Input Handling
	userInput.InputBegan:connect(function(event, soaked)
		downKeys[event.KeyCode] = true
		if event.UserInputType == Enum.UserInputType.MouseButton1 and not soaked and on then
			mouseDown = true
			click = true
		elseif event.UserInputType == Enum.UserInputType.Touch and on then
			OnTouchBegan(event, soaked)
		end
	end)
	
	userInput.InputChanged:connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			OnTouchChanged(input, processed)
		end
	end)
	
	userInput.InputEnded:connect(function(event, soaked)
		downKeys[event.KeyCode] = nil
		if event.UserInputType == Enum.UserInputType.MouseButton1 and mouseDown then
			mouseDown = false
			if changeHistory then
				changeHistory:SetWaypoint('Terrain '..kCurrentTool.Name)
			end
		elseif event.UserInputType == Enum.UserInputType.Touch then
			OnTouchEnded(event, soaked)
		end
	end)

	function scrollwheel(change)
		if on then
			if downKeys[Enum.KeyCode.LeftShift] or downKeys[Enum.KeyCode.RightShift] then
				kSelectionSize = max(kMinSelectionSize, min(kMaxSelectionSize, kSelectionSize + change))
				selectionSizeValue.Value = kSelectionSize
			end
			if downKeys[Enum.KeyCode.LeftControl] or downKeys[Enum.KeyCode.RightControl] then
				kStrength = max(0, min(1, kStrength + change * (1/(kMaxSelectionSize-kMinSelectionSize))))
				strengthValue.Value = round(kStrength * 100 + 1)
			end
		end
	end
	
	mouse.WheelForward:connect(function()
		scrollwheel(1)
	end)
	
	mouse.WheelBackward:connect(function()
		scrollwheel(-1)
	end)

	setBrushShape(brushShape)
	kMaterialsListObject:SetMaterialSelection(kMaterialsListObject:GetCurrentMaterialSelection())

	-- Reset keyboard status on lost focus as key release may never come blocked by popups etc.
	userInput.WindowFocusReleased:connect(function()
		downKeys = {}
	end)
end


return module]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXaf07187c71ca426394504ca51a05ce3c">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TerrainGeneration</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Stickmasterluke

local module = {}

local GuiUtilities = require(script.Parent.GuiUtilities)
local VerticallyScalingListFrame = require(script.Parent.VerticallyScalingListFrame)
local CollapsibleTitledSection = require(script.Parent.CollapsibleTitledSection)
local LabeledCheckbox = require(script.Parent.LabeledCheckbox)
local LabeledTextInput = require(script.Parent.LabeledTextInput)
local ProgressFrame = require(script.Parent.ProgressFrame)
local LabeledMultiChoice = require(script.Parent.LabeledMultiChoice)

local coreGui = game:GetService('CoreGui')
local changeHistoryService = game:GetService('ChangeHistoryService')
local terrain = game.Workspace.Terrain

local pluginGui
local screenGui

local terrainGenerationFrame 
local progressFrame 
local pauseButton
local cancelButton 
local barFill 


local kBiomesCheckboxHPadding = 24

local kBottomButtonsWidth = 100
local kBottomButtonsPadding = 20

local kProgressFrameObj = nil

kBiomeData = {
	Mountains = {
		LayoutOrder = 1,
		Text = "Mountains",
	},
	Canyons = {
		LayoutOrder = 2,
		Text = "Canyons",
	},
	Dunes = {
		LayoutOrder = 3,
		Text = "Dunes",
	},
	Arctic = {
		LayoutOrder = 4,
		Text = "Arctic",
	},
	Lavaflow = {
		LayoutOrder = 5,
		Text = "Lavaflow",
	},
	Hills = {
		LayoutOrder = 6,
		Text = "Hills",
	},
	Plains = {
		LayoutOrder = 7,
		Text = "Plains",
	},
	Marsh = {
		LayoutOrder = 8,
		Text = "Marsh",
	},
	Water = {
		LayoutOrder = 9,
		Text = "Water",
	},
}

local kBiomeSizeChoices = {
	{
		Id = "Small", 
		Data = 50, 
		Text = "Small (50)"
	},
	{
		Id = "Medium", 
		Data = 100, 
		Text = "Medium (100)"
	},
	{
		Id = "Large", 
		Data = 200, 
		Text = "Large (200)"
	},
	{
		Id = "Massive", 
		Data = 500, 
		Text = "Massive (500)"
	},
}

local kMapSizeChoices = {
	{
		Id = "Small", 
		Data = 128, 
		Text = "Small (128)"
	},
	{
		Id = "Medium", 
		Data = 256, 
		Text = "Medium (256)"
	},
	{
		Id = "Large", 
		Data = 512, 
		Text = "Large (512)"
	},
	{
		Id = "Massive", 
		Data = 1024, 
		Text = "Massive (1024)"
	},
}

local kSelectedBiomes = {
	['Mountains'] = true,
	['Canyons'] = false,
	['Dunes'] = false,
	['Arctic'] = false,
	['Lavaflow'] = false,
	['Hills'] = true,
	['Plains'] = true,
	['Marsh'] = false,
	['Water'] = false,
}


local on = false
local mouse = nil
local generating = false
local clearing = false
local paused = false
local cancelIt = false

local noise = math.noise
local min = math.min
local max = math.max
local sin = math.sin
local cos = math.cos
local floor = math.floor
local ceil = math.ceil
local sqrt = math.sqrt
local randomseed = math.randomseed
local random = math.random
local pi = math.pi
local tau = math.pi*2


---------Directly used in Generation---------
local masterSeed = 618033988
local mapWidth = 256
local mapHeight = 128
local biomeSize = 100
local generateCaves = false
local waterLevel = .48
local surfaceThickness = .018
local biomes = {}
---------------------------------------------

-------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------

local rock = Enum.Material.Rock
local snow = Enum.Material.Snow
local ice = Enum.Material.Glacier
local grass = Enum.Material.Grass
local ground = Enum.Material.Ground
local mud = Enum.Material.Mud
local slate = Enum.Material.Slate
local concrete = Enum.Material.Concrete
local lava = Enum.Material.CrackedLava
local basalt = Enum.Material.Basalt
local air = Enum.Material.Air
local sand = Enum.Material.Sand
local sandstone = Enum.Material.Sandstone
local water = Enum.Material.Water

local fill = rock

local range = {}
randomseed(6180339)
theseed={}
for i=1,999 do
	table.insert(theseed,math.random())
end

local function MakeMapSettingsFrame()
	-- Height will be adjusted.
	local mapSettingsObj = CollapsibleTitledSection.new('MapSettingsFrame', 
	  'Map Settings', 
	  true, 
	  true)

	-- The 'Map size' dropdown.
	-- The "Size" dropdown.	
	local sizeMultiChoiceObj = LabeledMultiChoice.new("MapSize", "Map Size", kMapSizeChoices)
	sizeMultiChoiceObj:SetValueChangedFunction(function(index) 
		mapWidth = kMapSizeChoices[index].Data
	end)
	sizeMultiChoiceObj:SetSelectedIndex(2)
		
	-- The 'Seed' text box.
	local seedTextBoxObj = LabeledTextInput.new("Seed", "Seed", masterSeed)
	local seedFrame = seedTextBoxObj:GetFrame()
	seedTextBoxObj:SetValueChangedFunction(function(text)
		local compositeNumber = 0
		for i=1,#text do
			local character = string.sub(text,i,i)
			local number = tonumber(character)
			if number then
				compositeNumber = (compositeNumber+6)*(number+5)
			else
				compositeNumber = (compositeNumber+7)*(string.byte(character)+3)
			end
			compositeNumber = compositeNumber%61803	--yes, this does need to be done after every character iteration, otherwise number loses precision by the end
		end
		masterSeed = compositeNumber
	end)

	-- The 'Caves' check box.
	local cavesObj = LabeledCheckbox.new("CavesFrame", "Caves", generateCaves)
	cavesObj:SetValueChangedFunction(function(value)
		generateCaves = value
	end)

	-- Make contents of collapsible frame an auto-scaling list.
	GuiUtilities.MakeFrameAutoScalingList(mapSettingsObj:GetContentsFrame())

	-- Add these as striped fields in parent 
	GuiUtilities.AddStripedChildrenToListFrame(mapSettingsObj:GetContentsFrame(), 
		{sizeMultiChoiceObj:GetFrame(), seedFrame, cavesObj:GetFrame()})

	return mapSettingsObj:GetSectionFrame()
end

local function AddBiomeCheckbox(parentFrame, biomeId)
	local checkboxObj = LabeledCheckbox.new(biomeId, kBiomeData[biomeId].Text, kSelectedBiomes[biomeId])
	checkboxObj:SetValueChangedFunction(function(value)
		kSelectedBiomes[biomeId] = value
	end)
	checkboxObj:UseSmallSize()
	checkboxObj:GetFrame().LayoutOrder = kBiomeData[biomeId].LayoutOrder
	checkboxObj:GetFrame().Parent = parentFrame
end

local function MakeBiomesCheckboxes()
	local frame = GuiUtilities.MakeFrame("Checkboxes")

	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, GuiUtilities.StandardLineLabelLeftMargin)
	padding.PaddingRight = UDim.new(0, GuiUtilities.StandardLineLabelLeftMargin)
	padding.Parent = frame
	
	-- Make a grid to put checkboxes in.
	local uiGridLayout = Instance.new("UIGridLayout")
	uiGridLayout.CellSize = LabeledCheckbox.kMinFrameSize
	uiGridLayout.CellPadding = UDim2.new(0, 
		kBiomesCheckboxHPadding,
		0,
		GuiUtilities.kStandardVMargin)
	uiGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	uiGridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	uiGridLayout.Parent = frame
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder

	for biomeId, biomeData in pairs(kBiomeData) do 
		AddBiomeCheckbox(frame, biomeId)
	end

		-- Sync size with content size.
	GuiUtilities.AdjustHeightDynamicallyToLayout(frame, uiGridLayout)

	return frame
end

local function MakeBiomesCheckboxesWithTitle()
	local vsl = VerticallyScalingListFrame.new("bcwt")

	local titleLabel = GuiUtilities.MakeFrameWithSubSectionLabel("Title", "Biomes")
	vsl:AddChild(titleLabel)

	-- Container for cells.
	local cellFrame = MakeBiomesCheckboxes()
	vsl:AddChild(cellFrame)

	return vsl:GetFrame()
end

local function MakeBiomesSettingsFrame()
	-- Height will be updated dynamically.
	local biomesSettingsObj = CollapsibleTitledSection.new('BiomesSettingsFrame', 
		'Biomes Settings', 
		true, 
		true)
	
	-- The "Size" dropdown.	
	local sizeMultiChoiceObj = LabeledMultiChoice.new("SizeFrame", "Biome Size", kBiomeSizeChoices)
	sizeMultiChoiceObj:SetValueChangedFunction(function(index) 
		biomeSize = kBiomeSizeChoices[index].Data
	end)
	sizeMultiChoiceObj:SetSelectedIndex(2)

	-- The "Biomes" checkbox frame.
	local biomeCheckboxesFrame = MakeBiomesCheckboxesWithTitle()
	
	-- Make contents of collapsible frame an auto-scaling list.
	GuiUtilities.MakeFrameAutoScalingList(biomesSettingsObj:GetContentsFrame())

	-- add these as striped fields in parent.
	GuiUtilities.AddStripedChildrenToListFrame(biomesSettingsObj:GetContentsFrame(), {sizeMultiChoiceObj:GetFrame(), 
		biomeCheckboxesFrame})

	return biomesSettingsObj:GetSectionFrame()
end

local function MakeButtonsFrame()
	local frame = GuiUtilities.MakeFixedHeightFrame("Buttons", GuiUtilities.kBottomButtonsFrameHeight)

	local clearButton = GuiUtilities.MakeTextButton("ClearButton", "Clear", frame)
	clearButton.Size = UDim2.new(0, kBottomButtonsWidth, 0, GuiUtilities.kBottomButtonsHeight)
	clearButton.Position = UDim2.new(0.5, -kBottomButtonsWidth - kBottomButtonsPadding/2, 0.5, -GuiUtilities.kBottomButtonsHeight/2)

	local generateButton = GuiUtilities.MakeTextButton("GenerateButton", "Generate", frame)
	generateButton.Size = UDim2.new(0, kBottomButtonsWidth, 0, GuiUtilities.kBottomButtonsHeight)
	generateButton.Position = UDim2.new(0.5, kBottomButtonsPadding/2, 0.5, -GuiUtilities.kBottomButtonsHeight/2)
	
	return frame
end

function MakeTerrainGenerationFrame()
	-- Create top level container.  
	-- It has no title bar.
	local verticallyScalingListFrameObj = VerticallyScalingListFrame.new("GenerationFrame")
	local verticallyScalingListFrame = verticallyScalingListFrameObj:GetFrame()

	local mapSettingsFrame = MakeMapSettingsFrame()
	mapSettingsFrame.Parent = verticallyScalingListFrame
	mapSettingsFrame.LayoutOrder = 1

	local biomesSettingsFrame = MakeBiomesSettingsFrame()
	biomesSettingsFrame.Parent = verticallyScalingListFrame
	biomesSettingsFrame.LayoutOrder = 2

	local buttonsFrame = MakeButtonsFrame()
	buttonsFrame.Parent = verticallyScalingListFrame
	buttonsFrame.LayoutOrder = 3

	return verticallyScalingListFrame
end

module.FirstTimeSetup = function(mouse, thePluginGui, theContentFrame)
	mouse = theMouse
	pluginGui = thePluginGui
	contentFrame = theContentFrame

	screenGui = Instance.new("ScreenGui")
	screenGui.Name = "TerrainBrushGui"

	-- Add Terrain Generation Frame(s)
	terrainGenerationFrame = MakeTerrainGenerationFrame()
	terrainGenerationFrame.Parent = contentFrame

	kProgressFrameObj = ProgressFrame.new()
	progressFrame = kProgressFrameObj:GetFrame()
	progressFrame.Parent = screenGui

	pauseButton = kProgressFrameObj:GetPauseButton()
	cancelButton = kProgressFrameObj:GetCancelButton()
	barFill = kProgressFrameObj:GetFill()

	pauseButton.MouseButton1Down:connect(function()
		paused = not paused
		updatePausedButton()
	end)
	
	cancelButton.MouseButton1Down:connect(function()
		if not cancelIt then
			cancelIt = true
			print('Canceled')
		end
	end)

	terrainGenerationFrame.Buttons.GenerateButton.MouseButton1Down:connect(function()
		-- A frame delay allows time for the button image to visually respond before the generation starts chugging away with processing.
		wait()
		generate()
	end)
	
	terrainGenerationFrame.Buttons.ClearButton.MouseButton1Down:connect(function()
		clearTerrain()
	end)
end

function checkRange(v)
	if not range.min or v < range.min then
		range.min = v
	end
	if not range.max or v > range.max then
		range.max = v
	end
end

local function getPerlin(x,y,z,seed,scale,raw)
	local seed = seed or 0
	local scale = scale or 1
	if not raw then
		return noise(x/scale+(seed*17)+masterSeed,y/scale-masterSeed,z/scale-seed*seed)*.5 + .5 -- accounts for bleeding from interpolated line
	else
		return noise(x/scale+(seed*17)+masterSeed,y/scale-masterSeed,z/scale-seed*seed)
	end
end


local function getNoise(x,y,z,seed1)
	local x = x or 0
	local y = y or 0
	local z = z or 0
	local seed1 = seed1 or 7
	local wtf=x+y+z+seed1+masterSeed + (masterSeed-x)*(seed1+z) + (seed1-y)*(masterSeed+z)		-- + x*(y+z) + z*(masterSeed+seed1) + seed1*(x+y)			--x+y+z+seed1+masterSeed + x*y*masterSeed-y*z+(z+masterSeed)*x	--((x+y)*(y-seed1)*seed1)-(x+z)*seed2+x*11+z*23-y*17
	return theseed[(floor(wtf%(#theseed)))+1]
end

local function thresholdFilter(value, bottom, size)
	if value <= bottom then
		return 0
	elseif value >= bottom+size then
		return 1
	else
		return (value-bottom)/size
	end
end

local function ridgedFilter(value)	--absolute and flip for ridges. and normalize
	return value<.5 and value*2 or 2-value*2
end

local function ridgedFlippedFilter(value)					--unflipped
	return value < .5 and 1-value*2 or value*2-1
end

local function advancedRidgedFilter(value, cutoff)
	local cutoff = cutoff or .5
	value = value - cutoff
	return 1 - (value < 0 and -value or value) * 1/(1-cutoff)
end


local function fractalize(operation,x,y,z, operationCount, scale, offset, gain)
	local operationCount = operationCount or 3
	local scale = scale or .5
	local offset = 0
	local gain = gain or 1
	local totalValue = 0
	local totalScale = 0
	for i=1, operationCount do
		local thisScale = scale^(i-1)
		totalScale = totalScale + thisScale
		totalValue = totalValue + (offset + gain * operation(x,y,z,i))*thisScale
	end
	return totalValue/totalScale
end


local function mountainsOperation(x,y,z,i)
	return ridgedFilter(getPerlin(x,y,z,100+i,(1/i)*160))
end

local canyonBandingMaterial = {rock,mud,sand,sand,sandstone,sandstone,sandstone,sandstone,sandstone,sandstone,}

local function findBiomeInfo(choiceBiome,x,y,z,verticalGradientTurbulence)
	local choiceBiomeValue = .5
	local choiceBiomeSurface = grass
	local choiceBiomeFill = rock
	if choiceBiome == 'City' then
		choiceBiomeValue = .55
		choiceBiomeSurface = concrete
		choiceBiomeFill = slate
	elseif choiceBiome == 'Water' then
		choiceBiomeValue = .36+getPerlin(x,y,z,2,50)*.08
		choiceBiomeSurface = 
			(1-verticalGradientTurbulence < .44 and slate)
			or sand
	elseif choiceBiome == 'Marsh' then
		local preLedge = getPerlin(x+getPerlin(x,0,z,5,7,true)*10+getPerlin(x,0,z,6,30,true)*50,0,z+getPerlin(x,0,z,9,7,true)*10+getPerlin(x,0,z,10,30,true)*50,2,70)	--could use some turbulence
		local grassyLedge = thresholdFilter(preLedge,.65,0)
		local largeGradient = getPerlin(x,y,z,4,100)
		local smallGradient = getPerlin(x,y,z,3,20)
		local smallGradientThreshold = thresholdFilter(smallGradient,.5,0)
		choiceBiomeValue = waterLevel-.04
			+preLedge*grassyLedge*.025
			+largeGradient*.035
			+smallGradient*.025
		choiceBiomeSurface =
			(grassyLedge >= 1 and grass)
			or (1-verticalGradientTurbulence < waterLevel-.01 and mud)
			or (1-verticalGradientTurbulence < waterLevel+.01 and ground)
			or grass
		choiceBiomeFill = slate
	elseif choiceBiome == 'Plains' then
		local rivulet = ridgedFlippedFilter(getPerlin(x+getPerlin(x,y,z,17,40)*25,0,z+getPerlin(x,y,z,19,40)*25,2,200))
		local rivuletThreshold = thresholdFilter(rivulet,.01,0)

		local rockMap = thresholdFilter(ridgedFlippedFilter(getPerlin(x,0,z,101,7)),.3,.7)		--rocks
			 * thresholdFilter(getPerlin(x,0,z,102,50),.6,.05)									--zoning

		choiceBiomeValue = .5			--.51
		+getPerlin(x,y,z,2,100)*.02		--.05
		+rivulet*.05					--.02
		+rockMap*.05		--.03
		+rivuletThreshold*.005

		local verticalGradient = 1-((y-1)/(mapHeight-1))
		local surfaceGradient = verticalGradient*.5 + choiceBiomeValue*.5
		local thinSurface = surfaceGradient > .5-surfaceThickness*.4 and surfaceGradient < .5+surfaceThickness*.4
		choiceBiomeSurface =
			(rockMap>0 and rock)
			or (not thinSurface and mud)
			or (thinSurface and rivuletThreshold <=0 and water)
			or (1-verticalGradientTurbulence < waterLevel-.01 and sand)
			or grass
		choiceBiomeFill =
			(rockMap>0 and rock)
			or sandstone
	elseif choiceBiome == 'Canyons' then
		local canyonNoise = ridgedFlippedFilter(getPerlin(x,0,z,2,200))
		local canyonNoiseTurbed = ridgedFlippedFilter(getPerlin(x+getPerlin(x,0,z,5,20,true)*20,0,z+getPerlin(x,0,z,9,20,true)*20,2,200))
		local sandbank = thresholdFilter(canyonNoiseTurbed,0,.05)
		local canyonTop = thresholdFilter(canyonNoiseTurbed,.125,0)
		local mesaSlope = thresholdFilter(canyonNoise,.33,.12)
		local mesaTop = thresholdFilter(canyonNoiseTurbed,.49,0)
		choiceBiomeValue = .42
			+getPerlin(x,y,z,2,70)*.05
			+canyonNoise*.05
			+sandbank*.04										--canyon bottom slope
			+thresholdFilter(canyonNoiseTurbed,.05,0)*.08		--canyon cliff
			+thresholdFilter(canyonNoiseTurbed,.05,.075)*.04	--canyon cliff top slope
			+canyonTop*.01										--canyon cliff top ledge

			+thresholdFilter(canyonNoiseTurbed,.0575,.2725)*.01	--plane slope

			+mesaSlope*.06			--mesa slope
			+thresholdFilter(canyonNoiseTurbed,.45,0)*.14		--mesa cliff
			+thresholdFilter(canyonNoiseTurbed,.45,.04)*.025	--mesa cap
			+mesaTop*.02										--mesa top ledge
		choiceBiomeSurface =
			(1-verticalGradientTurbulence < waterLevel+.015 and sand)		--this for biome blending in to lakes
			or (sandbank>0 and sandbank<1 and sand)							--this for canyonbase sandbanks
			--or (canyonTop>0 and canyonTop<=1 and mesaSlope<=0 and grass)		--this for grassy canyon tops
			--or (mesaTop>0 and mesaTop<=1 and grass)							--this for grassy mesa tops
			or sandstone
		choiceBiomeFill = canyonBandingMaterial[ceil((1-getNoise(1,y,2))*10)]
	elseif choiceBiome == 'Hills' then
		local rivulet = ridgedFlippedFilter(getPerlin(x+getPerlin(x,y,z,17,20)*20,0,z+getPerlin(x,y,z,19,20)*20,2,200))^(1/2)
		local largeHills = getPerlin(x,y,z,3,60)
		choiceBiomeValue = .48
			+largeHills*.05
				+(.05
				+largeHills*.1
				+getPerlin(x,y,z,4,25)*.125)
				*rivulet
		local surfaceMaterialGradient = (1-verticalGradientTurbulence)*.9 + rivulet*.1
		choiceBiomeSurface =
			(surfaceMaterialGradient < waterLevel-.015 and mud)
			or (surfaceMaterialGradient < waterLevel and ground)
			or grass
		choiceBiomeFill = slate
	elseif choiceBiome == 'Dunes' then
		local duneTurbulence = getPerlin(x,0,z,227,20)*24
		local layer1 = ridgedFilter(getPerlin(x,0,z,201,40))
		local layer2 = ridgedFilter(getPerlin(x/10+duneTurbulence,0,z+duneTurbulence,200,48))
		choiceBiomeValue = .4+.1*(layer1 + layer2)
		choiceBiomeSurface = sand
		choiceBiomeFill = sandstone
	elseif choiceBiome == 'Mountains' then
		local rivulet = ridgedFlippedFilter(getPerlin(x+getPerlin(x,y,z,17,20)*20,0,z+getPerlin(x,y,z,19,20)*20,2,200))
		choiceBiomeValue = -.4		--.3
			+fractalize(mountainsOperation,x,y/20,z, 8, .65)*1.2
			+rivulet*.2
		choiceBiomeSurface =
			(verticalGradientTurbulence < .275 and snow)
			or (verticalGradientTurbulence < .35 and rock)
			or (verticalGradientTurbulence < .4 and ground)
			or (1-verticalGradientTurbulence < waterLevel and rock)
			or (1-verticalGradientTurbulence < waterLevel+.01 and mud)
			or (1-verticalGradientTurbulence < waterLevel+.015 and ground)
			or grass
	elseif choiceBiome == 'Lavaflow' then
		local crackX = x+getPerlin(x,y*.25,z,21,8,true)*5
		local crackY = y+getPerlin(x,y*.25,z,22,8,true)*5
		local crackZ = z+getPerlin(x,y*.25,z,23,8,true)*5
		local crack1 = ridgedFilter(getPerlin(crackX+getPerlin(x,y,z,22,30,true)*30,crackY,crackZ+getPerlin(x,y,z,24,30,true)*30,2,120))
		local crack2 = ridgedFilter(getPerlin(crackX,crackY,crackZ,3,40))*(crack1*.25+.75)
		local crack3 = ridgedFilter(getPerlin(crackX,crackY,crackZ,4,20))*(crack2*.25+.75)

		local generalHills = thresholdFilter(getPerlin(x,y,z,9,40),.25,.5)*getPerlin(x,y,z,10,60)

		local cracks = max(0,1-thresholdFilter(crack1,.975,0)-thresholdFilter(crack2,.925,0)-thresholdFilter(crack3,.9,0))

		local spireVec = CFrame.Angles(.7,.7,0)*Vector3.new(crackX,crackY,crackZ)
		local spires = thresholdFilter(getPerlin(spireVec.x/40,spireVec.y/300,spireVec.z/30,123,1),.6,.4)

		choiceBiomeValue = waterLevel+.02
			+cracks*(.5+generalHills*.5)*.02
			+generalHills*.05
			+spires*.3
			+((1-verticalGradientTurbulence > waterLevel+.01 or spires>0) and .04 or 0)			--This lets it lip over water

		choiceBiomeFill = (spires>0 and rock) or (cracks<1 and lava) or basalt
		choiceBiomeSurface = (choiceBiomeFill == lava and 1-verticalGradientTurbulence < waterLevel and basalt) or choiceBiomeFill
	elseif choiceBiome == 'Arctic' then
		local preBoundary = getPerlin(x+getPerlin(x,0,z,5,8,true)*5,y/8,z+getPerlin(x,0,z,9,8,true)*5,2,20)
		--local cliffs = thresholdFilter(preBoundary,.5,0)
		local boundary = ridgedFilter(preBoundary)
		local roughChunks = getPerlin(x,y/4,z,436,2)
		local boundaryMask = thresholdFilter(boundary,.8,.1)	--,.7,.25)
		local boundaryTypeMask = getPerlin(x,0,z,6,74)-.5
		local boundaryComp = 0
		if boundaryTypeMask < 0 then							--divergent
			boundaryComp = (boundary > (1+boundaryTypeMask*.5) and -.17 or 0)
							--* boundaryTypeMask*-2
		else													--convergent
			boundaryComp = boundaryMask*.1*roughChunks
							* boundaryTypeMask
		end
		choiceBiomeValue = .55
			+boundary*.05*boundaryTypeMask		--.1	--soft slope up or down to boundary
			+boundaryComp								--convergent/divergent effects
			+getPerlin(x,0,z,123,25)*.025	--*cliffs	--gentle rolling slopes

		choiceBiomeSurface = (1-verticalGradientTurbulence < waterLevel-.1 and ice) or (boundaryMask>.6 and boundaryTypeMask>.1 and roughChunks>.5 and ice) or snow
		choiceBiomeFill = ice
	end
	return choiceBiomeValue, choiceBiomeSurface, choiceBiomeFill
end

function findBiomeTransitionValue(biome,weight,value,averageValue)
	if biome == 'Arctic' then
		return (weight>.2 and 1 or 0)*value
	elseif biome == 'Canyons' then
		return (weight>.7 and 1 or 0)*value
	elseif biome == 'Mountains' then
		local weight = weight^3			--This improves the ease of mountains transitioning to other biomes
		return averageValue*(1-weight)+value*weight
	else
		return averageValue*(1-weight)+value*weight
	end
end

function updatePausedButton()
	pauseButton.Style = paused and 'RobloxRoundButton' or 'RobloxRoundDefaultButton'
	pauseButton.Text = paused and 'Resume' or 'Pause'
end

function generate()
	if not generating and not clearing then
		generating = true
		paused = false
		updatePausedButton()
		cancelIt = false
		progressFrame.Visible = true

		local mapWidth = mapWidth
		local biomeSize = biomeSize
		local biomeBlendPercent = .25	--(biomeSize==50 or biomeSize == 100) and .5 or .25
		local biomeBlendPercentInverse = 1-biomeBlendPercent
		local biomeBlendDistortion = biomeBlendPercent
		local smoothScale = .5/mapHeight

		local startTime = tick()
		biomes = {}
		for i,v in pairs(kSelectedBiomes) do
			if v then
				table.insert(biomes,i)
			end
		end
		if #biomes<=0 then
			table.insert(biomes,'Hills')
		end
		--local oMap = {}
		--local mMap = {}
		for x = 1, mapWidth do
			local oMapX = {}
			--oMap[x] = oMapX
			local mMapX = {}
			--mMap[x] = mMapX
			for z = 1, mapWidth do
				local biomeNoCave = false
				local cellToBiomeX = x/biomeSize + getPerlin(x,0,z,233,biomeSize*.3)*.25 + getPerlin(x,0,z,235,biomeSize*.05)*.075
				local cellToBiomeZ = z/biomeSize + getPerlin(x,0,z,234,biomeSize*.3)*.25 + getPerlin(x,0,z,236,biomeSize*.05)*.075
				local closestPoint = Vector3.new(0,0,0)
				local closestDistance = 1000000
				local biomePoints = {}
				for vx=-1,1 do
					for vz=-1,1 do
						local gridPointX = floor(cellToBiomeX+vx+.5)
						local gridPointZ = floor(cellToBiomeZ+vz+.5)
						--local pointX, pointZ = getBiomePoint(gridPointX,gridPointZ)
						local pointX = gridPointX+(getNoise(gridPointX,gridPointZ,53)-.5)*.75	--de-uniforming grid for vornonoi
						local pointZ = gridPointZ+(getNoise(gridPointX,gridPointZ,73)-.5)*.75

						local dist = sqrt((pointX-cellToBiomeX)^2 + (pointZ-cellToBiomeZ)^2)
						if dist < closestDistance then
							closestPoint = Vector3.new(pointX,0,pointZ)
							closestDistance = dist
						end
						table.insert(biomePoints,{
							x = pointX,
							z = pointZ,
							dist = dist,
							biomeNoise = getNoise(gridPointX,gridPointZ),
							weight = 0
						})
					end
				end
				local weightTotal = 0
				local weightPoints = {}
				for _,point in pairs(biomePoints) do
					local weight = point.dist == closestDistance and 1 or ((closestDistance / point.dist)-biomeBlendPercentInverse)/biomeBlendPercent
					if weight > 0 then
						local weight = weight^2.1		--this smooths the biome transition from linear to cubic InOut
						weightTotal = weightTotal + weight
						local biome = biomes[ceil(#biomes*(1-point.biomeNoise))]	--inverting the noise so that it is limited as (0,1]. One less addition operation when finding a random list index
						weightPoints[biome] = {
							weight = weightPoints[biome] and weightPoints[biome].weight + weight or weight
						}
					end
				end
				for biome,info in pairs(weightPoints) do
					info.weight = info.weight / weightTotal
					if biome == 'Arctic' then		--biomes that don't have caves that breach the surface
						biomeNoCave = true
					end
				end


				for y = 1, mapHeight do
					local oMapY = oMapX[y] or {}
					oMapX[y] = oMapY
					local mMapY = mMapX[y] or {}
					mMapX[y] = mMapY

					--[[local oMapY = {}
					oMapX[y] = oMapY
					local mMapY = {}
					mMapX[z] = mMapY]]


					local verticalGradient = 1-((y-1)/(mapHeight-1))
					local caves = 0
					local verticalGradientTurbulence = verticalGradient*.9 + .1*getPerlin(x,y,z,107,15)
					local choiceValue = 0
					local choiceSurface = lava
					local choiceFill = rock
	
					if verticalGradient > .65 or verticalGradient < .1 then
						--under surface of every biome; don't get biome data; waste of time.
						choiceValue = .5
					elseif #biomes == 1 then
						choiceValue, choiceSurface, choiceFill = findBiomeInfo(biomes[1],x,y,z,verticalGradientTurbulence)
					else
						local averageValue = 0
						--local findChoiceMaterial = -getNoise(x,y,z,19)
						for biome,info in pairs(weightPoints) do
							local biomeValue, biomeSurface, biomeFill = findBiomeInfo(biome,x,y,z,verticalGradientTurbulence)
							info.biomeValue = biomeValue
							info.biomeSurface = biomeSurface
							info.biomeFill = biomeFill
							local value = biomeValue * info.weight
							averageValue = averageValue + value
							--[[if findChoiceMaterial < 0 and findChoiceMaterial + weight >= 0 then
								choiceMaterial = biomeMaterial
							end
							findChoiceMaterial = findChoiceMaterial + weight]]
						end
						for biome,info in pairs(weightPoints) do
							local value = findBiomeTransitionValue(biome,info.weight,info.biomeValue,averageValue)
							if value > choiceValue then
								choiceValue = value
								choiceSurface = info.biomeSurface
								choiceFill = info.biomeFill
							end
						end
					end

					local preCaveComp = verticalGradient*.5 + choiceValue*.5

					local surface = preCaveComp > .5-surfaceThickness and preCaveComp < .5+surfaceThickness

					if generateCaves																--user wants caves
						and (not biomeNoCave or verticalGradient > .65)								--biome allows caves or deep enough
							and not (surface and (1-verticalGradient) < waterLevel+.005)			--caves only breach surface above waterlevel
								and not (surface and (1-verticalGradient) > waterLevel+.58) then	--caves don't go too high so that they don't cut up mountain tops
									local ridged2 = ridgedFilter(getPerlin(x,y,z,4,30))
									local caves2 = thresholdFilter(ridged2,.84,.01)
									local ridged3 = ridgedFilter(getPerlin(x,y,z,5,30))
									local caves3 = thresholdFilter(ridged3,.84,.01)
									local ridged4 = ridgedFilter(getPerlin(x,y,z,6,30))
									local caves4 = thresholdFilter(ridged4,.84,.01)
									local caveOpenings = (surface and 1 or 0) * thresholdFilter(getPerlin(x,0,z,143,62),.35,0)	--.45
									caves = caves2 * caves3 * caves4 - caveOpenings
									caves = caves < 0 and 0 or caves > 1 and 1 or caves
					end

					local comp = preCaveComp - caves

					local smoothedResult = thresholdFilter(comp,.5,smoothScale)

					---below water level				  -above surface		-no terrain
					if 1-verticalGradient < waterLevel and preCaveComp <= .5 and smoothedResult <= 0 then
						smoothedResult = 1
						choiceSurface = water
						choiceFill = water
						surface = true
					end

					oMapY[z] = (y == 1 and 1) or smoothedResult
					mMapY[z] = (y == 1 and lava) or (smoothedResult <= 0 and air) or (surface and choiceSurface) or choiceFill
				end
			end

			local regionStart = Vector3.new(mapWidth*-2+(x-1)*4,mapHeight*-2,mapWidth*-2)
			local regionEnd = Vector3.new(mapWidth*-2+x*4,mapHeight*2,mapWidth*2)
			local mapRegion = Region3.new(regionStart, regionEnd)
			terrain:WriteVoxels(mapRegion, 4, {mMapX}, {oMapX})

			local completionPercent = x/mapWidth
			barFill.Size = UDim2.new(completionPercent,0,1,0)

			wait()
			while paused and not cancelIt do
				wait()
			end
			if cancelIt then
				break
			end
		end
		changeHistoryService:SetWaypoint('Terrain Generation')
		progressFrame.Visible = false
		generating = false
		print('Generation Complete',tick()-startTime)
	end
end


module.On = function(theTool)
	screenGui.Parent = coreGui
	terrainGenerationFrame.Visible = true
	on = true
end

module.Off = function()
	on = false
	screenGui.Parent = nil
	terrainGenerationFrame.Visible = false
end

function clearTerrain()
	if not generating and not clearing then
		clearing = true
		terrain:Clear()
		changeHistoryService:SetWaypoint('Terrain Clear')
		clearing = false
	end
end


return module


]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX79e76b9a4c8d42648c667ba66c56ce98">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GuiUtilities</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local module = {}


module.kTitleBarHeight = 27
module.kInlineTitleBarHeight = 24

module.kStandardContentAreaWidth = 180

module.kStandardPropertyHeight = 30
module.kSubSectionLabelHeight = 20

module.kStandardVMargin = 7
module.kStandardHMargin = 16

module.StandardLineLabelLeftMargin = 10
module.StandardLineElementLeftMargin = 90
module.StandardLineLabelWidth = (module.StandardLineElementLeftMargin - module.StandardLineLabelLeftMargin - 10 )

module.kDropDownHeight = 55

module.kStandardTextColor = Color3.new(0, 0, 0)                      --todo: input spec text color
module.kDisabledTextColor = Color3.new(.4, .4, .4)                   --todo: input spec disabled text color
module.kStandardButtonTextColor = Color3.new(0, 0, 0)                --todo: input spec disabled text color
module.kPressedButtonTextColor = Color3.new(1, 1, 1)                 --todo: input spec disabled text color

module.kButtonStandardBackgroundColor = Color3.new(1, 1, 1)          --todo: sync with spec
module.kButtonStandardBorderColor = Color3.new(.4,.4,.4)             --todo: sync with spec
module.kButtonDisabledBackgroundColor = Color3.new(.7,.7,.7)         --todo: sync with spec
module.kButtonDisabledBorderColor = Color3.new(.6,.6,.6)             --todo: sync with spec

module.kBottomButtonsFrameHeight = 40
module.kBottomButtonsHeight = 28

module.kShapeButtonSize = 32

module.kStandardWhite = Color3.new(1, 1, 1)

local kSelectedImageWithTextButtonColor = Color3.new(0.85, 0.85, 0.85)

local kDeselectedButtonColor = Color3.new(1, 1, 1)


local kRowStripeColor = Color3.new(0.95, 0.95, 0.95)

local kRowStripeColors = {}
kRowStripeColors[0] = kRowStripeColor
kRowStripeColors[1] = module.kStandardWhite

local kButtonImageIdDefault = 1532597154
local kButtonImageIdHovered = 1532596912
local kButtonImageIdPressed = 1532596488

module.kMainFrame = nil


function module.SetMainFrame(frame)
    module.kMainFrame = frame
end


-- A frame with standard styling.
function module.MakeFrame(name)
    local frame = Instance.new("Frame")
    frame.Name = name
    frame.BackgroundTransparency = 0
    frame.BackgroundColor3 = Color3.new(1, 1, 1)
    frame.BorderSizePixel = 0

    return frame
end
    

-- A frame that is a whole line, containing some arbitrary sized widget.
function module.MakeFixedHeightFrame(name, height)
    local frame = module.MakeFrame(name)
    frame.Size = UDim2.new(1, 0, 0, height)

    return frame
end

-- A frame that is one standard-sized line, containing some standard-sized widget (label, edit box, dropdown, 
-- checkbox)
function module.MakeStandardFixedHeightFrame(name)
    return module.MakeFixedHeightFrame(name, module.kStandardPropertyHeight)
end

function module.AdjustHeightDynamicallyToLayout(frame, uiLayout, optPadding)
    if (not optPadding) then 
        optPadding = 0
    end

	local function updateSizes()
		frame.Size = UDim2.new(1, 0, 0, uiLayout.AbsoluteContentSize.Y + optPadding)
	end
	uiLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateSizes)
	updateSizes()
end

-- Assumes input frame has a List layout with sort order layout order.
-- Add frames in order as siblings of list layout, they will be laid out in order.
-- Color frame background accordingly.
function module.AddStripedChildrenToListFrame(listFrame, frames)
    for index, frame in ipairs(frames) do 
        frame.Parent = listFrame
        frame.LayoutOrder = index
        frame.BackgroundColor3 = kRowStripeColors[(index + 1) % 2]
        frame.BackgroundTransparency = 0
    end
end


function module.SetImageWithTextButtonSelectedState(button, selected)
    -- Image-with-text buttons have translucent background by default.
    -- When selected, the background becomes opaque(r), so we can see highlight
    -- color.
    if (selected) then
        button.BackgroundTransparency = 0.5
    else
        button.BackgroundTransparency = 1
    end
end

-- Create a button with image and text.
function module.MakeImageWithTextButton(name, 
      layoutOrder, 
      icon, 
      text, 
      buttonSize,
      imageSize, 
      imagePos, 
      textSize, 
     textPos)
    local button = Instance.new("ImageButton")
    button.Name = name
    button.AutoButtonColor = false
    button.Size = buttonSize
    button.BorderSizePixel = 1
    -- Image-with-text button has translucent background and "selected" background color.
    -- When selected we set transluency to not-zero so we see selected color.
    button.BackgroundTransparency = 1 
    button.BackgroundColor3 = kSelectedImageWithTextButtonColor

    button.LayoutOrder = layoutOrder

    local buttonIcon = Instance.new("ImageLabel")
    buttonIcon.BackgroundTransparency = 1
    buttonIcon.Image = icon or ""
    buttonIcon.Size = imageSize
    buttonIcon.Position = imagePos
    buttonIcon.Parent = button

    local textLabel = Instance.new("TextLabel")
    textLabel.BackgroundTransparency = 1
    textLabel.Text = text
    textLabel.Size = textSize
    textLabel.Position = textPos
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.SourceSans
    textLabel.Parent = button

    local uiTextSizeConstraint = Instance.new("UITextSizeConstraint")
    -- Spec asks for fontsize of 12 pixels, but in Roblox the text font sizes look smaller than the mock
    --Note: For this font the Roblox text size is 25.7% larger than the design spec. 
    uiTextSizeConstraint.MaxTextSize = 15		                                          
    uiTextSizeConstraint.Parent = textLabel

    return button
end

local function MakeSectionInternal(parentGui, name, title, contentHeight)
    local frame = Instance.new("Frame")
    frame.Name = name
    frame.BackgroundTransparency = 1
    frame.Parent = parentGui
    frame.BackgroundTransparency = 1
    frame.BorderSizePixel = 0
    
    -- If title is "nil', no title bar.
    local contentYOffset = 0
    local titleBar = nil
    if (title ~= nil) then  
        local titleBarFrame = Instance.new("Frame")
        titleBarFrame.Name = "TitleBarFrame"
        titleBarFrame.Parent = frame
        titleBarFrame.Position = UDim2.new(0, 0, 0, 0)
        titleBarFrame.LayoutOrder = 0

        local titleBar = Instance.new("TextLabel")
        titleBar.Name = "TitleBarLabel"
        titleBar.Text = title
        titleBar.Parent = titleBarFrame
        titleBar.BackgroundTransparency = 1
        titleBar.Position = UDim2.new(0, module.kStandardHMargin, 0, 0)

        contentYOffset = contentYOffset + module.kTitleBarHeight
    end

    frame.Size = UDim2.new(1, 0, 0, contentYOffset + contentHeight)

    return frame
end

-- FIXME(DBANKS)
-- 2018/03/19
-- This is temporary: remove it once we figure out multi-choice and we fix progress bar.
-- Creates frame with optional title bar.
-- Width will be full scale
-- Height will be contentHeight + titleBarHeight (if TB is present)
-- Handles all the styling for margins, fonts, etc.
-- Returns the frame.
function module.MakeSectionWithTitleBar(parentGui, name, title, contentHeight)  
    local frame = MakeSectionInternal(parentGui, name, title, contentHeight)
    if (title ~= nil) then 
        -- Tweaks for major title bar.
        frame.TitleBarFrame.Size = UDim2.new(1, 0, 0, module.kTitleBarHeight)
        frame.TitleBarFrame.BackgroundColor3 = Color3.new(0.85, 0.85, 0.85)
        frame.TitleBarFrame.BackgroundTransparency = 0
        frame.TitleBarFrame.TitleBarLabel.TextXAlignment = Enum.TextXAlignment.Center
        frame.TitleBarFrame.TitleBarLabel.Size = UDim2.new(1, -2 * module.kStandardHMargin, 0, module.kTitleBarHeight)
    end

    return frame
end

function module.MakeStandardPropertyLabel(text)
    local label = Instance.new('TextLabel')
    label.Name = 'Label'
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.SourceSans                    --todo: input spec font
    label.TextSize = 15                                  --todo: input spec font size
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.Text = text
    label.AnchorPoint = Vector2.new(0, 0.5)
    label.Position = UDim2.new(0, module.StandardLineLabelLeftMargin, 0.5, 0)
    label.Size = UDim2.new(0, module.StandardLineLabelWidth, 1, 0)
    return label
end

function module.MakeFrameWithSubSectionLabel(name, text)
    local row = module.MakeFixedHeightFrame(name, module.kSubSectionLabelHeight)
    row.BackgroundTransparency = 1
        
    local label = module.MakeStandardPropertyLabel(text)
    label.BackgroundTransparency = 1
    label.Parent = row

    return row
end

local function updateButtonVisual(button, clickedDown, hovered)
    if button then
        print("Hi oo1")
        button.Image = 'http://www.roblox.com/asset/?id=' .. (
            (clickedDown and kButtonImageIdPressed) or (hovered and kButtonImageIdHovered) or kButtonImageIdDefault
        )
        local textLabel = button:FindFirstChild('TextLabel')
        if textLabel then
            textLabel.TextColor3 = clickedDown and module.kPressedButtonTextColor or module.kStandardButtonTextColor
        end
    end
end

-- Creates a text button with standard look & feel.
function module.MakeTextButton(name, title, parent)
    local button = Instance.new('ImageButton')
    button.Name = name
    print("Hi oo2")
    button.Image = 'http://www.roblox.com/asset/?id=' .. kButtonImageIdDefault
    button.BackgroundTransparency = 1
    button.ScaleType = Enum.ScaleType.Slice
    button.SliceCenter = Rect.new(7, 7, 156, 36)
    button.AutoButtonColor = false

    local label = Instance.new('TextLabel')
    label.Text = title
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.Font = Enum.Font.SourceSans                    --todo: input spec font
    label.TextSize = 18                                  --todo: input spec font size
    label.Parent = button

    local hovered = false
    local clickedDown = false
    button.MouseEnter:connect(function()
        hovered = true
        updateButtonVisual(button, clickedDown, hovered)
    end)
    button.MouseLeave:connect(function()
        hovered = false
        clickedDown = false
        updateButtonVisual(button, clickedDown, hovered)
    end)
    updateButtonVisual(button, clickedDown, hovered)
    button.MouseButton1Down:connect(function()
        clickedDown = true
        updateButtonVisual(button, clickedDown, hovered)
    end)
    button.MouseButton1Up:connect(function()
        clickedDown = false
        updateButtonVisual(button, clickedDown, hovered)
    end)
    updateButtonVisual(button, clickedDown, hovered)

    button.Parent = parent

    return button
end

-- Create a button to define brush shape.
function module.MakeShapeButton(name, imageAsset, parent)
    local button = Instance.new("ImageButton")
    button.Parent = parent
    button.Image = imageAsset
    button.Size = UDim2.new(0, module.kShapeButtonSize, 0, module.kShapeButtonSize)
    button.Name = name

    return button
end

function module.StyleScrollingFrame(scrollingFrame)
    scrollingFrame.ClipsDescendants = true
    scrollingFrame.ScrollingEnabled = true
    scrollingFrame.BottomImage = "rbxasset://textures/ui/studs.png"
    scrollingFrame.TopImage = "rbxasset://textures/ui/studs.png"
    scrollingFrame.MidImage = "rbxasset://textures/ui/smooth.png"
    scrollingFrame.ScrollBarThickness = 12
    scrollingFrame.HorizontalScrollBarInset = Enum.ScrollBarInset.None
    scrollingFrame.VerticalScrollBarInset = Enum.ScrollBarInset.None
    scrollingFrame.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
end

function module.MakeFrameAutoScalingList(frame)
    local uiListLayout = Instance.new("UIListLayout")
    uiListLayout.Parent = frame
    uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder

    module.AdjustHeightDynamicallyToLayout(frame, uiListLayout)
end


return module]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX547c539f22d34a15a07a7c5e8b11c3e4">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MainPanel</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local module = {}

local GuiUtilities = require(script.Parent.GuiUtilities)

local kMainButtonOuterSize = 51
local kMainButtonBorderSize = 1
local kMainButtonActualSize = (kMainButtonOuterSize - 2 * kMainButtonBorderSize)

local kMainButtonActualSizeUDim2 = UDim2.new(0, kMainButtonActualSize, 0, kMainButtonActualSize)
local kMainButtonOuterSizeUDim2 = UDim2.new(0, kMainButtonOuterSize, 0, kMainButtonOuterSize)

local kMainButtonFramePadding = UDim.new(0, 4)

local kMainButtonListFrame

--[[
	How tool modules work:
		Your ModuleScript should return a table. The table can contain the following functions
			On	= This function will be called when your tool is selected. Will hand in the mouse object, and the tool.
			Off	= This function will be called when your tool is deselected.
			BrushOperation = If this function is present, the tool will use the basic brushing functionality, and use this function as the operation
				operation(centerPoint, materialsTable, occupanciesTable, resolution, selectionSize, strength, desiredMaterial, brushShape, minBounds, maxBounds)
			FirstTimeSetup = A function that can hold back the majority of the code from being setup until the tool is used for the first time
]]


local modules =
{
	Brush = require(script.Parent.TerrainBrush),
	TerrainGeneration = require(script.Parent.TerrainGeneration),
	TerrainSmoother = require(script.Parent.TerrainSmoother),
	TerrainRegionEditor = require(script.Parent.TerrainRegionEditor)
}

local kMainButtonConfigs = 
{
    {
        Name = "Generate",
        Text = "Generate",
		Tip = 'Generate landscapes of terrain.',
		Icon = 'http://www.roblox.com/asset/?id=236006872',
		Modules = {modules.TerrainGeneration},
		LayoutOrder = 1,
    }, 
    {
        Name = "Add",
        Text = "Add",
		Tip = 'Click and hold to add terrain.',
		Icon = 'http://www.roblox.com/asset/?id=225328572',
		Modules = {modules.Brush,},
		UsesMaterials = true,
		LayoutOrder = 2,
    }, 
    {
        Name = "Subtract",
        Text = "Subtract",
		Tip = 'Click and hold to remove terrain.',
		Icon = 'http://www.roblox.com/asset/?id=225328818',
		Modules = {modules.Brush,},
		LayoutOrder = 3,
    }, 
    {
        Name = "Paint",
        Text = "Paint",
		Tip = 'Paint the material of the terrain.',
		Icon = 'http://www.roblox.com/asset/?id=225328954',
		Modules = {modules.Brush,},
		UsesMaterials = true,
		LayoutOrder = 4,
    }, 
    {
        Name = "Grow",
        Text = "Grow",
		Tip = 'Click and hold to grow and expand terrain.',
		Icon = 'http://www.roblox.com/asset/?id=225329153',
		Modules = {modules.Brush,},
		UsesMaterials = true,
		LayoutOrder = 5,
    }, 
    {
        Name = "Erode",
        Text = "Erode",
		Tip = 'Click and hold to erode and remove terrain.',
		Icon = 'http://www.roblox.com/asset/?id=225329301',
		Modules = {modules.Brush,},
		LayoutOrder = 6,
    }, 
    {
        Name = "Smooth",
        Text = "Smooth",
		Tip = 'Brush to smooth out rough or jagged terrain.',
		Icon = 'http://www.roblox.com/asset/?id=225329641',
		Modules = {modules.Brush, modules.TerrainSmoother,},
		LayoutOrder = 7,
    }, 
    {
        Name = "Regions",
        Text = "Regions",
		Tip = 'Manipulate regions of smooth terrain.',
		Icon = 'http://www.roblox.com/asset/?id=240631063',
		Modules = {modules.TerrainRegionEditor,},
		LayoutOrder = 8,
    }, 
}


local function createMainButton(mainButtonConfig)	
	local button = GuiUtilities.MakeImageWithTextButton(mainButtonConfig.Name, 
		mainButtonConfig.LayoutOrder, 
		mainButtonConfig.Icon, 
		mainButtonConfig.Text, 
		kMainButtonActualSizeUDim2,
		UDim2.new(0,26,0,26), 
		UDim2.new(0,13,0,3),
		UDim2.new(1,0,0,22), 
		UDim2.new(0,0,1,-22))

	button.Parent = kMainButtonListFrame
	mainButtonConfig.Button = button
end


-- Creates the main panel for tools, and creates the scrolling frame for sub-content section.
-- The main panel will be resized dynamically when widget is stretched horizontally
-- The content section will resize to fill the rest of the vertical space that the main panel is not using.
-- Returns the main panel, and returns the sub-content section
function makeMainPanel()
	-- Make the main panel for tool buttons
	local section = GuiUtilities.MakeFixedHeightFrame("MainPanel",  100)	
	section.Parent = pluginGui
	section.Position = UDim2.new(0, 0, 0, 0)

	GuiUtilities.SetMainFrame(section)

	local buttonListFrame = Instance.new("Frame")
	buttonListFrame.Name = "ButtonListFrame"
	buttonListFrame.BackgroundTransparency = 1
	buttonListFrame.BorderSizePixel = 0
	buttonListFrame.Size = UDim2.new(1, 0, 1, 0)
	buttonListFrame.Position = UDim2.new(0, 0, 0, 0)
	buttonListFrame.Parent = section

	local uiGridLayout = Instance.new("UIGridLayout")
	uiGridLayout.CellSize = kMainButtonOuterSizeUDim2
	uiGridLayout.CellPadding = UDim2.new(0,0,0,0)
	uiGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	uiGridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiGridLayout.Parent = buttonListFrame
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder

	local uiPadding = Instance.new("UIPadding")
	uiPadding.PaddingBottom = kMainButtonFramePadding
	uiPadding.PaddingLeft = kMainButtonFramePadding
	uiPadding.PaddingRight = kMainButtonFramePadding
	uiPadding.PaddingTop = kMainButtonFramePadding
	uiPadding.Parent = buttonListFrame

	-- Make the visual that sits behind the scrollbar and gives the scrollbar thumb visual contrast
	local scrollbarBackground = Instance.new('Frame')
	scrollbarBackground.Name = 'ScrollbarBackground'
	scrollbarBackground.BackgroundColor3 = Color3.fromRGB(238, 238, 238)
	scrollbarBackground.BorderColor3 = Color3.fromRGB(182, 182, 182)
	scrollbarBackground.Parent = pluginGui

	-- Make the content section scrolling frame
	local mainSpaceScrollingFrame = Instance.new("ScrollingFrame")
	mainSpaceScrollingFrame.Name = "MainSpace"
	mainSpaceScrollingFrame.VerticalScrollBarPosition = Enum.VerticalScrollBarPosition.Right
	mainSpaceScrollingFrame.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
	mainSpaceScrollingFrame.ElasticBehavior = Enum.ElasticBehavior.Never
	mainSpaceScrollingFrame.ScrollBarThickness = 17
	mainSpaceScrollingFrame.BorderSizePixel = 0
	mainSpaceScrollingFrame.BackgroundTransparency = 1
	mainSpaceScrollingFrame.ZIndex = 2
	mainSpaceScrollingFrame.TopImage = "http://www.roblox.com/asset/?id=1533255544"
	mainSpaceScrollingFrame.MidImage = "http://www.roblox.com/asset/?id=1535685612"
	mainSpaceScrollingFrame.BottomImage = "http://www.roblox.com/asset/?id=1533256504"

	local uiListLayout = Instance.new("UIListLayout")
	uiListLayout.Parent = mainSpaceScrollingFrame
	uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder

	mainSpaceScrollingFrame.Parent = pluginGui

	-- The scrollbar backing should only be visible when the scrollbar is visible
	local function updateScrollbarBackingVisibility()
		scrollbarBackground.Visible = mainSpaceScrollingFrame.CanvasSize.Y.Offset > mainSpaceScrollingFrame.AbsoluteSize.Y
	end

	-- Adjust the vertical size of the main buttons panel and the main panel details space when the main panel buttons change the number of rows are being rendered
	local function updateMainSectionsSizesAndPositions()
		section.Size = UDim2.new(1, 0, 0, uiGridLayout.AbsoluteContentSize.Y+kMainButtonFramePadding.Offset*2)
		mainSpaceScrollingFrame.Size = UDim2.new(1, 0, 1, -section.AbsoluteSize.Y)
		mainSpaceScrollingFrame.Position = UDim2.new(0, 0, 0, section.AbsolutePosition.Y+section.AbsoluteSize.Y)
		scrollbarBackground.Size = UDim2.new(0, mainSpaceScrollingFrame.ScrollBarThickness-2, 1, -section.AbsoluteSize.Y-2)
		scrollbarBackground.Position = UDim2.new(1, -mainSpaceScrollingFrame.ScrollBarThickness+1, 0, section.AbsolutePosition.Y+section.AbsoluteSize.Y+1)
		updateScrollbarBackingVisibility()
	end
	uiGridLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateMainSectionsSizesAndPositions)
	updateMainSectionsSizesAndPositions()

	-- Update the canvas size of the scrolling frame to fit the size of it's contents
	local function updateScrollingFrameCanvas()
		mainSpaceScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, uiListLayout.AbsoluteContentSize.Y)
		updateScrollbarBackingVisibility()
	end
	uiListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateScrollingFrameCanvas)
	updateScrollingFrameCanvas()

	contentFrame = mainSpaceScrollingFrame
	kMainButtonListFrame = buttonListFrame
end

local function fastSpawn(func)	-- Creates a new thread like Spawn() but executes the code immediately, without a frame delay.
	coroutine.wrap(func)()
end


module.Initialize = function(thePlugin, thePluginGui)
	on = false
	currentMainButtonConfig = nil
	plugin = thePlugin
	pluginGui = thePluginGui
	makeMainPanel()
	local mouse = plugin:GetMouse()
	local userInput = game:GetService('UserInputService')
	local prevCameraType = game.Workspace.CurrentCamera.CameraType

	for mainButtonIndex, mainButtonConfig in ipairs(kMainButtonConfigs) do
		createMainButton(mainButtonConfig)
		mainButtonConfig.Button.MouseButton1Click:connect(function()
			if not on or (currentMainButtonConfig ~= nil and mainButtonConfig ~= currentMainButtonConfig) then	--if off or on but current tool isn't the desired tool, then select this tool.
				Selected(mainButtonConfig)
			else
				Deselected()
			end
		end)

	end


	-- If the plugin gui is disabled, we should definitely be deselected.
	pluginGui:GetPropertyChangedSignal("Enabled"):Connect(function()
		if (not pluginGui.Enabled) then 
			Deselected()
		end
	end)

	function Selected(tool)
		if plugin then
			plugin:Activate(true)
		end

		if not userInput.MouseEnabled then
			prevCameraType = game.Workspace.CurrentCamera.CameraType
			game.Workspace.CurrentCamera.CameraType = Enum.CameraType.Fixed	
		end

		GuiUtilities.SetImageWithTextButtonSelectedState(tool.Button, true)

		on = true
		currentMainButtonConfig = tool

		--local toolModule = tool.Module or module.Brush
		for _, toolModule in pairs(tool.Modules) do
			fastSpawn(function()
				if toolModule.FirstTimeSetup and not toolModule.isSetup then
					toolModule.FirstTimeSetup(mouse, pluginGui, contentFrame)
					toolModule.isSetup = true
				end
				if toolModule.On then
					toolModule.On(tool)
				end
			end)
		end
	end
	
	function Deselected()
		if not userInput.MouseEnabled then
			game.Workspace.CurrentCamera.CameraType = prevCameraType		
		end

		on = false
		local lastTool = currentMainButtonConfig
		currentMainButtonConfig = nil

		if lastTool then
			GuiUtilities.SetImageWithTextButtonSelectedState (lastTool.Button, false)

			--local lastToolModule = lastTool.Module or module.Brush
			for _, lastToolModule in pairs(lastTool.Modules) do
				fastSpawn(function()
					if lastToolModule.Off then
						lastToolModule.Off()
					end
				end)
			end
		end
	end

	if plugin then
		plugin.Deactivation:connect(function()
			if on then
				Deselected()
			end
		end)
	end

end


return module]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX2375ab4d9469492b8163512bfd383fc6">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">main</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local mainPanelModule = require(script.parent.MainPanel)
local terrainBrushScriptModule = require(script.parent.TerrainBrush)

local kMinWidthWidth = 232

-- A function to sync toolbar button 'active' state with plugin gui
-- visibility.
local function updateButtonActive(button, plugin)
    if plugin.Enabled then 
      button:SetActive(true)
    else
      button:SetActive(false)
    end
end

local function IsTerrainToolsInLuaWidgetEnabled()
    local StudioTerrainToolsInLuaWidget = false
    local successFlagFetch, flagResult = pcall(function()
        return settings():GetFFlag("StudioTerrainToolsInLuaWidget")
    end)
    if successFlagFetch then
        StudioTerrainToolsInLuaWidget = flagResult
    end
    
    return StudioTerrainToolsInLuaWidget
end

-- If we are not using new-school terrain tools, bail immediately.
if (not IsTerrainToolsInLuaWidgetEnabled()) then 
    return
end

-- Create the toolbar, create the button to toggle terrain tools plugin GUI on/off.
local toolbar = plugin:CreateToolbar('TerrainToolsLuaToolbarName')
local toggleVisibilityButton = toolbar:CreateButton('Terrain Tools',
                'Add, remove, and modify terrain',
                'http://www.roblox.com/asset/?id=225329641')

local dockWidgetPluginGuiInfo = DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Left, false, false, 0, 0, kMinWidthWidth)

local pluginGui = plugin:CreateDockWidgetPluginGui("TerrainTools_PluginGui", dockWidgetPluginGuiInfo)
pluginGui.Title = "Terrain Tools"

toggleVisibilityButton.Click:connect(function()
    if pluginGui.Enabled then
        pluginGui.Enabled = false
    else
        pluginGui.Enabled = true
    end
end)


-- Immediately sync toolbar button active state with plugin gui visibility.   
updateButtonActive(toggleVisibilityButton, pluginGui)

-- Listen for changes in plugin gui visibility to keep toolbar button
-- active state synced.
pluginGui:GetPropertyChangedSignal("Enabled"):connect(function(property)
    updateButtonActive(toggleVisibilityButton, pluginGui)
end)     

-- Make sure plugin and pluginGui have nice user-facing names.
plugin.Name = "Terrain"
pluginGui.Name = "Tools"


-- Some craziness I don't fully understand.
local Terrain = workspace:WaitForChild('Terrain', 86400) or workspace:WaitForChild('Terrain')
while not Terrain.IsSmooth do
	Terrain.Changed:wait()
end

-- Add the main panel.
mainPanelModule.Initialize(plugin, pluginGui)





]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXe08ae87da37c4aac83f0576532f66686">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TerrainSmoother</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--

local module = {}

module.FirstTimeSetup = function(theMouse, thePluginGui, theContentFrame)
	local terrain = game.Workspace.Terrain

	local function getCell(list, x, y, z)
		return list and list[x] and list[x][y] and list[x][y][z]
	end

	local function extendRange(x)		--This is very important. It allows cells to fully diminish or fully fill by lying to the algorithm
		return x * 1.5 - .25
	end

	function getNeighborOccupanciesFast(list, x, y, z, includeSelf)
		local fullNeighbor = false
		local emptyNeighbor = false
		local neighborOccupancies = includeSelf and extendRange(getCell(list, x, y, z)) or 0
		local totalNeighbors = includeSelf and 1 or 0
		for axis = 1, 3 do
			for offset = -1, 1, 2 do
				local neighbor = nil
				if axis == 1 then
					neighbor = list[x + offset] and list[x + offset][y][z]
				elseif axis == 2 then
					neighbor = list[x][y + offset] and list[x][y + offset][z]
				elseif axis == 3 then
					neighbor = list[x][y][z + offset]
				end
				if neighbor then
					if neighbor >= 1 then
						fullNeighbor = true
					end
					if neighbor <= 0 then
						emptyNeighbor = true
					end
					neighbor = extendRange(neighbor)
					totalNeighbors = totalNeighbors + 1
					neighborOccupancies = neighborOccupancies + neighbor
				end
			end
		end
		return neighborOccupancies / (totalNeighbors > 0 and totalNeighbors or extendRange(getCell(list, x, y, z))), fullNeighbor, emptyNeighbor
	end

	function getNeighborOccupancies(list, x, y, z, includeSelf, range)
		local fullNeighbor = false
		local emptyNeighbor = false
		local range = range or 1
		local neighborOccupancies = 0
		local totalNeighbors = 0
		local sqrt = math.sqrt
		for ix = -range, range do
			for iy = -range, range do
				for iz = -range, range do
					if includeSelf or not (ix == 0 and iy == 0 and iz == 0) then
						local neighbor = getCell(list, x + ix, y + iy, z + iz)
						if neighbor then
							local distanceScale = 1 - (sqrt(ix * ix + iy * iy + iz * iz) / (range * 2))
							if neighbor >= 1 then
								fullNeighbor = true
							end
							if neighbor <= 0 then
								emptyNeighbor = true
							end
							neighbor = extendRange(neighbor)
							totalNeighbors = totalNeighbors + 1 * distanceScale
							neighborOccupancies = neighborOccupancies + neighbor * distanceScale
						end
					end
				end
			end
		end
		return neighborOccupancies / (totalNeighbors > 0 and totalNeighbors or extendRange(getCell(list, x, y, z))), fullNeighbor, emptyNeighbor
	end


	function operation(centerPoint, materials, occupancies, resolution, selectionSize, strength, desiredMaterial, brushType, minBounds, maxBounds)
		local region = Region3.new(minBounds, maxBounds)
		local readMaterials, readOccupancies = terrain:ReadVoxels(region, resolution)

		local radius = selectionSize * .5 * resolution

		local materialAir = Enum.Material.Air

		for ix, vx in ipairs(readOccupancies) do
			local cellVectorX = minBounds.x + (ix - .5) * resolution - centerPoint.x

			for iy, vy in pairs(vx) do
				local cellVectorY = minBounds.y + (iy - .5) * resolution - centerPoint.y

				for iz, cellOccupancy in pairs(vy) do
					local cellVectorZ = minBounds.z + (iz - .5) * resolution - centerPoint.z

					local cellMaterial = materials[ix][iy][iz]
					local distance = math.sqrt(cellVectorX * cellVectorX + cellVectorY * cellVectorY + cellVectorZ * cellVectorZ)
		
					local magnitudePercent = 1
					local brushOccupancy = 1
					if brushType == 'Sphere' then
						magnitudePercent = math.cos(math.min(1, distance / (radius + resolution * .5)) * math.pi * .5)
						brushOccupancy = math.max(0, math.min(1, (radius + .5 * resolution - distance) / resolution))
					elseif brushType == 'Box' then
						--leave as default
					end

					if brushOccupancy >= .5 then
						local neighborOccupancies, fullNeighbor, emptyNeighbor = getNeighborOccupancies(readOccupancies, ix, iy, iz, true, 1)
						local difference = (neighborOccupancies - cellOccupancy) * (strength + .1) * .5 * brushOccupancy * magnitudePercent

						if not fullNeighbor and difference > 0 then
							difference = 0
						elseif not emptyNeighbor and difference < 0 then
							difference = 0
						end

						if readMaterials[ix][iy][iz] == materialAir or cellOccupancy <= 0 and difference > 0 then
							materials[ix][iy][iz] = desiredMaterial
						end
						if difference ~= 0 then
							occupancies[ix][iy][iz] = math.max(0, math.min(1, cellOccupancy + difference))
						end
					end
				end
			end
		end
	end

	module.BrushOperation = operation

end

return module

]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXddaba16a358749708bb7322b7434ee4c">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TerrainRegionEditor</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[--Made by Stickmasterluke
local module = {}

--[[todo:
	-fill region (with material, action)
	-optimize resize scaling code more
]]
local GuiUtilities = require(script.Parent.GuiUtilities)
local MaterialsListClass = require(script.Parent.MaterialsList)
local VerticallyScalingListFrame = require(script.Parent.VerticallyScalingListFrame)
local CollapsibleTitledSection = require(script.Parent.CollapsibleTitledSection)
local LabeledCheckbox = require(script.Parent.LabeledCheckbox)

local Terrain = workspace:WaitForChild('Terrain', 86400) or workspace:WaitForChild('Terrain')
while not Terrain.IsSmooth do
	Terrain.Changed:wait()
end

local on = false
local currentTool = 'Create'

local pluginGui = nil
local contentFrame = nil
local terrainRegionFrame = nil
local fillFrame = nil

local kRegionButtonOuterWidth = 45
local kRegionButtonOuterHeight = 62
local kRegionButtonBorderSize = 0
local kRegionButtonActualWidth = (kRegionButtonOuterWidth - 2 * kRegionButtonBorderSize)
local kRegionButtonActualHeight = (kRegionButtonOuterHeight - 2 * kRegionButtonBorderSize)

local kRegionButtonActualSizeUDim2 = UDim2.new(0, kRegionButtonActualWidth, 0, kRegionButtonActualHeight)
local kRegionButtonOuterSizeUDim2 = UDim2.new(0, kRegionButtonOuterWidth, 0, kRegionButtonOuterHeight)

local kFillConfirmButtonWidth = 44
local kFillConfirmButtonHeight = 25
local kMaterialsListObject = nil

local kRegionModeButtonConfigs = 
{
    Select = {
        Text = "Select",
        Name = "ButtonSelect",
		Icon = 'http://www.roblox.com/asset/?id=1509930186',
		LayoutOrder = 1,
		Mode = 'Select',
		Tool = 'Resize',
    }, 
    Move = {
        Text = "Move",
        Name = "ButtonMove",
		Icon = 'http://www.roblox.com/asset/?id=1509929310',
		LayoutOrder = 2,
		Mode = 'Edit',
		Tool = 'Move',
    }, 
    Resize = {
        Text = "Resize",
        Name = "ButtonResize",
		Icon = 'http://www.roblox.com/asset/?id=1509929759',
		LayoutOrder = 3,
		Mode = 'Edit',
		Tool = 'Resize',
    }, 
    Rotate = {
        Text = "Rotate",
        Name = "ButtonRotate",
		Icon = 'http://www.roblox.com/asset/?id=1509929974',
		LayoutOrder = 4,
		Mode = 'Edit',
		Tool = 'Rotate',
	}, 
}

local kRegionOperationButtonConfigs = 
{
    Copy = {
        Text = "Copy",
        Name = "ButtonCopy",
		Icon = 'http://www.roblox.com/asset/?id=1509928608',
		LayoutOrder = 5,
    }, 
    Paste = {
        Text = "Paste",
        Name = "ButtonPaste",
		Icon = 'http://www.roblox.com/asset/?id=1509929519',
		LayoutOrder = 6,
    }, 
	Delete = {
        Text = "Delete",
        Name = "ButtonDelete",
		Icon = 'http://www.roblox.com/asset/?id=1509928878',
		LayoutOrder = 7,
    }, 
	Fill = {
        Text = "Fill",
        Name = "ButtonFill",
		Icon = 'http://www.roblox.com/asset/?id=1509929069',
		LayoutOrder = 8,
    }, 
}

local function createRegionButton(parent, buttonConfig)
	local button = GuiUtilities.MakeImageWithTextButton(buttonConfig.Name, 
		buttonConfig.LayoutOrder, 
		buttonConfig.Icon, 
		buttonConfig.Text, 
		kRegionButtonActualSizeUDim2,
		UDim2.new(0,45,0,36), 
		UDim2.new(0,0,0,0),
		UDim2.new(1,0,0,22), 
		UDim2.new(0,0,1,-22))

	button.Parent = parent
	buttonConfig.Button = button
end

function MakeButtonGridInFrameWithTitle(buttonConfigs, name, title) 
	local vsf = VerticallyScalingListFrame.new(name)

	local labelFrame = GuiUtilities.MakeFrameWithSubSectionLabel("Label", title)
	vsf:AddChild(labelFrame)

	local buttonListFrame = GuiUtilities.MakeFixedHeightFrame("grid", kRegionButtonOuterHeight + 2 * GuiUtilities.kStandardVMargin)
	vsf:AddChild(buttonListFrame)
	buttonListFrame.BackgroundTransparency = 1

	local uiGridLayout = Instance.new("UIGridLayout")
	uiGridLayout.CellSize = kRegionButtonOuterSizeUDim2
	uiGridLayout.CellPadding = UDim2.new(0,0,0,0)
	uiGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	uiGridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	uiGridLayout.Parent = buttonListFrame
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder

	local uiPadding = Instance.new("UIPadding")
	uiPadding.PaddingBottom = UDim.new(0, GuiUtilities.kStandardVMargin)
	uiPadding.PaddingTop = UDim.new(0, GuiUtilities.kStandardVMargin)
	uiPadding.PaddingLeft = UDim.new(0, GuiUtilities.kStandardHMargin)
	uiPadding.PaddingRight = UDim.new(0, GuiUtilities.kStandardHMargin)
	uiPadding.Parent = buttonListFrame

	for buttonId, buttonConfig in pairs(buttonConfigs) do
		createRegionButton(buttonListFrame, buttonConfig)
	end

	return vsf:GetFrame()
end

function MakeModeButtonsFrame()
	local frame = MakeButtonGridInFrameWithTitle(kRegionModeButtonConfigs, "ModeFrame", "Tools")
	return frame
end

function MakeOperationButtonsFrame()
	local frame = MakeButtonGridInFrameWithTitle(kRegionOperationButtonConfigs, "OperationFrame", "Edit")
	return frame
end

function AddToFrameInOrder(childElement, parentFrame, order)
	childElement.Parent = parentFrame
	childElement.LayoutOrder = order
end

local function MakeButtonsFrame()
	local frame = GuiUtilities.MakeFixedHeightFrame("Buttons", GuiUtilities.kBottomButtonsFrameHeight)

	local okButton = GuiUtilities.MakeTextButton("OkButton", "OK", frame)
	okButton.Size = UDim2.new(0, kFillConfirmButtonWidth, 0, GuiUtilities.kBottomButtonsFrameHeight)
	okButton.Position = UDim2.new(0.5, -kFillConfirmButtonWidth/2, 0.5, -GuiUtilities.kBottomButtonsHeight/2)
	
	return frame
end


function MakeFillFrame(pluginGui)
	local vsl = VerticallyScalingListFrame.new("mwt")

	local titleLabel = GuiUtilities.MakeFrameWithSubSectionLabel("Material", "Fill Selection")
	vsl:AddChild(titleLabel)

	kMaterialsListObject = MaterialsListClass.new()
	local materialsFrame = kMaterialsListObject:GetMaterialsFrame()
	vsl:AddChild(materialsFrame)

	local buttonFrame = MakeButtonsFrame()
	vsl:AddChild(buttonFrame)

	vsl:GetFrame().Visible = false
	return vsl:GetFrame()
end

module.FirstTimeSetup = function(theMouse, thePluginGui, theContentFrame)
	mouse = theMouse
	pluginGui = thePluginGui
	contentFrame = theContentFrame
	local changeHistory = game:GetService('ChangeHistoryService')
	local terrain = game.Workspace.Terrain
	local coreGui = game:GetService('CoreGui')

	screenGui = Instance.new("ScreenGui")

	-- Size will be updated dynamically.
	local editCollapsibleSectionObj = CollapsibleTitledSection.new("Edit", "Edit Tools", true, true)
	GuiUtilities.MakeFrameAutoScalingList(editCollapsibleSectionObj:GetContentsFrame())
	editCollapsibleSectionObj:GetSectionFrame().Parent = contentFrame

	-- First child: the "merge empty" button(s).
	local checkboxObj = LabeledCheckbox.new("CheckboxFrame", "Merge Empty", false)

	-- Second child: the "Mode" buttons.
	local modeButtonsFrame = MakeModeButtonsFrame()

	-- Third child: the "Operation" buttons.
	local operationButtonsFrame = MakeOperationButtonsFrame()

	-- Forth child: the "Fill" frame.
	local fillFrame = MakeFillFrame()

	GuiUtilities.AddStripedChildrenToListFrame(editCollapsibleSectionObj:GetContentsFrame(), {
		checkboxObj:GetFrame(), 
		modeButtonsFrame,
		operationButtonsFrame, 
		fillFrame})

	editCollapsibleSectionObj:GetSectionFrame().Visible = false
	terrainRegionFrame = editCollapsibleSectionObj:GetSectionFrame()

	local buttonSelect = modeButtonsFrame.grid.ButtonSelect
	local buttonMove = modeButtonsFrame.grid.ButtonMove
	local buttonResize = modeButtonsFrame.grid.ButtonResize
	local buttonRotate = modeButtonsFrame.grid.ButtonRotate
	local buttonCopy = operationButtonsFrame.grid.ButtonCopy
	local buttonPaste = operationButtonsFrame.grid.ButtonPaste
	local buttonDelete = operationButtonsFrame.grid.ButtonDelete
	local buttonFill = operationButtonsFrame.grid.ButtonFill

	local materialsTable = MaterialsListClass.MaterialsTable
	local buttonFillConfirm = fillFrame.Buttons.OkButton
	--local mouse = plugin:GetMouse()

	----SETTINGS----
	local mode = 'Select'	--Select, Edit
	local tool = 'None'		--None, Resize, Move, Rotate
	local currentButtonId = 'Select'
	
	local fillAir = true
	local fillWater = true
	----------------

	--SUB SETTINGS--
	local resolution = 4			--This is the size of voxels on Roblox. Why is this a variable? ;)
	local textSelectColor = Color3.new(72/255, 145/255, 212/255)
	local white = Color3.new(238/255, 238/255, 238/255)
	local editColor1 = 'Institutional white'
	local editColor2 = 'Light stone grey'
	local rotationInterval = math.pi * .5
	local regionLengthLimit = 125
	----------------

	--Variables--
	local faceToNormal = {
		[Enum.NormalId.Top] = Vector3.new(0, 1, 0),
		[Enum.NormalId.Bottom] = Vector3.new(0, -1, 0),
		[Enum.NormalId.Left] = Vector3.new(-1, 0, 0),
		[Enum.NormalId.Right] = Vector3.new(1, 0, 0),
		[Enum.NormalId.Front] = Vector3.new(0, 0, -1),
		[Enum.NormalId.Back] = Vector3.new(0, 0, 1),
	}
	local undefined=0/0
	local selectionStart = nil
	local selectionEnd = nil
	local selectionPart = nil
	local selectionObject = nil
	local selectionHandles = nil
	kMaterialsListObject:SetMaterialSelection(materialsTable[5])
	local downLoop = nil
	local clickStart = Vector3.new(0, 0, 0)
	local dragVector = nil
	local dragStart = true
	local lockedMaterials, lockedOccupancies = nil, nil
	local lockedRegion = nil
	local behindThis = nil
	local axis = 'X'
	local materialAir = Enum.Material.Air
	local materialWater = Enum.Material.Water
	local floor = math.floor		--Scaling linear resize
	local ceil = math.ceil
	-------------

	function updateButtonSelectionState(newButtonId, buttonId)
		GuiUtilities.SetImageWithTextButtonSelectedState(kRegionModeButtonConfigs[buttonId].Button, newButtonId == buttonId)
	end

	function setButton(newButtonId)
		lockInMap()

		for buttonId, buttonConfig in pairs(kRegionModeButtonConfigs) do
			updateButtonSelectionState(newButtonId, buttonId)
		end

		if (newButtonId ~= nil) then 			
			mode = kRegionModeButtonConfigs[newButtonId].Mode
			tool = kRegionModeButtonConfigs[newButtonId].Tool
		end

		currentButtonId = newButtonId
		renderSelection()
	end

	buttonSelect.MouseButton1Down:connect(function()
		setButton('Select')
	end)
	buttonMove.MouseButton1Down:connect(function()
		setButton('Move')
	end)
	buttonResize.MouseButton1Down:connect(function()
		setButton('Resize')
	end)
	buttonRotate.MouseButton1Down:connect(function()
		setButton('Rotate')
	end)

	checkboxObj:SetValueChangedFunction(function(value) 
		fillAir = value
		if currentButtonId=='Move' or currentButtonId=='Resize' then
			updateDragOperation()
		elseif currentButtonId=='Rotate' then
			updateRotateOperation()
		end
	end)

	function lockInMap()	--Should call this every time the terrain under your selection changes. Don't for resize though, it uses the original lockin for rescaling.
		if selectionStart and selectionEnd then
			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			lockedRegion = region
			lockedMaterials, lockedOccupancies = terrain:ReadVoxels(region, resolution)
		end
	end

	do
		local runService = game:GetService('RunService').RenderStepped
		function quickWait(waitTime)
			if not waitTime then
				runService:wait()
			elseif waitTime < .033333 then
				local startTick = tick()
				runService:wait()
				local delta = tick() - startTick
				if delta <= waitTime * .5 then
					quickWait(waitTime - delta)
				end
			else
				wait(waitTime)
			end
		end
	end

	function clearSelection()
		if selectionArcHandles then
			selectionArcHandles:Destroy()
			selectionArcHandles = nil
		end
		if selectionHandles then
			selectionHandles:Destroy()
			selectionHandles = nil
		end
		if selectionObject then
			selectionObject:Destroy()
			selectionObject = nil
		end
		if selectionPart then
			selectionPart:Destroy()
			selectionPart = nil
		end
	end

	local function round(n)
		return n + .5 - ((n + .5)%1)
	end

	local function positionWorldToVoxel(pos)
		return Vector3.new(ceil(pos.x / resolution), ceil(pos.y / resolution), ceil(pos.z / resolution))
	end

	local function make3DTable(size,fill)
		local size = size or Vector3.new(1,1,1)
		local newTable = {}
		for x = 1, size.x do
			local xt = {}
			for y = 1, size.y do
				local yt = {}
				for z = 1, size.z do
					yt[z] = fill
				end
				xt[y] = yt
			end
			newTable[x] = xt
		end
		return newTable
	end

	local function linInterp(a,b,p)
		return a+(b-a)*p
	end

	local function exaggerate(n,exaggeration)
		return (n-.5)*exaggeration + .5		--optimized
		--return n*exaggeration - exaggeration*.5 + .5
	end
	local function exaggeratedLinInterp(a,b,p,exaggeration)
		local unclamped = (a+(b-a)*p-.5)*exaggeration+.5
		return (unclamped < 0 and 0) or (unclamped > 1 and 1) or unclamped

		--At first I thought this didn't need to be clamped because the terrain clamps that anways.
		--But I then realized I am using this number a bit more before handing it to terrain.
		--After doing some tests. Clamping is necessary for artificial structures being streched. If unclamped, rounding of artificial edges occurs.
		--return (a+(b-a)*p-.5)*exaggeration+.5
		--Maybe this extra dimension of unclamping might be desired for natural terrain, but not artificuial?
	end

	function updateDragOperation()
		local dragVector = dragVector or Vector3.new(0,0,0)
		local temporaryStart = selectionStart
		local temporaryEnd = selectionEnd
		if tool == 'Resize' then
			if dragStart then
				temporaryStart = Vector3.new(
					math.min(
						math.max(temporaryStart.x+dragVector.x,temporaryEnd.x-regionLengthLimit),
						temporaryEnd.x),
					math.min(
						math.max(temporaryStart.y+dragVector.y,temporaryEnd.y-regionLengthLimit),
						temporaryEnd.y),
					math.min(
						math.max(temporaryStart.z+dragVector.z,temporaryEnd.z-regionLengthLimit),
						temporaryEnd.z)
				)
			else
				temporaryEnd = Vector3.new(
					math.max(
						math.min(temporaryEnd.x+dragVector.x,temporaryStart.x+regionLengthLimit),
						temporaryStart.x),
					math.max(
						math.min(temporaryEnd.y+dragVector.y,temporaryStart.y+regionLengthLimit),
						temporaryStart.y),
					math.max(
						math.min(temporaryEnd.z+dragVector.z,temporaryStart.z+regionLengthLimit),
						temporaryStart.z)
				)
			end
			if mode == 'Edit' then
				local region = Region3.new((temporaryStart - Vector3.new(1,1,1)) * resolution, temporaryEnd * resolution)
				if behindThis then
					terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
				else
					if selectionStart and selectionEnd then
						local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
						local regionSize = region.Size / resolution
						terrain:WriteVoxels(region, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
					end
				end
				behindThis = {}
				behindThis.region = region
				behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

				local behindMaterials, behindOccupancies = behindThis.materials, behindThis.occupancies

				local loopx = #lockedMaterials - 1
				local loopy = #lockedMaterials[1] - 1
				local loopz = #lockedMaterials[1][1] - 1
				local tempRegionSize = Vector3.new(1,1,1) + temporaryEnd - temporaryStart
				local tempSizeX = tempRegionSize.x
				local tempSizeY = tempRegionSize.y
				local tempSizeZ = tempRegionSize.z
				local newMat = {}
				local newOcc = {}
				for x=1, tempSizeX do
					local scalex = (x-1)/(tempSizeX-1)*loopx
					if scalex ~= scalex then
						scalex = 0
					end
					local startx = floor(scalex)+1
					local endx = startx+1
					local interpScalex = scalex-startx+1
					if startx > loopx then
						endx = startx
					end
		
					local xtm = {}
					local xto = {}
					for y=1, tempSizeY do
						local scaley = (y-1)/(tempSizeY-1)*loopy
						if scaley ~= scaley then
							scaley = 0
						end
						local starty = floor(scaley)+1
						local endy = starty+1
						local interpScaley = scaley-starty+1
						if starty > loopy then
							endy = starty
						end
		
						local ytm = {}
						local yto = {}
						for z=1, tempSizeZ do
							local scalez = (z-1)/(tempSizeZ-1)*loopz	--consider adding 1 here and removing +1's elsewhere
							if scalez ~= scalez then		--undefined check
								scalez = 0
							end
							local startz = floor(scalez)+1
							local endz = startz+1
							local interpScalez = scalez-startz+1
							if startz > loopz then
								endz = startz
							end
		
							local interpz1 = exaggeratedLinInterp(lockedOccupancies[startx][starty][startz],lockedOccupancies[startx][starty][endz],interpScalez, tempSizeZ/(loopz+1))
							local interpz2 = exaggeratedLinInterp(lockedOccupancies[startx][endy][startz],lockedOccupancies[startx][endy][endz],interpScalez, tempSizeZ/(loopz+1))
							local interpz3 = exaggeratedLinInterp(lockedOccupancies[endx][starty][startz],lockedOccupancies[endx][starty][endz],interpScalez, tempSizeZ/(loopz+1))
							local interpz4 = exaggeratedLinInterp(lockedOccupancies[endx][endy][startz],lockedOccupancies[endx][endy][endz],interpScalez, tempSizeZ/(loopz+1))
		
							local interpy1 = exaggeratedLinInterp(interpz1,interpz2,interpScaley, tempSizeY/(loopy+1))
							local interpy2 = exaggeratedLinInterp(interpz3,interpz4,interpScaley, tempSizeY/(loopy+1))
		
							local interpx1 = exaggeratedLinInterp(interpy1,interpy2,interpScalex, tempSizeX/(loopx+1))
		
							local newMaterial = lockedMaterials[round(scalex)+1][round(scaley)+1][round(scalez)+1]
		
							if fillAir and newMaterial == materialAir then
								ytm[z]=behindMaterials[x][y][z]
								yto[z]=behindOccupancies[x][y][z]
							elseif fillWater and newMaterial == materialWater and behindMaterials[x][y][z] ~= materialAir then
								ytm[z]=behindMaterials[x][y][z]
								yto[z]=behindOccupancies[x][y][z]
							else
								ytm[z]=newMaterial
								yto[z]=interpx1
							end
						end
						xtm[y] = ytm
						xto[y] = yto
					end
					newMat[x] = xtm
					newOcc[x] = xto
				end
		
				terrain:WriteVoxels(region, resolution, newMat, newOcc)
			else
				behindThis = nil
			end
		elseif tool == 'Move' then
			temporaryStart = temporaryStart + dragVector
			temporaryEnd = temporaryEnd + dragVector
			if mode == 'Edit' then
				local region = Region3.new((temporaryStart - Vector3.new(1,1,1)) * resolution, temporaryEnd * resolution)
				if behindThis then
					terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
				else
					if selectionStart and selectionEnd then
						local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
						local regionSize = region.Size / resolution
						terrain:WriteVoxels(region, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
					end
				end
				behindThis = {}
				behindThis.region = region
				behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

				local behindMaterials, behindOccupancies = behindThis.materials, behindThis.occupancies
		
				if not (fillAir or fillWater) then
					terrain:WriteVoxels(region, resolution, lockedMaterials, lockedOccupancies)
				else
					local newMat = {}
					local newOcc = {}
		
					for x,xv in ipairs(lockedMaterials) do
						local xtm = {}
						local xto = {}
						for y,yv in ipairs(xv) do
							local ytm = {}
							local yto = {}
							for z,zv in ipairs(yv) do
								if fillAir and zv == materialAir then
									ytm[z]=behindMaterials[x][y][z]
									yto[z]=behindOccupancies[x][y][z]
								elseif fillWater and zv == materialWater and behindMaterials[x][y][z] ~= materialAir then
									ytm[z]=behindMaterials[x][y][z]
									yto[z]=behindOccupancies[x][y][z]
								else
									ytm[z]=lockedMaterials[x][y][z]
									yto[z]=lockedOccupancies[x][y][z]
								end
							end
							xtm[y] = ytm
							xto[y] = yto
						end
						newMat[x] = xtm
						newOcc[x] = xto
					end
					terrain:WriteVoxels(region, resolution, newMat, newOcc)
				end
			end
		end
		renderSelection(temporaryStart,temporaryEnd)
	end

	function dragHandles(face, delta)
		local normal = faceToNormal[face]
		local delta = delta
		local newDragVector = normal * floor((delta + .5) / resolution)
		dragStart = normal.x < 0 or normal.y < 0 or normal.z < 0	--This determines if we are dragging a side on the min or max bounds
		if newDragVector ~= dragVector then
			dragVector = newDragVector
			updateDragOperation()
		end
	end

	local function rotate(mx,x,my,y,rotation)
		if rotation == 1 then
			return my + 1 - y, x 
		elseif rotation == 2 then
			return mx + 1 - x, my + 1 - y
		elseif rotation == 3 then
			return y, mx + 1 - x
		end
		return x,y
	end

	function updateRotateOperation()
		local dragAngle = dragAngle or 0
		local rotationCFrame = CFrame.Angles(
			axis ~= 'X' and 0 or dragAngle * rotationInterval,
			axis ~= 'Y' and 0 or dragAngle * rotationInterval,
			axis ~= 'Z' and 0 or dragAngle * rotationInterval
		)
		local temporarySize = Vector3.new(1,1,1) + selectionEnd - selectionStart
		local centerOffset = Vector3.new(ceil(temporarySize.x * .5), ceil(temporarySize.y * .5), ceil(temporarySize.z * .5))

		temporarySize = rotationCFrame * temporarySize
		local temporarySizeX = round(math.abs(temporarySize.x))	--I need to round these because of floating point imprecision
		local temporarySizeY = round(math.abs(temporarySize.y))
		local temporarySizeZ = round(math.abs(temporarySize.z))
		centerOffset = centerOffset - Vector3.new(ceil(temporarySizeX * .5), ceil(temporarySizeY * .5), ceil(temporarySizeZ * .5))

		local temporaryEnd = selectionStart + centerOffset + Vector3.new(temporarySizeX, temporarySizeY, temporarySizeZ) - Vector3.new(1, 1, 1)
		local temporaryStart = selectionStart + centerOffset

		if mode == 'Edit' then
		local region = Region3.new((temporaryStart - Vector3.new(1,1,1)) * resolution, temporaryEnd * resolution)
			if behindThis then
				terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
			else
				if selectionStart and selectionEnd then
					local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
					local regionSize = region.Size / resolution
					terrain:WriteVoxels(region, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
				end
				--local regionSize = lockedRegion.Size / resolution
				--terrain:WriteVoxels(lockedRegion, resolution, make3DTable(regionSize,materialAir), make3DTable(regionSize,0))
			end
			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			local newMat = {}
			local newOcc = {}

			for x=1, temporarySizeX do
				local xtm = {}
				local xto = {}
				for y=1, temporarySizeY do
					local ytm = {}
					local yto = {}
					for z=1, temporarySizeZ do
						local targetx = x
						local targety = y
						local targetz = z
						if axis == 'Y' then	--prioritize y because I know this is the primary rotation axis
							targetx, targetz = rotate(temporarySizeX, x, temporarySizeZ, z, dragAngle)
						elseif axis == 'X' then
							targetz, targety = rotate(temporarySizeZ, z, temporarySizeY, y, dragAngle)
						elseif axis == 'Z' then
							targety, targetx = rotate(temporarySizeY, y, temporarySizeX, x, dragAngle)
						end
						local newMaterial = lockedMaterials[targetx][targety][targetz]

						if fillAir and newMaterial == materialAir then
							ytm[z]=behindThis.materials[x][y][z]
							yto[z]=behindThis.occupancies[x][y][z]
						elseif fillWater and newMaterial == materialWater and behindThis.materials[x][y][z] ~= materialAir then
							ytm[z]=behindThis.materials[x][y][z]
							yto[z]=behindThis.occupancies[x][y][z]
						else
							ytm[z]=newMaterial
							yto[z]=lockedOccupancies[targetx][targety][targetz]
						end
					end
					xtm[y] = ytm
					xto[y] = yto
				end
				newMat[x] = xtm
				newOcc[x] = xto
			end

			terrain:WriteVoxels(region, resolution, newMat, newOcc)
		end
		renderSelection(temporaryStart,temporaryEnd,rotationCFrame)
	end

	function dragArcHandles(rotationAxis,relativeAngle,deltaRadius)
		axis = rotationAxis.Name
		local newDragAngle = round(relativeAngle / rotationInterval) % 4
		if newDragAngle ~= dragAngle then
			dragAngle = newDragAngle
			updateRotateOperation()
		end
	end

	buttonCopy.MouseButton1Down:connect(function()
		if selectionStart and selectionEnd then
			local selectionStartInt16=Vector3int16.new(selectionStart.x-1,selectionStart.y-1,selectionStart.z-1)
			local selectionEndInt16=Vector3int16.new(selectionEnd.x-1,selectionEnd.y-1,selectionEnd.z-1)
			local region = Region3int16.new(selectionStartInt16,selectionEndInt16)
			copyRegion = terrain:CopyRegion(region)
			selectionEffect(nil,nil,'New Yeller',1,1.2,.5)
		end
	end)

	buttonPaste.MouseButton1Down:connect(function()
		if copyRegion then
			selectionEnd=selectionStart+copyRegion.SizeInCells-Vector3.new(1,1,1)

			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			terrain:PasteRegion(copyRegion,Vector3int16.new(selectionStart.x-1,selectionStart.y-1,selectionStart.z-1),true)
			setButton('Move')
			changeHistory:SetWaypoint('Terrain Paste')
			selectionEffect(nil,nil,'Lime green',1.2,1,.5)
		end
	end)

	buttonDelete.MouseButton1Down:connect(function()
		if selectionStart and selectionEnd then
			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			local regionSize = region.Size / resolution
			local emptyMaterialMap = make3DTable(regionSize,materialAir)
			local emptyOccupancyMap = make3DTable(regionSize,0)

			--[[behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = emptyMaterialMap, emptyOccupancyMap

			terrain:WriteVoxels(region, resolution, emptyMaterialMap, emptyOccupancyMap)]]
			if behindThis then
				terrain:WriteVoxels(behindThis.region, resolution, behindThis.materials, behindThis.occupancies)
			else
				if selectionStart and selectionEnd then
					terrain:WriteVoxels(region, resolution, emptyMaterialMap, emptyOccupancyMap)
				end
			end
			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			--[[lockedRegion = region
			lockedMaterials, lockedOccupancies = emptyMaterialMap, emptyOccupancyMap]]
			local oldStart, oldEnd = selectionStart, selectionEnd
			selectionStart, selectionEnd = nil, nil
			setButton('Select')

			changeHistory:SetWaypoint('Terrain Delete')
			selectionEffect(oldStart,oldEnd,'Really red',1,1.2,.5)
		end
	end)

	buttonFill.MouseButton1Down:connect(function()
		fillFrame.Visible = not fillFrame.Visible
	end)

	buttonFillConfirm.MouseButton1Down:connect(function()
		if selectionStart and selectionEnd then
			local region = Region3.new((selectionStart - Vector3.new(1,1,1)) * resolution, selectionEnd * resolution)
			local regionSize = region.Size / resolution

			local beforeMaterialMap, beforeOccupancyMap = terrain:ReadVoxels(region, resolution)
			local newMaterialMap = {}
			local newOccupancyMap = {}
			for x = 1, regionSize.x do
				local xtm = {}
				local xto = {}
				for y = 1, regionSize.y do
					local ytm = {}
					local yto = {}
					for z = 1, regionSize.z do
						local beforeMaterial = beforeMaterialMap[x][y][z]

						if beforeMaterial == materialAir or beforeOccupancyMap[x][y][z] == 0 or not fillAir then	--'fillAir' variable is actually 'Merge Empty' to the user
							ytm[z] = kMaterialsListObject:GetCurrentMaterialSelection().enum
						else
							ytm[z] = beforeMaterial
						end

						yto[z] = 1
					end
					xtm[y] = ytm
					xto[y] = yto
				end
				newMaterialMap[x] = xtm
				newOccupancyMap[x] = xto
			end


			terrain:WriteVoxels(region, resolution, newMaterialMap, newOccupancyMap)

			behindThis = {}
			behindThis.region = region
			behindThis.materials, behindThis.occupancies = terrain:ReadVoxels(region, resolution)

			fillFrame.Visible = false

			changeHistory:SetWaypoint('Terrain Fill')
			selectionEffect(nil,nil,'Lime green',1.2,1,.5)
		end
	end)

	function selectionEffect(temporaryStart, temporaryEnd, color, sizeFrom, sizeTo, effectTime)
		local temporaryStart = temporaryStart or selectionStart
		local temporaryEnd = temporaryEnd or selectionEnd

		local effectPart = Instance.new('Part')
		effectPart.Name = 'EffectPart'
		effectPart.Transparency = 1
		effectPart.TopSurface = 'Smooth'
		effectPart.BottomSurface = 'Smooth'
		effectPart.Anchored = true
		effectPart.CanCollide = false
		effectPart.Parent = screenGui

		local selectionEffectObject = Instance.new('SelectionBox')
		selectionEffectObject.Name = 'SelectionObject'
		selectionEffectObject.Transparency = 1
		selectionEffectObject.SurfaceTransparency = .75
		selectionEffectObject.SurfaceColor = BrickColor.new(color)
		selectionEffectObject.Adornee = effectPart
		selectionEffectObject.Parent = effectPart

		local baseSize = ((temporaryEnd - temporaryStart + Vector3.new(1,1,1)) * resolution + Vector3.new(.21,.21,.21))
		effectPart.CFrame = CFrame.new((temporaryStart + temporaryEnd - Vector3.new(1, 1, 1)) * .5 * resolution)
		effectPart.Size = baseSize * sizeFrom
		local endTick=tick()+effectTime
		while endTick>tick() do
			local percent=1-(endTick-tick())/effectTime
			selectionEffectObject.SurfaceTransparency = .75 + percent*.25
			effectPart.Size = baseSize * (sizeFrom+(sizeTo-sizeFrom)*percent)
			wait()
		end
		effectPart:Destroy()
	end

	function renderSelection(temporaryStart,temporaryEnd,rotation)
		local temporaryStart = temporaryStart or selectionStart
		local temporaryEnd = temporaryEnd or selectionEnd
		local seeable = false
		if temporaryStart and temporaryEnd and selectionPart then
			seeable = true
			local temporarySize = ((temporaryEnd - temporaryStart + Vector3.new(1,1,1)) * resolution + Vector3.new(.2,.2,.2))
			if rotation then
				local rotatedSize = rotation * temporarySize
				temporarySize = Vector3.new(math.abs(rotatedSize.x), math.abs(rotatedSize.y), math.abs(rotatedSize.z))
			end
			selectionPart.Size = temporarySize
			selectionPart.CFrame = CFrame.new((temporaryStart + temporaryEnd - Vector3.new(1, 1, 1)) * .5 * resolution) * (rotation or CFrame.new(0,0,0))
		end
		if selectionObject then
			selectionObject.Visible = seeable
			selectionObject.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
			selectionObject.SurfaceColor = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
		end
		if selectionHandles then
			selectionHandles.Visible = seeable and (tool == 'Move' or tool == 'Resize')
			selectionHandles.Color = BrickColor.new(mode == 'Select' and 'Cyan' or editColor2)
			selectionHandles.Style = tool == 'Move' and Enum.HandlesStyle.Movement or Enum.HandlesStyle.Resize
		end
		if selectionArcHandles then
			selectionArcHandles.Visible = seeable and tool == 'Rotate'
			selectionArcHandles.Color = BrickColor.new(mode == 'Select' and 'Cyan' or editColor2)
		end
	end

	mouse.Button1Down:connect(function()
		if on and mode == 'Select' then
			mouseDown = true
			behindThis = nil
			local mousePos = mouse.Hit.p + mouse.UnitRay.Direction * .05
			if mouse.Target == nil then	--cage the cursor so that it does not fly away
				mousePos = game.Workspace.CurrentCamera.CoordinateFrame.p + mouse.UnitRay.Direction * 100
			end
			clickStart = positionWorldToVoxel(mousePos)
			local thisDownLoop = {}
			downLoop = thisDownLoop
			while thisDownLoop == downLoop and mouseDown and on and mode == 'Select' do
				local mousePos = mouse.Hit.p + mouse.UnitRay.Direction * .05
				if mouse.Target == nil then	--cage the cursor so that it does not fly away
					mousePos = game.Workspace.CurrentCamera.CoordinateFrame.p + mouse.UnitRay.Direction * 100
				end
				local voxelCurrent = positionWorldToVoxel(mousePos)
				voxelCurrent = Vector3.new(
					math.max(math.min(voxelCurrent.x,clickStart.x+regionLengthLimit),clickStart.x-regionLengthLimit),
					math.max(math.min(voxelCurrent.y,clickStart.y+regionLengthLimit),clickStart.y-regionLengthLimit),
					math.max(math.min(voxelCurrent.z,clickStart.z+regionLengthLimit),clickStart.z-regionLengthLimit))
				selectionStart = Vector3.new(math.min(clickStart.x, voxelCurrent.x), math.min(clickStart.y, voxelCurrent.y), math.min(clickStart.z, voxelCurrent.z))
				selectionEnd = Vector3.new(math.max(clickStart.x, voxelCurrent.x), math.max(clickStart.y, voxelCurrent.y), math.max(clickStart.z, voxelCurrent.z))
				renderSelection()
				quickWait()
			end
		end
	end)
	mouse.Button1Up:connect(function()
		mouseDown = false
		if dragVector and dragVector.magnitude > 0 then
			if tool == 'Resize' then
				--[[if dragStart then
					selectionStart = Vector3.new(math.min(selectionStart.x+dragVector.x,selectionEnd.x),math.min(selectionStart.y+dragVector.y,selectionEnd.y),math.min(selectionStart.z+dragVector.z,selectionEnd.z))
				else
					selectionEnd = Vector3.new(math.max(selectionEnd.x+dragVector.x,selectionStart.x),math.max(selectionEnd.y+dragVector.y,selectionStart.y),math.max(selectionEnd.z+dragVector.z,selectionStart.z))
				end]]
				if dragStart then
					selectionStart = Vector3.new(
						math.min(
							math.max(selectionStart.x+dragVector.x,selectionEnd.x-regionLengthLimit),
							selectionEnd.x),
						math.min(
							math.max(selectionStart.y+dragVector.y,selectionEnd.y-regionLengthLimit),
							selectionEnd.y),
						math.min(
							math.max(selectionStart.z+dragVector.z,selectionEnd.z-regionLengthLimit),
							selectionEnd.z)
					)
				else
					selectionEnd = Vector3.new(
						math.max(
							math.min(selectionEnd.x+dragVector.x,selectionStart.x+regionLengthLimit),
							selectionStart.x),
						math.max(
							math.min(selectionEnd.y+dragVector.y,selectionStart.y+regionLengthLimit),
							selectionStart.y),
						math.max(
							math.min(selectionEnd.z+dragVector.z,selectionStart.z+regionLengthLimit),
							selectionStart.z)
					)
				end
			elseif tool == 'Move' then
				selectionStart = selectionStart + dragVector
				selectionEnd = selectionEnd + dragVector
			end
			
			changeHistory:SetWaypoint('Terrain '..currentButtonId)
		end
		if dragAngle and dragAngle ~= 0 then
			local rotationCFrame = CFrame.Angles(
				axis ~= 'X' and 0 or dragAngle * rotationInterval,
				axis ~= 'Y' and 0 or dragAngle * rotationInterval,
				axis ~= 'Z' and 0 or dragAngle * rotationInterval
			)
			local temporarySize = Vector3.new(1,1,1) + selectionEnd - selectionStart
			local centerOffset = Vector3.new(ceil(temporarySize.x * .5), ceil(temporarySize.y * .5), ceil(temporarySize.z * .5))
			temporarySize = rotationCFrame * temporarySize
			local temporarySizeX = round(math.abs(temporarySize.x))	--I need to round these because of floating point imprecision
			local temporarySizeY = round(math.abs(temporarySize.y))
			local temporarySizeZ = round(math.abs(temporarySize.z))
			centerOffset = centerOffset - Vector3.new(ceil(temporarySizeX * .5), ceil(temporarySizeY * .5), ceil(temporarySizeZ * .5))
			
			selectionEnd = selectionStart + centerOffset + Vector3.new(temporarySizeX, temporarySizeY, temporarySizeZ) - Vector3.new(1, 1, 1)
			selectionStart = selectionStart + centerOffset
			lockInMap()
			changeHistory:SetWaypoint('Terrain '..currentButtonId)
		end

		dragVector = nil
		dragAngle = nil
		renderSelection()
		--lockInMap()
	end)

	local function historyChanged()
		selectionStart = nil
		selectionEnd = nil
		lockedMaterials = nil
		lockedOccupancies = nil
		setButton('Select')
	end
	
	changeHistory.OnUndo:connect(historyChanged)
	changeHistory.OnRedo:connect(historyChanged)

	module.On = function()
		on = true
		screenGui.Parent = coreGui
		terrainRegionFrame.Visible = true

		if not selectionPart then
			selectionPart = Instance.new('Part')
			selectionPart.Name = 'SelectionPart'
			selectionPart.Transparency = 1
			selectionPart.TopSurface = 'Smooth'
			selectionPart.BottomSurface = 'Smooth'
			selectionPart.Anchored = true
			selectionPart.CanCollide = false
			selectionPart.Parent = screenGui
		end
		if not selectionObject then
			selectionObject = Instance.new('SelectionBox')
			selectionObject.Name = 'SelectionObject'
			selectionObject.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
			selectionObject.SurfaceTransparency = .85
			selectionObject.SurfaceColor = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor1)
			selectionObject.Adornee = selectionPart
			selectionObject.Visible = false
			selectionObject.Parent = selectionPart
		end
		if not selectionHandles then
			selectionHandles = Instance.new('Handles')
			selectionHandles.Name = 'SelectionHandles'
			selectionHandles.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor2)
			selectionHandles.Adornee = selectionPart
			selectionHandles.Visible = false
			selectionHandles.Parent = coreGui--game.Workspace--terrainRegionFrame--selectionPart
			selectionHandles.MouseDrag:connect(dragHandles)
		end
		if not selectionArcHandles then
			selectionArcHandles = Instance.new('ArcHandles')
			selectionArcHandles.Name = 'SelectionArcHandles'
			selectionArcHandles.Color = BrickColor.new(mode == 'Select' and 'Toothpaste' or editColor2)
			selectionArcHandles.Adornee = selectionPart
			selectionArcHandles.Visible = false
			selectionArcHandles.Parent = coreGui--game.Workspace--terrainRegionFrame--selectionPart
			selectionArcHandles.MouseDrag:connect(dragArcHandles)
		end
		renderSelection()
		setButton(currentButtonId)
	end

	module.Off = function()
		setButton('Select')
		terrainRegionFrame.Visible = false
		fillFrame.Visible = false
		clearSelection()
		behindThis = nil
		on = false
	end
end


return module


]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXbd9426082fe242898a75b7d49ed89f2a">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MaterialsList</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[local MaterialsListClass = {}

GuiUtilities = require(script.Parent.GuiUtilities)

local kMaterialCellSize = 35
local kMaterialCellPadding = 5

local kMaterialTooltipHeight = 30

MaterialsListClass.MaterialsTable = {	--Interface order is defined by order here
	{
		enum = Enum.Material.Grass, 
		image = 'http://www.roblox.com/asset/?id=225314676', 
		text = "Grass", 
	},
	{
		enum = Enum.Material.Sand, 
		image = 'http://www.roblox.com/asset/?id=225315607', 
		text = "Sand", 
	},
	{
		enum = Enum.Material.Rock,
		image = 'http://www.roblox.com/asset/?id=225315178', 
		text = "Rock", 
	},
	{
		enum = Enum.Material.Water, 
		image = 'http://www.roblox.com/asset/?id=225315529', forceIgnoreWater = true, forceIgnoreWaterTo = false, 
		text = "Water", 
	},
	{
		enum = Enum.Material.Ground, 
		image = 'http://www.roblox.com/asset/?id=254542189', 
		text = "Ground", 
	},
	{
		enum = Enum.Material.Sandstone, 
		image = 'http://www.roblox.com/asset/?id=254541350', 
		text = "Sandstone", 
	},
	{
		enum = Enum.Material.Slate, 
		image = 'http://www.roblox.com/asset/?id=225315290', 
		text = "Slate", 
	},
	{
		enum = Enum.Material.Snow, 
		image = 'http://www.roblox.com/asset/?id=254541898', 
		text = "Snow", 
	},
	{
		enum = Enum.Material.Mud, 
		image = 'http://www.roblox.com/asset/?id=254541862', 
		text = "Mud", 
	},
	{
		enum = Enum.Material.Brick, 
		image = 'http://www.roblox.com/asset/?id=225315419', forceSnapToGrid = true, 
		text = "Brick", 
	},
	{
		enum = Enum.Material.Concrete, 
		image = 'http://www.roblox.com/asset/?id=225314983', 
		text = "Concrete", 
	},
	{
		enum = Enum.Material.Glacier, 
		image = 'http://www.roblox.com/asset/?id=254541572', 
		text = "Glacier", 
	},
	{
		enum = Enum.Material.WoodPlanks, 
		image = 'http://www.roblox.com/asset/?id=225315705', 
		forceSnapToGrid = true, 
		text = "Wood Planks", 
	},
	{
		enum = Enum.Material.CrackedLava, 
		image = 'http://www.roblox.com/asset/?id=254541726', 
		text = "Cracked Lava", 
	},
	{
		enum = Enum.Material.Basalt, 
		image = 'http://www.roblox.com/asset/?id=254542066', 
		text = "Basalt", 
	},
	{
		enum = Enum.Material.Ice,
		image = 'http://www.roblox.com/asset/?id=397352205', 
		text = "Ice", 
	},
	{
		enum = Enum.Material.Salt, 
		image = 'http://www.roblox.com/asset/?id=397352299', 
		text = "Salt", 
	},
	{
		enum = Enum.Material.Cobblestone, 
		image = 'http://www.roblox.com/asset/?id=397352378', 
		text = "Cobblestone", 
	},
	{
		enum = Enum.Material.Limestone, 
		image = 'http://www.roblox.com/asset/?id=397352474', 
		text = "Limestone", 
	},
	{
		enum = Enum.Material.Asphalt, 
		image = 'http://www.roblox.com/asset/?id=397352644',
		text = "Asphalt", 
	},
	{
		enum = Enum.Material.LeafyGrass, 
		image = 'http://www.roblox.com/asset/?id=397720681',
		text = "Leafy Grass", 
	},
	{
		enum = Enum.Material.Pavement, 
		image = 'http://www.roblox.com/asset/?id=397727024',
		text = "Pavement", 
	},
}

MaterialsListClass.__index = MaterialsListClass
------------------------------------------
-- 
-- Public functions
--
------------------------------------------
-- Constructor
function MaterialsListClass.new()
	local self = {}
	setmetatable(self, MaterialsListClass)

	self._currentMaterialSelection = MaterialsListClass.MaterialsTable[1]
	self._callbackOnSelectionChanged = nil
	self._materialsFrame = nil
	self._activeToolTip = Instance.new("StringValue")

	self:_MakeMaterialsFrame()

	return self
end


function MaterialsListClass:SetCallbackOnSelectionChanged(callback)
	self._callbackOnSelectionChanged = callback
end

function MaterialsListClass:GetCurrentMaterialSelection()
	return self._currentMaterialSelection
end

function MaterialsListClass:GetMaterialsFrame()
	return self._materialsFrame
end

function MaterialsListClass:SetMaterialSelection(newMaterialSelection)
	self._currentMaterialSelection = newMaterialSelection

	if (self._callbackOnSelectionChanged) then 
		self._callbackOnSelectionChanged()
	end

	for _, v in pairs(self._materialsFrame:GetChildren()) do
		if string.sub(v.Name,1,14) == 'MaterialButton' then
			if v.Name == 'MaterialButton' .. self._currentMaterialSelection.enum.Name then
				v.BackgroundTransparency = .1
			else
				v.BackgroundTransparency = 1
			end
		end
	end
end

function MaterialsListClass:SetMaterialSelectionUsingEnum(foundMaterial)
	for _, materialTable in pairs(MaterialsListClass.MaterialsTable) do
		if materialTable.enum == foundMaterial then
			self:SetMaterialSelection(materialTable)
			break
		end
	end
end

------------------------------------------
-- 
-- Private functions
--
------------------------------------------

function MaterialsListClass:_MakeMaterialsFrame()
	self._materialsFrame = GuiUtilities.MakeFrame("MaterialsFrame")

	local uiGridLayout = Instance.new("UIGridLayout")
	uiGridLayout.CellSize = UDim2.new(0,kMaterialCellSize,0,kMaterialCellSize)
	uiGridLayout.CellPadding = UDim2.new(0,kMaterialCellPadding,0,kMaterialCellPadding)
	uiGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	uiGridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	uiGridLayout.Parent = self._materialsFrame

	local uiPadding = Instance.new("UIPadding")
	uiPadding.PaddingTop = UDim.new(0, GuiUtilities.kStandardVMargin)
	uiPadding.PaddingBottom = UDim.new(0, GuiUtilities.kStandardVMargin)
	uiPadding.PaddingLeft = UDim.new(0, GuiUtilities.StandardLineLabelLeftMargin)
	uiPadding.PaddingRight = UDim.new(0, GuiUtilities.StandardLineLabelLeftMargin)
	uiPadding.Parent = self._materialsFrame

	for i, materialSubTable in pairs(MaterialsListClass.MaterialsTable) do
		self:_AddNewMaterialsButton(materialSubTable)
	end

	GuiUtilities.AdjustHeightDynamicallyToLayout(self._materialsFrame, 
		uiGridLayout, 
		2 * GuiUtilities.kStandardVMargin)

	return self._materialsFrame
end


function MaterialsListClass:_AddNewMaterialsButton(materialSubTable)
	local newMaterialButton = Instance.new('ImageButton')
	newMaterialButton.Name = 'MaterialButton' .. materialSubTable.enum.Name
	newMaterialButton.BorderSizePixel = 2
	newMaterialButton.BorderColor3 = Color3.new(.2, 1, 1)
	newMaterialButton.BackgroundColor3 = Color3.new(.2, 1, 1)
	newMaterialButton.BackgroundTransparency = 1
	newMaterialButton.Image = materialSubTable.image
	newMaterialButton.Size = UDim2.new(0, 35, 0, 35)

	newMaterialButton.MouseButton1Down:connect(function()
		self:SetMaterialSelection(materialSubTable)
	end)

	newMaterialButton.Parent = self._materialsFrame
	-- Add spaces to names
		self:_MakeToolTip(newMaterialButton,
		materialSubTable.text) 
end

function MaterialsListClass:_MakeToolTip(guiElement, text)
	local Name = tostring(guiElement:GetFullName() .. text)

	local Frame = Instance.new("Frame")
	Frame.BackgroundTransparency = 0.3
	Frame.BackgroundColor3 = Color3.new(0, 0, 0)
	Frame.Size = UDim2.new(0, 100, 0, kMaterialTooltipHeight)
	Frame.SizeConstraint = "RelativeYY"
	Frame.ZIndex = guiElement.ZIndex + 1
	Frame.Style = "DropShadow"
	Frame.AnchorPoint = Vector2.new(0.5, 0.5)
	-- We will set position down below...

	-- Parent to main frame so it doesn't get clipped by anything.
	Frame.Parent = GuiUtilities.kMainFrame

	self._tweakingTooltipFrame = nil

	-- Tooltips are positioned as children of main screen.
	-- The buttons they describe are in a scroll widget, so they can 
	-- move around.
	-- So we need to watch the buttons and dynmically reposition.
	-- Also, we need to worry about slopping over right/left edges.
	local function updateTooltipPosition()
		-- Don't let this be re-entrant.
		if (self._tweakingTooltipFrame == Frame) then 
			return
		end
		self._tweakingTooltipFrame = Frame

		local materialSquareAbsPosition = guiElement.AbsolutePosition
		local materialSquareAbsSize = guiElement.AbsoluteSize

		local absSize = Frame.AbsoluteSize

		local targetLocationX = materialSquareAbsPosition.X + materialSquareAbsSize.X/2
		local targetLocationY = materialSquareAbsPosition.Y - kMaterialTooltipHeight/2

		local containerSize = self._materialsFrame.AbsoluteSize

		-- Worry about slopping over either side.
		if (targetLocationX < absSize.X/2) then 
			targetLocationX = absSize.X/2
		end

		if (targetLocationX > containerSize.X - absSize.X/2) then 
			targetLocationX = containerSize.X - absSize.X/2
		end

		Frame.Position = UDim2.new(0, targetLocationX, 0, targetLocationY)

		self._tweakingTooltipFrame = nil
	end
	Frame:GetPropertyChangedSignal("AbsolutePosition"):connect(updateTooltipPosition)
	Frame:GetPropertyChangedSignal("AbsoluteSize"):connect(updateTooltipPosition)
	guiElement:GetPropertyChangedSignal("AbsolutePosition"):connect(updateTooltipPosition)
	updateTooltipPosition()

	local TextLabel = Instance.new("TextLabel", Frame)
	TextLabel.BackgroundTransparency = 1
	TextLabel.TextXAlignment = "Left"
	TextLabel.Text = text
	TextLabel.BorderSizePixel = 0
	TextLabel.TextColor3 = Color3.new(1, 1, 1)
	TextLabel.Size = UDim2.new(1, -30, 1, 0);
	TextLabel.Position = UDim2.new(0, 10, 0, 0);
	TextLabel.FontSize = "Size10"
	TextLabel.ZIndex = Frame.ZIndex
	TextLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	TextLabel.TextStrokeTransparency = 0.87

	Frame.Visible = false

	guiElement.MouseEnter:connect(function()
		self._activeToolTip.Value = Name
		Frame.Visible = true
		Frame.Size = UDim2.new(0, math.ceil(TextLabel.TextBounds.X + 36), Frame.Size.Y.Scale, Frame.Size.Y.Offset)
	end)
	self._activeToolTip.Changed:connect(function()
		if self._activeToolTip.Value ~= Name then
			Frame.Visible = false
		end
	end)
	guiElement.MouseLeave:connect(function()
		Frame.Visible = false
	end)
end

return MaterialsListClass


]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXbd2d02a4fa4840b897c2a6ab59891bcc">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ProgressFrame</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- ProgressFrame.lua
--
-- Creates a frame that has a progress bar.
--
----------------------------------------

local GuiUtilities = require(script.Parent.GuiUtilities)

local kWidth = 400
local kHeight = 160

local kStandardHMargin = 10
local kStandardVMargin = 5
local kBarHeight = 25
local kButtonHeight = 30

local kTitleBarHeight = 25

ProgressFrameClass = {}
ProgressFrameClass.__index = ProgressFrameClass

function ProgressFrameClass.new(nameSuffix, labelText, initValue, initDisabled)
	local self = {}
	setmetatable(self, ProgressFrameClass)

    self._frame = Instance.new("Frame")
    self._frame.Name = "ProgressFrame"
    self._frame.Position = UDim2.new(0.5, -kWidth/2, 0, 0)
    self._frame.Size = UDim2.new(0, kWidth, 0, kHeight)
    self._frame.Style = Enum.FrameStyle.DropShadow

    self._frame.Visible = false

    self._bar = Instance.new("Frame")
    self._bar.Name = "Bar"
    self._bar.Parent = self._frame
    self._bar.Position = UDim2.new(0, kStandardHMargin, 0.39, 0)
    self._bar.Size = UDim2.new(1, -2 * kStandardHMargin, 0, kBarHeight)

    self._fill = Instance.new("ImageLabel")
    self._fill.Name = "ImageLabel"
    self._fill.Parent = self._bar
    self._fill.Image = "http://www.roblox.com/asset/?id=67599350"
    self._fill.ImageColor3 = Color3.new(0, 0.9, 0.4)
    self._fill.ImageRectOffset = Vector2.new(0, 256)
    self._fill.ImageRectSize = Vector2.new(0, -100)
    self._fill.ScaleType = Enum.ScaleType.Stretch

    self._pauseButton = Instance.new("TextButton")
    self._pauseButton.Name = "PauseButton"
    self._pauseButton.Text = "Pause"
    self._pauseButton.Parent = self._frame
    self._pauseButton.Style = Enum.ButtonStyle.RobloxRoundDefaultButton
    self._pauseButton.Size = UDim2.new(0.5, -2 * kStandardHMargin, 0, kButtonHeight)
    self._pauseButton.Position = UDim2.new(0, kStandardHMargin, 1, -kStandardVMargin - kButtonHeight)

    self._cancelButton = Instance.new("TextButton")
    self._cancelButton.Name = "CancelButton"
    self._cancelButton.Text = "Cancel"
    self._cancelButton.Parent = self._frame
    self._cancelButton.AnchorPoint = Vector2.new(1, 0)
    self._cancelButton.Style = Enum.ButtonStyle.RobloxRoundDefaultButton
    self._cancelButton.Size = UDim2.new(0.5, -2 * kStandardHMargin, 0, kButtonHeight)
    self._cancelButton.Position = UDim2.new(1, -kStandardHMargin, 1, -kStandardVMargin - kButtonHeight)

    self._titleLabel = Instance.new("TextLabel")
    self._titleLabel.Name = "TitleLabel"
    self._titleLabel.Text = "Progress"
    self._titleLabel.Parent = self._frame
    self._titleLabel.BackgroundTransparency = 0.75
    self._titleLabel.BackgroundColor3 = GuiUtilities.kStandardWhite
    self._titleLabel.Size = UDim2.new(1, 0, 0, kTitleBarHeight)

    self:_FixFont(self._pauseButton)
    self:_FixFont(self._cancelButton)
    self:_FixFont(self._titleLabel)

    return self
end

function ProgressFrameClass:_FixFont(frame)
    frame.Font = Enum.Font.SourceSansBold
    frame.TextColor3 = GuiUtilities.kStandardWhite
    frame.TextSize = 18
end

function ProgressFrameClass:GetFrame() 
    return self._frame
end

function ProgressFrameClass:GetPauseButton() 
    return self._pauseButton
end

function ProgressFrameClass:GetCancelButton() 
    return self._cancelButton
end

function ProgressFrameClass:GetFill() 
    return self._fill
end

return ProgressFrameClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXaef9fd845d744485bc728c63387cf1fb">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LabeledCheckbox</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- LabeledCheckbox.lua
--
-- Creates a frame containing a label and a checkbox.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kCheckboxWidth = 15

local kMinTextSize = 12
local kMinHeight = 24
local kMinLabelWidth = 42
local kMinMargin = 12
local kMinButtonWidth = 12;

local kMinLabelSize = UDim2.new(0, kMinLabelWidth, 0, kMinHeight)
local kMinLabelPos = UDim2.new(0, kMinButtonWidth + kMinMargin, 0, kMinHeight/2)

local kMinButtonSize = UDim2.new(0, kMinButtonWidth, 0, kMinButtonWidth)
local kMinButtonPos = UDim2.new(0, 0, 0, kMinHeight/2)

local kCheckImageWidth = 20
local kMinCheckImageWidth = 16

local kCheckImageSize = UDim2.new(0, kCheckImageWidth, 0, kCheckImageWidth)
local kMinCheckImageSize = UDim2.new(0, kMinCheckImageWidth, 0, kMinCheckImageWidth)

local kEnabledCheckImage = "http://www.roblox.com/asset/?id=1530112162"
local kDisabledCheckImage = "http://www.roblox.com/asset/?id=1530112767"

LabeledCheckboxClass = {}
LabeledCheckboxClass.__index = LabeledCheckboxClass

LabeledCheckboxClass.kMinFrameSize = UDim2.new(0, kMinLabelWidth + kMinMargin + kMinButtonWidth, 0, kMinHeight)


function LabeledCheckboxClass.new(nameSuffix, labelText, initValue, initDisabled)
	local self = {}
	setmetatable(self, LabeledCheckboxClass)

    local initValue = not not initValue
    local initDisabled = not not initDisabled

    local frame = GuiUtilities.MakeStandardFixedHeightFrame("CBF" .. nameSuffix)

    local label = GuiUtilities.MakeStandardPropertyLabel(labelText)
    label.Parent = frame

    local button = Instance.new('ImageButton')
    button.Name = 'Button'
    button.Size = UDim2.new(0, kCheckboxWidth, 0, kCheckboxWidth)
    button.AnchorPoint = Vector2.new(0, .5)
    button.BackgroundColor3 = GuiUtilities.kStandardWhite
    button.Position = UDim2.new(0, GuiUtilities.StandardLineElementLeftMargin, .5, 0)
    button.Parent = frame

    local checkImage = Instance.new("ImageLabel")
    checkImage.Name = "CheckImage"
    checkImage.Parent = button
    checkImage.Image = kEnabledCheckImage
    checkImage.Visible = false
    checkImage.Size = kCheckImageSize
    checkImage.AnchorPoint = Vector2.new(0.5, 0.5)
    checkImage.Position = UDim2.new(0.65, 0, 0.25, 0)
    checkImage.BackgroundTransparency = 1
    checkImage.BorderSizePixel = 0

    self._frame = frame
    self._button = button
    self._label = label
    self._checkImage = checkImage

    self._disabled = not disabled
    self:SetDisabled(disabled)

    self._value = not initValue
    self:SetValue(initValue)

    self:_SetupMouseClickHandling()

    return self
end


function LabeledCheckboxClass:_SetupMouseClickHandling()
    self._button.MouseButton1Down:connect(function()
        if not self._disabled then
            self:SetValue(not self._value)
        end
    end)
end

-- Small checkboxes are a different entity.
-- All the bits are smaller.
-- Fixed width instead of flood-fill.
-- Box comes first, then label.
function LabeledCheckboxClass:UseSmallSize()
    self._label.TextSize = kMinTextSize
    self._label.Size = kMinLabelSize
    self._label.Position = kMinLabelPos
    self._label.TextXAlignment = Enum.TextXAlignment.Left

    self._button.Size = kMinButtonSize    
    self._button.Position = kMinButtonPos

    self._checkImage.Size = kMinCheckImageSize

    self._frame.Size = LabeledCheckboxClass.kMinFrameSize
    self._frame.BackgroundTransparency = 1
end

function LabeledCheckboxClass:GetFrame()
    return self._frame
end

function LabeledCheckboxClass:GetValue()
    return self._value
end

function LabeledCheckboxClass:GetLabel()
    return self._label
end

function LabeledCheckboxClass:GetButton()
    return self._getButton
end

function LabeledCheckboxClass:SetValueChangedFunction(vcFunction) 
    self._valueChangedFunction = vcFunction
end

function LabeledCheckboxClass:SetDisabled(newDisabled)
    local newDisabled = not not newDisabled
    if newDisabled ~= self._disabled then
        self._disabled = newDisabled

        if (newDisabled) then 
            self._checkImage.Image = kDisabledCheckImage
        else
            self._checkImage.Image = kEnabledCheckImage
        end

        self._label.TextColor3 = self._disabled and GuiUtilities.kDisabledTextColor or GuiUtilities.kStandardTextColor
        self._button.BackgroundColor3 = self._disabled and GuiUtilities.kButtonDisabledBackgroundColor or GuiUtilities.kButtonStandardBackgroundColor
        self._button.BorderColor3 = self._disabled and GuiUtilities.kButtonDisabledBorderColor or GuiUtilities.kButtonStandardBorderColor
        if self._disabledChangedFunction then
            self._disabledChangedFunction(self._disabled)
        end
    end
end

function LabeledCheckboxClass:GetDisabled()
    return self._disabled
end

function LabeledCheckboxClass:SetValue(newValue)
    local newValue = not not newValue
    
    if newValue ~= self._value then
        self._value = newValue

        self._checkImage.Visible = self._value

        if (self._valueChangedFunction) then 
            self._valueChangedFunction(newValue)
        end
    end
end

return LabeledCheckboxClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX7689df7cd8f943b1a6016b78ae6b67c2">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">CollapsibleTitledSection</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- CollapsibleTitledSectionClass
--
-- Creates a section with a title label:
--
-- "SectionXXX"
--     "TitleBarVisual"
--     "Contents"
--
-- Requires "parent" and "sectionName" parameters and returns the section and its contentsFrame
-- The entire frame will resize dynamically as contents frame changes size.
--
--  "showTitle" is true by default and will not display the section title if false
-- Both "minimizeable" and "minimizedByDefault" are false by default
-- These parameters define if the section will have an arrow button infront of the title label, 
-- which the user may use to hide the section's contents
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kRightButtonAsset = 'http://www.roblox.com/asset/?id=1526305310'
local kDownButtonAsset = 'http://www.roblox.com/asset/?id=1530219759'

CollapsibleTitledSectionClass = {}
CollapsibleTitledSectionClass.__index = CollapsibleTitledSectionClass


function CollapsibleTitledSectionClass.new(nameSuffix, titleText, showTitle, minimizable, minimizedByDefault)
	local self = {}
	setmetatable(self, CollapsibleTitledSectionClass)

    showTitle = showTitle or showTitle == nil
    
    self._minimized = minimizedByDefault
    self._minimizable = minimizable

    self._titleBarHeight = showTitle and GuiUtilities.kTitleBarHeight or 0

    local frame = Instance.new('Frame')
    frame.Name = 'CTSection' .. nameSuffix
    frame.BackgroundTransparency = 1
    self._frame = frame

    local uiListLayout = Instance.new('UIListLayout')
    uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    uiListLayout.Parent = frame
    self._uiListLayout = uiListLayout

    local contentsFrame = Instance.new('Frame')
    contentsFrame.Name = 'Contents'
    contentsFrame.BackgroundTransparency = 1
    contentsFrame.Size = UDim2.new(1, 0, 0, 1)
    contentsFrame.Position = UDim2.new(0, 0, 0, titleBarSize)
    contentsFrame.Parent = frame
    contentsFrame.LayoutOrder = 2
    self._contentsFrame = contentsFrame

    uiListLayout:GetPropertyChangedSignal('AbsoluteContentSize'):connect(function()
        self:_UpdateSize()
    end)
    self:_UpdateSize()

    if showTitle then
        self:_CreateTitleBar(titleText)
    end

    return self
end


function CollapsibleTitledSectionClass:GetSectionFrame()
    return self._frame
end

function CollapsibleTitledSectionClass:GetContentsFrame()
    return self._contentsFrame
end

function CollapsibleTitledSectionClass:_UpdateSize()
    local totalSize = self._uiListLayout.AbsoluteContentSize.Y
    if self._minimized then
        totalSize = self._titleBarHeight
    end
    self._frame.Size = UDim2.new(1, 0, 0, totalSize)
end

function CollapsibleTitledSectionClass:_UpdateMinimizeButton()
    -- We can't rotate it because rotated images don't get clipped by parents.
    -- This is all in a scroll widget.
    -- :(
    if (self._minimized) then 
        self._minimizeButton.Image = kRightButtonAsset
    else
        self._minimizeButton.Image = kDownButtonAsset
    end
end

function CollapsibleTitledSectionClass:_CreateTitleBar(titleText)
    local titleTextOffset = self._titleBarHeight

    local titleBar = Instance.new('Frame')
    titleBar.Name = 'TitleBarVisual'
    titleBar.BorderSizePixel = 0
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.Size = UDim2.new(1, 0, 0, self._titleBarHeight)
    titleBar.BackgroundColor3 = Color3.new(.85, .85, .85)        --todo: input spec section title background color
    titleBar.Parent = self._frame
    titleBar.LayoutOrder = 1

    local titleLabel = Instance.new('TextLabel')
    titleLabel.Name = 'TitleLabel'
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.SourceSansBold                --todo: input spec font
    titleLabel.TextSize = 15                                  --todo: input spec font size
    titleLabel.TextColor3 = GuiUtilities.kStandardTextColor
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Text = titleText
    titleLabel.Position = UDim2.new(0, titleTextOffset, 0, 0)
    titleLabel.Size = UDim2.new(1, -titleTextOffset, 1, 0)
    titleLabel.Parent = titleBar

    if self._minimizable then
        self._minimizeButton = Instance.new('ImageButton')
        self._minimizeButton.Name = 'MinimizeSectionButton'
        self._minimizeButton.Image = kRightButtonAsset              --todo: input arrow image from spec
        self._minimizeButton.Size = UDim2.new(0, self._titleBarHeight*.5, 0, self._titleBarHeight*.5)
        self._minimizeButton.Position = UDim2.new(0, self._titleBarHeight*.25, 0, self._titleBarHeight*.25)
        self._minimizeButton.BackgroundTransparency = 1

        self._minimizeButton.MouseButton1Down:connect(function()
            self._minimized = not self._minimized
            self._contentsFrame.Visible = not self._minimized
            self:_UpdateMinimizeButton()
            self:_UpdateSize()
        end)
        self:_UpdateMinimizeButton()
        self._minimizeButton.Parent = titleBar
    end
end

return CollapsibleTitledSectionClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX25b0c77511c44b80ada88a69b2f0bd11">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LabeledSlider</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- LabeledSlider.lua
--
-- Creates a frame containing a label and a slider control.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kSliderWidth = 100

LabeledSliderClass = {}
LabeledSliderClass.__index = LabeledSliderClass

local rbxGuiLibrary = assert(LoadLibrary('RbxGui'))
function LabeledSliderClass.new(nameSuffix, labelText, sliderIntervals, defaultValue)
	local self = {}
	setmetatable(self, LabeledSliderClass)

    self._valueChangedFunction = nil

    local sliderIntervals = sliderIntervals or 100
    local defaultValue = defaultValue or 1

    local frame = GuiUtilities.MakeStandardFixedHeightFrame('Slider ' .. nameSuffix)
    frame.Parent = parent
    self._frame = frame

    local label = GuiUtilities.MakeStandardPropertyLabel(labelText)
    label.Parent = frame
    self._label = label

    self._value = defaultValue

    local slider, sliderValue = rbxGuiLibrary.CreateSlider(sliderIntervals, 90, UDim2.new(0, 0, .5, -3)) --steps, width, position
    self._slider = slider
    self._sliderValue = sliderValue

    sliderValue.Changed:connect(function()
        self._value = sliderValue.Value
        if self._valueChangedFunction then 
            self._valueChangedFunction(self._value)
        end
    end)
    
    self:SetValue(defaultValue)
    slider.AnchorPoint = Vector2.new(0, 0.5)
    slider.Size = UDim2.new(0, kSliderWidth, 1, 0)
    slider.Position = UDim2.new(0, GuiUtilities.StandardLineElementLeftMargin, 0, GuiUtilities.kStandardPropertyHeight/2)
    slider.Parent = frame

    return self
end

function LabeledSliderClass:SetValueChangedFunction(vcf)
    self._valueChangedFunction = vcf
end

function LabeledSliderClass:GetFrame()
    return self._frame
end

function LabeledSliderClass:SetValue(newValue)
    if self._sliderValue.Value ~= newValue then
        self._sliderValue.Value = newValue
    end
end


return LabeledSliderClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX280f89632479457f844811a0b652087a">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LabeledTextInput</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- LabeledTextInput.lua
--
-- Creates a frame containing a label and a text input control.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

local kTextInputWidth = 100
local kTextBoxInternalPadding = 4

local kMaxCharacters = 10

LabeledTextInputClass = {}
LabeledTextInputClass.__index = LabeledTextInputClass

function LabeledTextInputClass.new(nameSuffix, labelText, defaultValue)
	local self = {}
	setmetatable(self, LabeledTextInputClass)

    self._valueChangedFunction = nil

    local defaultValue = defaultValue or ""

    local frame = GuiUtilities.MakeStandardFixedHeightFrame('TextInput ' .. nameSuffix)
    frame.Parent = parent
    self._frame = frame

    local label = GuiUtilities.MakeStandardPropertyLabel(labelText)
    label.Parent = frame
    self._label = label

    self._value = defaultValue

    -- Dumb hack to add padding to text box,
    local textBoxWrapperFrame = Instance.new("Frame")
    textBoxWrapperFrame.Name = "Wrapper"
    textBoxWrapperFrame.BackgroundColor3 = GuiUtilities.kStandardWhite
    textBoxWrapperFrame.Size = UDim2.new(0, kTextInputWidth, 0.7, 0)
    textBoxWrapperFrame.Position = UDim2.new(0, GuiUtilities.StandardLineElementLeftMargin, .5, 0)
    textBoxWrapperFrame.AnchorPoint = Vector2.new(0, .5)
    textBoxWrapperFrame.Parent = frame

    local textBox = Instance.new("TextBox")
    textBox.Parent = textBoxWrapperFrame
    textBox.Name = "TextBox"
    textBox.Text = defaultValue
    textBox.BackgroundTransparency = 1
    textBox.TextXAlignment = Enum.TextXAlignment.Left
    textBox.Size = UDim2.new(1, -kTextBoxInternalPadding, 1, 0)
    textBox.Position = UDim2.new(0, kTextBoxInternalPadding, 0, 0)
    textBox.ClipsDescendants = true
    
    textBox:GetPropertyChangedSignal("Text"):connect(function()
        -- Never let the text be too long.
        if (string.len(self._textBox.Text) > kMaxCharacters) then 
            self._textBox.Text = string.sub(self._textBox.Text, 1, kMaxCharacters)
            return
        end

        self._value = self._textBox.Text
        if (self._valueChangedFunction) then 
            self._valueChangedFunction(self._value)
        end
    end)
    
    self._textBox = textBox

    return self
end

function LabeledTextInputClass:SetValueChangedFunction(vcf)
    self._valueChangedFunction = vcf
end

function LabeledTextInputClass:GetFrame()
    return self._frame
end

function LabeledTextInputClass:GetValue()
    return self._value
end

function LabeledTextInputClass:SetValue(newValue)
    if self._value ~= newValue then
        self._textBox.Text = newValue
    end
end

return LabeledTextInputClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXa53c834734504f128a6b32ce97e9e941">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">VerticallyScalingListFrame</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- VerticallyScalingListFrame
--
-- Creates a frame that organizes children into a list layout.
-- Will scale dynamically as children grow.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)

VerticallyScalingListFrameClass = {}
VerticallyScalingListFrameClass.__index = VerticallyScalingListFrameClass


function VerticallyScalingListFrameClass.new(nameSuffix)
	local self = {}
	setmetatable(self, VerticallyScalingListFrameClass)

    self._resizeCallback = nil

    showTitle = showTitle or showTitle == nil
    
    local frame = Instance.new('Frame')
    frame.Name = 'VSLFrame' .. nameSuffix
    frame.Size = UDim2.new(1, 0, 0, height)
    frame.BackgroundTransparency = 0
    frame.BackgroundColor3 = Color3.new(1, 1, 1)
    frame.BorderSizePixel = 0

    self._frame = frame
    
    local uiListLayout = Instance.new('UIListLayout')
    uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
    uiListLayout.Parent = frame
    self._uiListLayout = uiListLayout

	local function updateSizes()
        self._frame.Size = UDim2.new(1, 0, 0, uiListLayout.AbsoluteContentSize.Y)
        if (self._resizeCallback) then 
            self._resizeCallback()
        end
	end
	self._uiListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):connect(updateSizes)
	updateSizes()

    self._childCount = 0

    return self
end

function VerticallyScalingListFrameClass:GetFrame()
    return self._frame
end

function VerticallyScalingListFrameClass:AddChild(childFrame)
    childFrame.LayoutOrder = self._childCount
    self._childCount = self._childCount + 1
    childFrame.Parent = self._frame
end

function VerticallyScalingListFrameClass:SetCallbackOnResize(callback)
    self._resizeCallback = callback
end

return VerticallyScalingListFrameClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX2c9ace526011406494b2be1cfd1c7622">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LabeledMultiChoice</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- LabeledMultiChoice.lua
--
-- Creates a frame containing a label and list of choices, of which exactly one 
-- is always selected.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)
LabeledRadioButton = require(script.Parent.LabeledRadioButton)
LabeledCheckbox = require(script.Parent.LabeledCheckbox)
VerticallyScalingListFrame = require(script.Parent.VerticallyScalingListFrame)

local kRadioButtonsHPadding = 24

LabeledMultiChoiceClass = {}
LabeledMultiChoiceClass.__index = LabeledMultiChoiceClass



function LabeledMultiChoiceClass.new(nameSuffix, labelText, choices, initChoiceIndex)
	local self = {}
	setmetatable(self, LabeledMultiChoiceClass)

    self._buttonObjsByIndex = {}

    if (not initChoiceIndex ) then 
        initChoiceIndex = 1
    end
    if (initChoiceIndex > #choices) then 
        initChoiceIndex = #choices
    end


    local vsl = VerticallyScalingListFrame.new("MCC_" .. nameSuffix)

	local titleLabel = GuiUtilities.MakeFrameWithSubSectionLabel("Title", labelText)
	vsl:AddChild(titleLabel)

	-- Container for cells.
	local cellFrame = self:_MakeRadioButtons(choices)
	vsl:AddChild(cellFrame)

    self._vsl = vsl

    self:SetSelectedIndex(initChoiceIndex)

    return self
end

function LabeledMultiChoiceClass:SetSelectedIndex(selectedIndex) 
    self._selectedIndex = selectedIndex
    for i = 1, #self._buttonObjsByIndex do 
        self._buttonObjsByIndex[i]:SetValue(i == selectedIndex)
    end

    if (self._valueChangedFunction) then 
        self._valueChangedFunction(self._selectedIndex)
    end
end

function LabeledMultiChoiceClass:GetSelectedIndex()
    return self._selectedIndex
end

function LabeledMultiChoiceClass:SetValueChangedFunction(vcf)
    self._valueChangedFunction = vcf
end

function LabeledMultiChoiceClass:GetFrame()
    return self._vsl:GetFrame()
end


-- Small checkboxes are a different entity.
-- All the bits are smaller.
-- Fixed width instead of flood-fill.
-- Box comes first, then label.
function LabeledMultiChoiceClass:_MakeRadioButtons(choices)
    local frame = GuiUtilities.MakeFrame("RadioButtons")
    frame.BackgroundTransparency = 1

	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, GuiUtilities.StandardLineLabelLeftMargin)
	padding.PaddingRight = UDim.new(0, GuiUtilities.StandardLineLabelLeftMargin)
	padding.Parent = frame
	
	-- Make a grid to put checkboxes in.
	local uiGridLayout = Instance.new("UIGridLayout")
	uiGridLayout.CellSize = LabeledCheckbox.kMinFrameSize
	uiGridLayout.CellPadding = UDim2.new(0, 
        kRadioButtonsHPadding,
		0,
		GuiUtilities.kStandardVMargin)
	uiGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	uiGridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	uiGridLayout.Parent = frame
	uiGridLayout.SortOrder = Enum.SortOrder.LayoutOrder

	for i, choiceData in ipairs(choices) do 
		self:_AddRadioButton(frame, i, choiceData)
	end

		-- Sync size with content size.
	GuiUtilities.AdjustHeightDynamicallyToLayout(frame, uiGridLayout)

	return frame
end

function LabeledMultiChoiceClass:_AddRadioButton(parentFrame, index, choiceData)
    local radioButtonObj = LabeledRadioButton.new(choiceData.Id, choiceData.Text)
    self._buttonObjsByIndex[index] = radioButtonObj

    radioButtonObj:SetValueChangedFunction(function(value)
        -- If we notice the button going from off to on, and it disagrees with 
        -- our current notion of selection, update selection.
        if (value and self._selectedIndex ~= index) then 
            self:SetSelectedIndex(index)
        end
    end)
    
	radioButtonObj:GetFrame().LayoutOrder = index
	radioButtonObj:GetFrame().Parent = parentFrame
end


return LabeledMultiChoiceClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX7b0aeda461124078ac12c7137cf7e2d9">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LabeledRadioButton</string>
				<string name="ScriptGuid"></string>
				<ProtectedString name="Source"><![CDATA[----------------------------------------
--
-- LabeledRadioButton.lua
--
-- Creates a frame containing a label and a radio button.
--
----------------------------------------
GuiUtilities = require(script.Parent.GuiUtilities)
LabeledCheckbox = require(script.Parent.LabeledCheckbox)

local kButtonImage = "http://www.roblox.com/asset/?id=1532774327"
local kBulletImage = "http://www.roblox.com/asset/?id=1532775081"

LabeledRadioButtonClass = {}
LabeledRadioButtonClass.__index = LabeledRadioButtonClass
setmetatable(LabeledRadioButtonClass, LabeledCheckbox)

function LabeledRadioButtonClass.new(nameSuffix, labelText)
	local newButton = LabeledCheckbox.new(nameSuffix, labelText, false)
    setmetatable(newButton, LabeledRadioButtonClass)

    newButton:UseSmallSize()
    newButton._checkImage.Position = UDim2.new(0.5, 0, 0.5, 0)
    newButton._checkImage.Image = kBulletImage

    newButton._button.Image = kButtonImage
    newButton._button.BackgroundTransparency = 1

    return newButton
end

function LabeledRadioButtonClass:_SetupMouseClickHandling()
    -- We are only allowed to toggle from off to on.
    self._button.MouseButton1Down:connect(function()
        if not self._disabled then
            if (not self._value) then 
                self:SetValue(not self._value)
            end
        end
    end)
end



return LabeledRadioButtonClass]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>